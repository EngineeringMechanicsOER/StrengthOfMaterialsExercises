% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrreprt}

\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else  
    % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\setcounter{secnumdepth}{2}
% Make \paragraph and \subparagraph free-standing
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
% definitions for citeproc citations
\NewDocumentCommand\citeproctext{}{}
\NewDocumentCommand\citeproc{mm}{%
  \begingroup\def\citeproctext{#2}\cite{#1}\endgroup}
\makeatletter
 % allow citations to break across lines
 \let\@cite@ofmt\@firstofone
 % avoid brackets around text for \cite:
 \def\@biblabel#1{}
 \def\@cite#1#2{{#1\if@tempswa , #2\fi}}
\makeatother
\newlength{\cslhangindent}
\setlength{\cslhangindent}{1.5em}
\newlength{\csllabelwidth}
\setlength{\csllabelwidth}{3em}
\newenvironment{CSLReferences}[2] % #1 hanging-indent, #2 entry-spacing
 {\begin{list}{}{%
  \setlength{\itemindent}{0pt}
  \setlength{\leftmargin}{0pt}
  \setlength{\parsep}{0pt}
  % turn on hanging indent if param 1 is 1
  \ifodd #1
   \setlength{\leftmargin}{\cslhangindent}
   \setlength{\itemindent}{-1\cslhangindent}
  \fi
  % set entry spacing
  \setlength{\itemsep}{#2\baselineskip}}}
 {\end{list}}
\usepackage{calc}
\newcommand{\CSLBlock}[1]{\hfill\break\parbox[t]{\linewidth}{\strut\ignorespaces#1\strut}}
\newcommand{\CSLLeftMargin}[1]{\parbox[t]{\csllabelwidth}{\strut#1\strut}}
\newcommand{\CSLRightInline}[1]{\parbox[t]{\linewidth - \csllabelwidth}{\strut#1\strut}}
\newcommand{\CSLIndent}[1]{\hspace{\cslhangindent}#1}

\KOMAoption{captions}{tableheading}
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage{bookmark}

\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={Strength of Materials Problem Exercises},
  pdfauthor={Curated by James Lord, Jake Grohs, \ldots{}},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}

\title{Strength of Materials Problem Exercises}
\author{Curated by James Lord, Jake Grohs, \ldots{}}
\date{2024-01-05}

\begin{document}
\maketitle

\renewcommand*\contentsname{Table of contents}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}
\bookmarksetup{startatroot}

\chapter*{Welcome to Demo Site}\label{welcome-to-demo-site}
\addcontentsline{toc}{chapter}{Welcome to Demo Site}

\markboth{Welcome to Demo Site}{Welcome to Demo Site}

Welcome to this demonstration site of the Strength of Materials Open
Problem Exercises companion to the Strength of Materials Open Textbook.

At this time, we are simply using this site as a demonstration and shell
for our ongoing work. The intent is to demonstrate a more traditional
static style problem exercise pack along with dynamic versions which
allow students to quickly check answers and receive basic feedback,
and/or to input their math in an interactive interface which will
provide them with targeted feedback based on their atempted solution.

This work is still very much in progress and you may find bugs. We would
welcome any input or feedback you have about this. Thanks!

\part{List of Complete Problems}

\chapter*{Problem 2.1}\label{problem-2.1}
\addcontentsline{toc}{chapter}{Problem 2.1}

\markboth{Problem 2.1}{Problem 2.1}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/138.png}

}

\caption{Figure 1: A series of solid circular bars are loaded with three
loads}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}


\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length))  }

\NormalTok{problem\_ID="138"}
\NormalTok{F1=reactive.Value("\_\_")}
\NormalTok{F2=reactive.Value("\_\_")}
\NormalTok{F3=reactive.Value("\_\_")}
\NormalTok{d1=8}
\NormalTok{d2=6}
\NormalTok{d3=10}
\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of MPa", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}
    
\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A series of solid circular bars are loaded with three loads as shown, F\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{F1()\} N, F\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{F2()\} N, and F\textless{}sub\textgreater{}3\textless{}/sub\textgreater{} = \{F3()\} N. What is the largest absolute normal stress in any bar?")]}
     
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        F1.set(random.randrange(50, 70, 1))}
\NormalTok{        F2.set(random.randrange(10, 30, 1))}
\NormalTok{        F3.set(F1(){-}F2())}
        

\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
        
\NormalTok{        \# Calculate the instructor\textquotesingle{}s answer and determine if the user\textquotesingle{}s answer is correct.}
\NormalTok{        instr= (F1()/(math.pi*(d2/(1000*2))**2))/10**6}
        
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 2.2}\label{problem-2.2}
\addcontentsline{toc}{chapter}{Problem 2.2}

\markboth{Problem 2.2}{Problem 2.2}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-1}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/139.png}

}

\caption{Figure 1: Two sylinders are stacked on top of each other.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length))  }

\NormalTok{problem\_ID="139"}
\NormalTok{L1=reactive.Value("\_\_")}
\NormalTok{L2=reactive.Value("\_\_")}
\NormalTok{FA=reactive.Value("\_\_")}
\NormalTok{FB=reactive.Value("\_\_")}
\NormalTok{E = 30*10**6}
  
\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of inches", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"Two cylinders are stacked on top of one another and two forces are applied at the top surface and at the joint between the cylinders as shown. If L\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{L1()\} in., L\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{L2()\} in., F\textless{}sub\textgreater{}A\textless{}/sub\textgreater{} = \{FA()\} lb, and F\textless{}sub\textgreater{}B\textless{}/sub\textgreater{} = \{FB()\} lb, find the total deflection in the stack of cylinders. Assume E = 30 x 10\textless{}sup\textgreater{}6\textless{}/sup\textgreater{} psi for both cylinders. ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        FA.set(random.randrange(300, 700, 10))}
\NormalTok{        FB.set(random.randrange(100, 300, 10))}
\NormalTok{        L1.set(random.randrange(2, 7, 1))}
\NormalTok{        L2.set(L1() * 1.3)}
        

\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
    
\NormalTok{        instr= (FA()*L1())/((math.pi*(5/2)**2)*E) + (FB()*L2())/((math.pi*(3/2)**2)*E)}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 2.3}\label{problem-2.3}
\addcontentsline{toc}{chapter}{Problem 2.3}

\markboth{Problem 2.3}{Problem 2.3}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-2}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/144.png}

}

\caption{Figure 1: A plastic cylindrical peg is constrained by a metal
cap}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length))}

\NormalTok{problem\_ID="144"}
\NormalTok{F=reactive.Value("\_\_")}
\NormalTok{d1=reactive.Value("\_\_")}
\NormalTok{d2=reactive.Value("\_\_")}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of psi", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A plastic cylindrical peg is constrained by a metal cap as shown. An axial load of F = \{F()\} lb is applied to the peg. If d\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{d1()\} in and d\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{d2()\} in, determine the normal stress in the peg. Assume the axial load is evenly distributed across the peg and that the metal cap is fixed and does not move.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        F.set(random.randrange(20, 80, 5))}
\NormalTok{        d1.set(random.randrange(3, 8, 1)/10)}
\NormalTok{        d2.set(round(d1() * 1.6, 2))}
        
 
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        instr= F()/(math.pi*((d1()/2)**2))}
\NormalTok{        \#check=math.isclose(float(input.answer()),instr,rel\_tol=0.001)}
        
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 2.4}\label{problem-2.4}
\addcontentsline{toc}{chapter}{Problem 2.4}

\markboth{Problem 2.4}{Problem 2.4}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-3}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/146.png}

}

\caption{Figure 1: A crate is suspended by a set of cables}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}


\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="146"}
\NormalTok{W=reactive.Value("\_\_")}
\NormalTok{d=reactive.Value("\_\_")}
\NormalTok{angle1=math.radians(45)}
\NormalTok{angle2=math.radians(30)}
\NormalTok{angle3=math.radians(75)}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of GPa", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A crate weighing \{W()\} kN is suspended by a set of cables. The diameter of each cable is \{d()\}  mm. What is the maximum stress in any cable, exluding the cable attached to the crate.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        W.set(random.randrange(30, 90, 1))}
\NormalTok{        d.set(random.randrange(20, 90, 1)/10)}
        

\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
    
\NormalTok{        R1 = W()/(((math.cos(angle1)/math.cos(angle2))*math.sin(angle2))+math.sin(angle1))}
\NormalTok{        instr= (R1*10**3/(math.pi*((d()/(1000*2))**2)))/10**9}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 2.47}\label{problem-2.47}
\addcontentsline{toc}{chapter}{Problem 2.47}

\markboth{Problem 2.47}{Problem 2.47}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-4}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/153.png}

}

\caption{Figure 1: Two slanted brackets are glued together}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length))  }

\NormalTok{problem\_ID="153"}
\NormalTok{F=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{Θ=reactive.Value("\_\_")}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of psi", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"Two slanted brackets are glued together as shown. If F = \{F()\} lb, L = \{L()\} in., and Θ = \{Θ()\} °, determine the shear stress parallel to the inclined plane. Assume loads are inline and there is no rotation.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        F.set(random.randrange(200, 800, 10))}
\NormalTok{        L.set(random.randrange(20, 80, 1)/10)}
\NormalTok{        Θ.set(random.randrange(15, 30, 1))}
        

\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
    
\NormalTok{        instr= (F()*math.sin(math.radians(Θ()))/(L()*2))}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 2.48}\label{problem-2.48}
\addcontentsline{toc}{chapter}{Problem 2.48}

\markboth{Problem 2.48}{Problem 2.48}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-5}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/156.png}

}

\caption{Figure 1: A 2 inch thick board is cut and then glued back
together along a line}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length))  }

\NormalTok{problem\_ID="156"}
\NormalTok{F=reactive.Value("\_\_")}
\NormalTok{h=reactive.Value("\_\_")}
\NormalTok{Θ=reactive.Value("\_\_")}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of psi", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A 2 inch thick board is cut and then glued back together along a line that is Θ = \{Θ()\} ° off the vertical as shown. If height h = \{h()\} in. and F = \{F()\} lb, determine the normal stress along the cut line.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        F.set(random.randrange(2000, 6000, 100))}
\NormalTok{        h.set(random.randrange(50, 150, 1)/10)}
\NormalTok{        Θ.set(random.randrange(10, 20, 1))}
        

\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
        
\NormalTok{        instr= (F()/(2*h()))*(math.cos(math.radians(Θ()))**2)}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 4.37}\label{problem-4.37}
\addcontentsline{toc}{chapter}{Problem 4.37}

\markboth{Problem 4.37}{Problem 4.37}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-6}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/157.png}

}

\caption{Figure 1: A small truss is constructed with solid square wood
members}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length))  }

\NormalTok{problem\_ID="157"}
\NormalTok{F=reactive.Value("\_\_")}
\NormalTok{FS=reactive.Value("\_\_")}
\NormalTok{σfail=reactive.Value("\_\_")}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of centimeters", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A small truss is constructed with solid square wood members and subjected to a load of F = \{F()\} kN. Determine the minimum dimension, a, of the member so that the truss will have a factor of safety of \{FS()\}. All members have the same cross{-}section. The wood has a failure stress of σ\textless{}sub\textgreater{}fail\textless{}/sub\textgreater{} = \{σfail()\} MPa.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        F.set(random.randrange(15, 50, 1))}
\NormalTok{        FS.set(random.randrange(15, 40, 1)/10)}
\NormalTok{        σfail.set(random.randrange(40, 60, 1))}
        

\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
    
\NormalTok{        dl = FS()*F()}
\NormalTok{        A = (dl/(σfail()*10**3))*100*100}
\NormalTok{        instr= math.sqrt(A)}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 2.21}\label{problem-2.21}
\addcontentsline{toc}{chapter}{Problem 2.21}

\markboth{Problem 2.21}{Problem 2.21}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-7}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/164.png}

}

\caption{Figure 1: A double lap joint is glued together}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length))  }

\NormalTok{problem\_ID="164"}
\NormalTok{τfail=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{t=reactive.Value("\_\_")}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of kips", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A double lap joint is glued together using glue with a shear stress failure strength of \{τfail()\} psi. If dimensions L = \{L()\} in. and t = \{t()\} in., what is the maximum load P that the joint can withstand? Assume the load is evenly distributed across the joint on both sides.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        τfail.set(random.randrange(7000, 9000, 100))}
\NormalTok{        L.set(random.randrange(40, 100, 1)/10)}
\NormalTok{        t.set(random.randrange(40, 100, 1)/10)}
        

\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
    
\NormalTok{        A = L()*t()*2}
\NormalTok{        instr= (τfail()*A)/1000}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 2.22}\label{problem-2.22}
\addcontentsline{toc}{chapter}{Problem 2.22}

\markboth{Problem 2.22}{Problem 2.22}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-8}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/165.png}

}

\caption{Figure 1: A bracket is attached to a wall with two circular
rivets}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length))}

\NormalTok{problem\_ID="165"}
\NormalTok{F=reactive.Value("\_\_")}
\NormalTok{d=reactive.Value("\_\_")}


\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of MPa", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A bracket is attached to a wall with two circular rivets of diameter d = \{d()\} mm. A load F = \{F()\} kN is applied in the center of the bracket. Assuming the load is split evenly between the two rivits, determine the shear stress in each rivet. ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        F.set(random.randrange(30, 100, 1))}
\NormalTok{        d.set(random.randrange(10, 40, 1))}
        

\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.  }
      
\NormalTok{        A = math.pi*(d()/(1000*2))**2}
\NormalTok{        instr= ((F()/2)/A)/1000}
\NormalTok{        if math.isclose(float(input.answer()), instr, abs\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 2.37}\label{problem-2.37}
\addcontentsline{toc}{chapter}{Problem 2.37}

\markboth{Problem 2.37}{Problem 2.37}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-9}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/166.png}

}

\caption{Figure 1: A crate is hanged on a circular solid metal rod.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{problem\_ID="166"}
\NormalTok{W=reactive.Value("\_\_")}
\NormalTok{d1=reactive.Value("\_\_")}
\NormalTok{d2=reactive.Value("\_\_")}
\NormalTok{t=reactive.Value("\_\_")}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of ksi", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A crate of weight W = \{W()\} lb hangs from a solid circular metal rod of diameter d\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{d1()\} in.. The cable is wrapped around a support collar of diameter d\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{d2()\} in. and thickness t = \{t()\} in. to evenly distribute the cable load. What is the bearing stress on the support collar due to the rod? ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        W.set(random.randrange(4000, 9000, 100))}
\NormalTok{        d1.set(random.randrange(5, 30, 1)/10)}
\NormalTok{        d2.set(round(d1() * 3, 2))}
\NormalTok{        t.set(round(d1() * 2, 2))}

\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
    
\NormalTok{        instr= (W()/(d1()*t()))/1000}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\part{Interactive Interface Demo}

\chapter*{Interactive Problem
Interface}\label{interactive-problem-interface}
\addcontentsline{toc}{chapter}{Interactive Problem Interface}

\markboth{Interactive Problem Interface}{Interactive Problem Interface}

To scaffold your learning in this example, we have provided a free body
diagram for you and a repeat of the problem statement.

A city planner is installing a new traffic light. Light A weighs 65 lb,
while lights B and C weigh 50 lb each. The post at O has a hollow
circular cross-section with an outer diameter of 5 inches and a wall
thickness of 0.2 inches. Please calculate the magnitude of the maximum
combined stress in the post. You may ignore the weight of the post.

\begin{figure}[H]

{\centering \includegraphics{images/stoplights.png}

}

\caption{Figure 1: Three traffic light installation with loads}

\end{figure}%

Please work through the problem step by step showing your math in the
interactive interface here.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}



\NormalTok{import io}
\NormalTok{import numpy as np}
\NormalTok{import asyncio}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}
\NormalTok{import matplotlib.pyplot as plt}
\NormalTok{from shiny import App, render, ui, reactive, req}
\NormalTok{from sympy import solve, Eq, Symbol}
\NormalTok{from sympy.parsing.sympy\_parser import parse\_expr}
\NormalTok{from shiny.ui import h4}

\NormalTok{\# load equations lists}


\NormalTok{class eqn:}
\NormalTok{    def \_\_init\_\_(self, name, inline\_math, newline\_math, working\_sym, working\_eqn\_latex,working\_eqn\_solver):}
\NormalTok{        self.name = name}
\NormalTok{        self.inline\_math = inline\_math}
\NormalTok{        self.newline\_math = newline\_math}
\NormalTok{        self.working\_sym = working\_sym}
\NormalTok{        self.working\_eqn\_latex = working\_eqn\_latex}
\NormalTok{        self.working\_eqn\_solver = working\_eqn\_solver}

\NormalTok{StaticsSumFx = eqn(}
\NormalTok{    "Equilibrium Forces in X", }
\NormalTok{    "\textbackslash{}(\textbackslash{}Sigma F\_x=0\textbackslash{})", }
\NormalTok{    "$$\textbackslash{}Sigma F\_x=0$$", }
\NormalTok{    "SigmaFx",}
\NormalTok{    "$$F\_x1+F\_x2+F\_x3+F\_x4+F\_x5=0$$",}
\NormalTok{    "F\_x1+F\_x2+F\_x3+F\_x4+F\_x5=0"}
\NormalTok{)}

\NormalTok{StaticsSumFy = eqn(}
\NormalTok{    "Equilibrium Forces in Y", }
\NormalTok{    "\textbackslash{}(\textbackslash{}Sigma F\_y=0\textbackslash{})", }
\NormalTok{    "$$\textbackslash{}Sigma F\_y=0$$", }
\NormalTok{    "SigmaFy",}
\NormalTok{    "$$F\_y1+F\_y2+F\_y3+F\_y4+F\_y5=0$$",}
\NormalTok{    "F\_y1+F\_y2+F\_y3+F\_y4+F\_y5=0"}
\NormalTok{)}

\NormalTok{StaticsSumM = eqn(}
\NormalTok{    "Equilibrium Moments about O", }
\NormalTok{    "\textbackslash{}(\textbackslash{}Sigma M\_O=0\textbackslash{})", }
\NormalTok{    "$$\textbackslash{}Sigma M\_O=0$$", }
\NormalTok{    "SigmaM",}
\NormalTok{    "$$M\_1+M\_2+M\_3+M\_4+M\_5=0$$",}
\NormalTok{    "M\_1+M\_2+M\_3+M\_4+M\_5=0"}
\NormalTok{)}

\NormalTok{StressEqn = eqn(}
\NormalTok{    "Stress Equation", }
\NormalTok{    "\textbackslash{}(\textbackslash{}sigma=\textbackslash{}\textbackslash{}frac\{F\}\{A\}\textbackslash{})", }
\NormalTok{    "$$\textbackslash{}sigma=\textbackslash{}\textbackslash{}frac\{F\}\{A\}$$", }
\NormalTok{    "sigma,F,A",}
\NormalTok{    "$$\textbackslash{}sigma=\textbackslash{}\textbackslash{}frac\{(F)\}\{(A)\}$$",}
\NormalTok{    "Eq(sigma,(F)/(A))"}
\NormalTok{)}

\NormalTok{AxialDeform = eqn(}
\NormalTok{    "Axial Deformation by Force",}
\NormalTok{    "\textbackslash{}(\textbackslash{}delta\_l=\textbackslash{}\textbackslash{}frac\{P L\}\{AE\}\textbackslash{})",}
\NormalTok{    "$$\textbackslash{}delta\_l=\textbackslash{}\textbackslash{}frac\{P\textbackslash{}cdot L\}\{A \textbackslash{}cdot E\}$$",}
\NormalTok{    "delta\_l,P,L,A,E",}
\NormalTok{    "$$\textbackslash{}delta\_l=\textbackslash{}\textbackslash{}frac\{(P)(L)\}\{(A)(E)\}$$",}
\NormalTok{    "Eq(delta\_l,(P)*(L)/(A)/(E))"}
\NormalTok{)}

\NormalTok{ThermalDeform = eqn(}
\NormalTok{    "Axial Deformation by Thermal",}
\NormalTok{    "\textbackslash{}(\textbackslash{}delta\_t= \textbackslash{}\textbackslash{}alpha \textbackslash{}Delta T L\textbackslash{})",}
\NormalTok{    "$$\textbackslash{}delta\_t= \textbackslash{}\textbackslash{}alpha \textbackslash{}cdot \textbackslash{}Delta T \textbackslash{}cdot L$$",}
\NormalTok{    "delta\_t,alpha,DeltaT,L",}
\NormalTok{    "$$\textbackslash{}delta\_t= \textbackslash{}\textbackslash{}alpha \textbackslash{}Delta T L$$",}
\NormalTok{    "delta\_t= alpha*(Delta\_T)*L"}
\NormalTok{)}

\NormalTok{AreaTube = eqn(}
\NormalTok{    "Area of a Tube", }
\NormalTok{    "\textbackslash{}(A\_\{tube\}=\textbackslash{}pi(r\_o\^{}2{-}r\_i\^{}2)\textbackslash{})", }
\NormalTok{    "$$A\_\{tube\}=\textbackslash{}pi(r\_o\^{}2{-}r\_i\^{}2)$$", }
\NormalTok{    "A\_tube,r\_o,r\_i",}
\NormalTok{    "$$A\_\{tube\}=\textbackslash{}pi(r\_o\^{}2{-}r\_i\^{}2)$$",}
\NormalTok{    "Eq(A\_tube,pi*((r\_o)**2{-}(r\_i)**2))"}
\NormalTok{)}

\NormalTok{ITube = eqn(}
\NormalTok{    "Moment of Inertia of a Tube",}
\NormalTok{    "\textbackslash{}(I\_\{tube\}=\textbackslash{}\textbackslash{}frac\{\textbackslash{}pi\}\{4\}(r\_o\^{}4{-}r\_i\^{}4)\textbackslash{})",}
\NormalTok{    "$$I\_\{tube\}=\textbackslash{}\textbackslash{}frac\{\textbackslash{}pi\}\{4\}(r\_o\^{}4{-}r\_i\^{}4)$$",}
\NormalTok{    "I\_tube,r\_o,r\_i",}
\NormalTok{    "$$I\_\{tube\}=\textbackslash{}\textbackslash{}frac\{\textbackslash{}pi\}\{4\}(r\_o\^{}4{-}r\_i\^{}4)$$", }
\NormalTok{    "Eq(I\_tube,pi/4*((r\_o)**4{-}(r\_i)**4))" }
\NormalTok{)}

\NormalTok{BendingStress = eqn(}
\NormalTok{    "Bending Stress from a Moment",}
\NormalTok{    "\textbackslash{}(\textbackslash{}sigma\_b=\textbackslash{}\textbackslash{}frac\{M*y\}\{I\}\textbackslash{})",}
\NormalTok{    "$$\textbackslash{}sigma\_b=\textbackslash{}\textbackslash{}frac\{M*y\}\{I\}$$",}
\NormalTok{    "sigma\_b,M,y,I,",}
\NormalTok{    "$$\textbackslash{}sigma\_b=\textbackslash{}\textbackslash{}frac\{M*y\}\{I\}$$", }
\NormalTok{    "Eq(sigma\_b,M*y/I))" }
\NormalTok{)}

\NormalTok{Compatability1 = eqn(}
\NormalTok{    "Compatability Equation 1",}
\NormalTok{    "\textbackslash{}(a\_1+\textbackslash{}ldots=b\_1+b\_2+\textbackslash{}ldots\textbackslash{})", }
\NormalTok{    "$$a\_1+\textbackslash{}ldots=b\_1+b\_2+\textbackslash{}ldots$$", }
\NormalTok{    "",}
\NormalTok{    "$$a\_1+a\_n=b\_1+b\_n$$",}
\NormalTok{    "Eq(a\_1+a\_n=b\_1+b\_n)" }
\NormalTok{)}

\NormalTok{Compatability2 = eqn(}
\NormalTok{    "Compatability Equation 2",}
\NormalTok{    "\textbackslash{}(c\_1+\textbackslash{}ldots=d\_1+d\_2+\textbackslash{}ldots\textbackslash{})", }
\NormalTok{    "$$c\_1+\textbackslash{}ldots=d\_1+d\_2+\textbackslash{}ldots$$", }
\NormalTok{    "",}
\NormalTok{    "$$c\_1+c\_n=d\_1+d\_n$$",}
\NormalTok{    "Eq(c\_1+c\_n=d\_1+d\_n)" }
\NormalTok{)}


\NormalTok{statics\_eqnbank\_inline = \{}
\NormalTok{    StaticsSumFx.name: StaticsSumFx.inline\_math,}
\NormalTok{    StaticsSumFy.name: StaticsSumFy.inline\_math,}
\NormalTok{    StaticsSumM.name: StaticsSumM.inline\_math,}
\NormalTok{\}}
\NormalTok{deforms\_eqnbank\_inline = \{}
\NormalTok{    StressEqn.name: StressEqn.inline\_math,}
\NormalTok{    AxialDeform.name: AxialDeform.inline\_math,}
\NormalTok{    ThermalDeform.name: ThermalDeform.inline\_math,}
\NormalTok{\}}

\NormalTok{geom\_eqnbank\_inline = \{}
\NormalTok{    AreaTube.name: AreaTube.inline\_math,}
\NormalTok{    ITube.name: ITube.inline\_math,}
\NormalTok{\}}

\NormalTok{eqnbank\_inline = \{}
\NormalTok{    StaticsSumFx.name: StaticsSumFx.inline\_math,}
\NormalTok{    StaticsSumFy.name: StaticsSumFy.inline\_math,}
\NormalTok{    StaticsSumM.name: StaticsSumM.inline\_math,}
\NormalTok{    StressEqn.name: StressEqn.inline\_math,}
\NormalTok{    BendingStress.name: BendingStress.inline\_math,}
\NormalTok{    AxialDeform.name: AxialDeform.inline\_math,}
\NormalTok{    ThermalDeform.name: ThermalDeform.inline\_math,}
\NormalTok{    AreaTube.name: AreaTube.inline\_math,}
\NormalTok{    ITube.name: ITube.inline\_math,}
\NormalTok{    Compatability1.name: Compatability1.inline\_math,}
\NormalTok{    Compatability2.name: Compatability2.inline\_math,}
\NormalTok{\}}

\NormalTok{eqnbank\_newline = \{}
\NormalTok{    StaticsSumFx.name: StaticsSumFx.newline\_math,}
\NormalTok{    StaticsSumFy.name: StaticsSumFy.newline\_math,}
\NormalTok{    StaticsSumM.name: StaticsSumM.newline\_math,}
\NormalTok{    StressEqn.name: StressEqn.newline\_math,}
\NormalTok{    BendingStress.name: BendingStress.newline\_math,}
\NormalTok{    AxialDeform.name: AxialDeform.newline\_math,}
\NormalTok{    ThermalDeform.name: ThermalDeform.newline\_math,}
\NormalTok{    AreaTube.name: AreaTube.newline\_math,}
\NormalTok{    ITube.name: ITube.newline\_math,}
\NormalTok{    Compatability1.name: Compatability1.newline\_math,}
\NormalTok{    Compatability2.name: Compatability2.newline\_math,}
\NormalTok{\}}



\NormalTok{working\_equations\_solver=reactive.Value([])}
\NormalTok{working\_equations\_latex\_render=reactive.Value([])}
\NormalTok{working\_symbols=reactive.Value([])}

\NormalTok{feedback\_equations=reactive.Value([])}
\NormalTok{feedback\_solns=reactive.Value([])}
\NormalTok{feedback\_syms=reactive.Value([])}

\NormalTok{working\_SumFx\_render=reactive.Value("")}
\NormalTok{working\_SumFy\_render=reactive.Value("")}
\NormalTok{working\_SumM\_render=reactive.Value("")}
\NormalTok{working\_StressEqn\_render=reactive.Value("")}
\NormalTok{working\_BendingStress\_render=reactive.Value("")}
\NormalTok{working\_AxialDeform\_render=reactive.Value("")}
\NormalTok{working\_ThermalDeform\_render=reactive.Value("")}
\NormalTok{working\_AreaTube\_render=reactive.Value("")}
\NormalTok{working\_Itube\_render=reactive.Value("")}
\NormalTok{working\_Compatability1\_render=reactive.Value("")}
\NormalTok{working\_Compatability2\_render=reactive.Value("")}

\NormalTok{working\_SumFx\_string=reactive.Value("")}
\NormalTok{working\_SumFy\_string=reactive.Value("")}
\NormalTok{working\_SumM\_string=reactive.Value("")}
\NormalTok{working\_StressEqn\_string=reactive.Value("")}
\NormalTok{working\_BendingStress\_string=reactive.Value("")}
\NormalTok{working\_AxialDeform\_string=reactive.Value("")}
\NormalTok{working\_ThermalDeform\_string=reactive.Value("")}
\NormalTok{working\_AreaTube\_string=reactive.Value("")}
\NormalTok{working\_Itube\_string=reactive.Value("")}
\NormalTok{working\_Compatability1\_string=reactive.Value("")}
\NormalTok{working\_Compatability2\_string=reactive.Value("")}

\NormalTok{NumForcesY=reactive.Value(2)}
\NormalTok{F1y=reactive.Value("")}
\NormalTok{F2y=reactive.Value("")}
\NormalTok{F3y=reactive.Value("")}
\NormalTok{F4y=reactive.Value("")}
\NormalTok{F5y=reactive.Value("")}
\NormalTok{Equil\_latex=reactive.Value("")}

\NormalTok{NumForcesX=reactive.Value(2)}
\NormalTok{F1x=reactive.Value("")}
\NormalTok{F2x=reactive.Value("")}
\NormalTok{F3x=reactive.Value("")}
\NormalTok{F4x=reactive.Value("")}
\NormalTok{F5x=reactive.Value("")}

\NormalTok{NumMoments=reactive.Value(2)}
\NormalTok{M1=reactive.Value("")}
\NormalTok{M2=reactive.Value("")}
\NormalTok{M3=reactive.Value("")}
\NormalTok{M4=reactive.Value("")}
\NormalTok{M5=reactive.Value("")}

\NormalTok{axial\_stress\_sigma=reactive.Value("")}
\NormalTok{axial\_stress\_force=reactive.Value("")}
\NormalTok{axial\_stress\_area=reactive.Value("")}

\NormalTok{bending\_stress\_sigma=reactive.Value("")}
\NormalTok{bending\_stress\_M=reactive.Value("")}
\NormalTok{bending\_stress\_y=reactive.Value("")}
\NormalTok{bending\_stress\_I=reactive.Value("")}

\NormalTok{axial\_delta\_l=reactive.Value("")}
\NormalTok{axial\_P=reactive.Value("")}
\NormalTok{axial\_L=reactive.Value("")}
\NormalTok{axial\_A=reactive.Value("")}
\NormalTok{axial\_E=reactive.Value("")}

\NormalTok{thermal\_delta\_t=reactive.Value("")}
\NormalTok{thermal\_alpha=reactive.Value("")}
\NormalTok{thermal\_Delta\_T=reactive.Value("")}
\NormalTok{thermal\_L=reactive.Value("")}

\NormalTok{area\_tube\_A\_tube=reactive.Value("")}
\NormalTok{area\_tube\_Ar\_o=reactive.Value("")}
\NormalTok{area\_tube\_Ar\_i=reactive.Value("")}

\NormalTok{I\_tube\_I\_tube=reactive.Value("")}
\NormalTok{I\_tube\_Ir\_o=reactive.Value("")}
\NormalTok{i\_tube\_Ir\_i=reactive.Value("")}

\NormalTok{Compatability1\_NumLHS=reactive.Value(1)}
\NormalTok{Compatability1\_NumRHS=reactive.Value(2)}
\NormalTok{Compatability1\_a\_1=reactive.Value("")}
\NormalTok{Compatability1\_a\_2=reactive.Value("")}
\NormalTok{Compatability1\_a\_3=reactive.Value("")}
\NormalTok{Compatability1\_a\_4=reactive.Value("")}
\NormalTok{Compatability1\_a\_5=reactive.Value("")}
\NormalTok{Compatability1\_b\_1=reactive.Value("")}
\NormalTok{Compatability1\_b\_2=reactive.Value("")}
\NormalTok{Compatability1\_b\_3=reactive.Value("")}
\NormalTok{Compatability1\_b\_4=reactive.Value("")}
\NormalTok{Compatability1\_b\_5=reactive.Value("")}

\NormalTok{Compatability2\_NumLHS=reactive.Value(1)}
\NormalTok{Compatability2\_NumRHS=reactive.Value(2)}
\NormalTok{Compatability2\_c\_1=reactive.Value("")}
\NormalTok{Compatability2\_c\_2=reactive.Value("")}
\NormalTok{Compatability2\_c\_3=reactive.Value("")}
\NormalTok{Compatability2\_c\_4=reactive.Value("")}
\NormalTok{Compatability2\_c\_5=reactive.Value("")}
\NormalTok{Compatability2\_d\_1=reactive.Value("")}
\NormalTok{Compatability2\_d\_2=reactive.Value("")}
\NormalTok{Compatability2\_d\_3=reactive.Value("")}
\NormalTok{Compatability2\_d\_4=reactive.Value("")}
\NormalTok{Compatability2\_d\_5=reactive.Value("")}

\NormalTok{active\_eqn\_tab=reactive.Value("Instructions")}

\NormalTok{prob\_statement="To scaffold your learning in this example, we have provided a free body diagram for you and a repeat of the problem statement. A city planner is installing a new traffic light. Light A weighs 65 lb, while lights B and C weigh 50 lb each. The post at O has a hollow circular cross{-}section with an outer diameter of 5 inches and a wall thickness of 0.2 inches. Please calculate the magnitude of the maximum combined stress in the post. You may ignore the weight of the post."}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.head\_content(}
\NormalTok{        ui.tags.script(}
\NormalTok{            src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX{-}AMS{-}MML\_HTMLorMML"}
\NormalTok{        ),}
\NormalTok{        ui.tags.script(}
\NormalTok{            "if (window.MathJax) MathJax.Hub.Queue([\textquotesingle{}Typeset\textquotesingle{}, MathJax.Hub]);"}
\NormalTok{        ),}
\NormalTok{    ),}
\NormalTok{    ui.panel\_title("Interactive Problem Solving Environment"),}
\NormalTok{        ui.row(}
\NormalTok{            ui.column(6,}
\NormalTok{                ui.markdown("**Problem Statement**"),}
\NormalTok{                ui.markdown(prob\_statement),}
\NormalTok{                ),}
\NormalTok{            ui.column(6,ui.output\_ui("dyn\_ui\_nav")),}
\NormalTok{            ),}
\NormalTok{        \#ui.row(}
\NormalTok{        \#    ui.output\_ui("dyn\_ui\_nav"),}
\NormalTok{        \#    ),}
\NormalTok{        ui.row(}
\NormalTok{            ui.markdown("**Your Equation Workspace**"),}
\NormalTok{            \#ui.column(6,ui.output\_ui("dyn\_ui\_nav")),}
\NormalTok{            ui.column(4,}
\NormalTok{                ui.navset\_tab\_card(}
\NormalTok{                    ui.nav("Equation Bank",}
\NormalTok{                        ui.input\_checkbox\_group("selected\_eqns","Choose your equations:",eqnbank\_inline,}
\NormalTok{                        ),}
\NormalTok{                    ),}
\NormalTok{                ),}
\NormalTok{            ),}
\NormalTok{            ui.column(2,ui.output\_ui("dyn\_eqns"),style=\textquotesingle{}border{-}right:1px solid;\textquotesingle{}),}
\NormalTok{            ui.column(4,ui.output\_ui("dyn\_working\_eqns"),ui.output\_text("txt")),}
\NormalTok{        ),}
\NormalTok{        ui.row(}
\NormalTok{          ui.output\_ui("ui\_equation\_bookkeeping")}
\NormalTok{        ),}
\NormalTok{        \#ui.row(ui.input\_action\_button(}
\NormalTok{        \#            "solveEquations", "Solve Equations", class\_="btn{-}success", width="240px", style=\textquotesingle{}margin{-}bottom:10px\textquotesingle{})}
\NormalTok{        \#      ),}
\NormalTok{        ui.output\_ui("ui\_solutions"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
   
\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def dyn\_eqns():}
\NormalTok{        eqns\_keys = input.selected\_eqns()}
\NormalTok{        req(eqns\_keys)}
\NormalTok{        lookup\_eqns = [eqnbank\_newline[key] for key in eqns\_keys]}
\NormalTok{        mystring\_eqns = "".join(lookup\_eqns)}
\NormalTok{        feedback\_equations.set(lookup\_eqns)}

\NormalTok{        return [}
\NormalTok{            ui.markdown(mystring\_eqns),}
\NormalTok{            ui.tags.script(}
\NormalTok{                "if (window.MathJax) MathJax.Hub.Queue([\textquotesingle{}Typeset\textquotesingle{}, MathJax.Hub]);"}
\NormalTok{            ),}
\NormalTok{        ]}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def dyn\_working\_eqns():}
\NormalTok{        eqns\_keys = input.selected\_eqns()}
\NormalTok{        req(eqns\_keys)}
\NormalTok{        lookup\_eqns = [eqnbank\_newline[key] for key in eqns\_keys]}
        

\NormalTok{        \# Dynamic Filling of Force equations }
\NormalTok{        if StaticsSumFy.newline\_math in lookup\_eqns:}
\NormalTok{            StaticsSumFy\_list = ["F\_y1","F\_y2","F\_y3","F\_y4","F\_y5"]}
\NormalTok{            StaticsSumFy\_list = StaticsSumFy\_list[:input.NumForcesY()]}
\NormalTok{            StaticsSumFy.working\_sym = ",".join(StaticsSumFy\_list)}
\NormalTok{            StaticsSumFy.working\_eqn\_latex = "$$" + "+".join(StaticsSumFy\_list) + "=0$$"}
\NormalTok{            StaticsSumFy.working\_eqn\_solver = "+".join(StaticsSumFy\_list)}
            
\NormalTok{            if str(input.F1y()) != "" : }
\NormalTok{                StaticsSumFy.working\_eqn\_latex = StaticsSumFy.working\_eqn\_latex.replace("F\_y1",str(input.F1y()))}
\NormalTok{                StaticsSumFy.working\_sym = StaticsSumFy.working\_sym.replace("F\_y1",str(input.F1y()))}
\NormalTok{                StaticsSumFy.working\_eqn\_solver = StaticsSumFy.working\_eqn\_solver.replace("F\_y1",str(input.F1y()))}
\NormalTok{            else:}
\NormalTok{                StaticsSumFy.working\_eqn\_latex = StaticsSumFy.working\_eqn\_latex.replace("F\_y1","\textbackslash{}\textbackslash{}boxed\{F\_\{y\_1\}\}")}
        
\NormalTok{            if str(input.F2y()) != "" : }
\NormalTok{                StaticsSumFy.working\_eqn\_latex = StaticsSumFy.working\_eqn\_latex.replace("F\_y2",str(input.F2y()))}
\NormalTok{                StaticsSumFy.working\_sym = StaticsSumFy.working\_sym.replace("F\_y2",str(input.F2y()))}
\NormalTok{                StaticsSumFy.working\_eqn\_solver = StaticsSumFy.working\_eqn\_solver.replace("F\_y2",str(input.F2y()))}
\NormalTok{            else:}
\NormalTok{                StaticsSumFy.working\_eqn\_latex = StaticsSumFy.working\_eqn\_latex.replace("F\_y2","\textbackslash{}\textbackslash{}boxed\{F\_\{y\_2\}\}")}
        
\NormalTok{            if str(input.F3y()) != "" : }
\NormalTok{                StaticsSumFy.working\_eqn\_latex = StaticsSumFy.working\_eqn\_latex.replace("F\_y3",str(input.F3y()))}
\NormalTok{                StaticsSumFy.working\_sym = StaticsSumFy.working\_sym.replace("F\_y3",str(input.F3y()))}
\NormalTok{                StaticsSumFy.working\_eqn\_solver = StaticsSumFy.working\_eqn\_solver.replace("F\_y3",str(input.F3y()))}
\NormalTok{            else:}
\NormalTok{                StaticsSumFy.working\_eqn\_latex = StaticsSumFy.working\_eqn\_latex.replace("F\_y3","\textbackslash{}\textbackslash{}boxed\{F\_\{y\_3\}\}")}
        
\NormalTok{            if str(input.F4y()) != "" : }
\NormalTok{                StaticsSumFy.working\_eqn\_latex = StaticsSumFy.working\_eqn\_latex.replace("F\_y4",str(input.F4y()))}
\NormalTok{                StaticsSumFy.working\_sym = StaticsSumFy.working\_sym.replace("F\_y4",str(input.F4y()))}
\NormalTok{                StaticsSumFy.working\_eqn\_solver = StaticsSumFy.working\_eqn\_solver.replace("F\_y4",str(input.F4y()))}
\NormalTok{            else:}
\NormalTok{                StaticsSumFy.working\_eqn\_latex = StaticsSumFy.working\_eqn\_latex.replace("F\_y4","\textbackslash{}\textbackslash{}boxed\{F\_\{y\_4\}\}")}
        
\NormalTok{            if str(input.F5y()) != "" : }
\NormalTok{                StaticsSumFy.working\_eqn\_latex = StaticsSumFy.working\_eqn\_latex.replace("F\_y5",str(input.F5y()))}
\NormalTok{                StaticsSumFy.working\_sym = StaticsSumFy.working\_sym.replace("F\_y5",str(input.F5y()))}
\NormalTok{                StaticsSumFy.working\_eqn\_solver = StaticsSumFy.working\_eqn\_solver.replace("F\_y5",str(input.F5y()))}
\NormalTok{            else:}
\NormalTok{                StaticsSumFy.working\_eqn\_latex = StaticsSumFy.working\_eqn\_latex.replace("F\_y5","\textbackslash{}\textbackslash{}boxed\{F\_\{y\_5\}\}")}
      
\NormalTok{  \# Dynamic Filling of Force equations }
\NormalTok{        if StaticsSumFx.newline\_math in lookup\_eqns:}
\NormalTok{            StaticsSumFx\_list = ["F\_x1","F\_x2","F\_x3","F\_x4","F\_x5"]}
\NormalTok{            StaticsSumFx\_list = StaticsSumFx\_list[:input.NumForcesX()]}
\NormalTok{            StaticsSumFx.working\_sym = ",".join(StaticsSumFx\_list)}
\NormalTok{            StaticsSumFx.working\_eqn\_latex = "$$" + "+".join(StaticsSumFx\_list) + "=0$$"}
\NormalTok{            StaticsSumFx.working\_eqn\_solver = "+".join(StaticsSumFx\_list)}
            
\NormalTok{            if str(input.F1x()) != "" : }
\NormalTok{                StaticsSumFx.working\_eqn\_latex = StaticsSumFx.working\_eqn\_latex.replace("F\_x1",str(input.F1x()))}
\NormalTok{                StaticsSumFx.working\_sym = StaticsSumFx.working\_sym.replace("F\_x1",str(input.F1x()))}
\NormalTok{                StaticsSumFx.working\_eqn\_solver = StaticsSumFx.working\_eqn\_solver.replace("F\_x1",str(input.F1x()))}
\NormalTok{            else:}
\NormalTok{                StaticsSumFx.working\_eqn\_latex = StaticsSumFx.working\_eqn\_latex.replace("F\_x1","\textbackslash{}\textbackslash{}boxed\{F\_\{x\_1\}\}")}
        
\NormalTok{            if str(input.F2x()) != "" : }
\NormalTok{                StaticsSumFx.working\_eqn\_latex = StaticsSumFx.working\_eqn\_latex.replace("F\_x2",str(input.F2x()))}
\NormalTok{                StaticsSumFx.working\_sym = StaticsSumFx.working\_sym.replace("F\_x2",str(input.F2x()))}
\NormalTok{                StaticsSumFx.working\_eqn\_solver = StaticsSumFx.working\_eqn\_solver.replace("F\_x2",str(input.F2x()))}
\NormalTok{            else:}
\NormalTok{                StaticsSumFx.working\_eqn\_latex = StaticsSumFx.working\_eqn\_latex.replace("F\_x2","\textbackslash{}\textbackslash{}boxed\{F\_\{x\_2\}\}")}
        
\NormalTok{            if str(input.F3x()) != "" : }
\NormalTok{                StaticsSumFx.working\_eqn\_latex = StaticsSumFx.working\_eqn\_latex.replace("F\_x3",str(input.F3x()))}
\NormalTok{                StaticsSumFx.working\_sym = StaticsSumFx.working\_sym.replace("F\_x3",str(input.F3x()))}
\NormalTok{                StaticsSumFx.working\_eqn\_solver = StaticsSumFx.working\_eqn\_solver.replace("F\_x3",str(input.F3x()))}
\NormalTok{            else:}
\NormalTok{                StaticsSumFx.working\_eqn\_latex = StaticsSumFx.working\_eqn\_latex.replace("F\_x3","\textbackslash{}\textbackslash{}boxed\{F\_\{x\_3\}\}")}
        
\NormalTok{            if str(input.F4x()) != "" : }
\NormalTok{                StaticsSumFx.working\_eqn\_latex = StaticsSumFx.working\_eqn\_latex.replace("F\_x4",str(input.F4x()))}
\NormalTok{                StaticsSumFx.working\_sym = StaticsSumFx.working\_sym.replace("F\_x4",str(input.F4x()))}
\NormalTok{                StaticsSumFx.working\_eqn\_solver = StaticsSumFx.working\_eqn\_solver.replace("F\_x4",str(input.F4x()))}
\NormalTok{            else:}
\NormalTok{                StaticsSumFx.working\_eqn\_latex = StaticsSumFx.working\_eqn\_latex.replace("F\_x4","\textbackslash{}\textbackslash{}boxed\{F\_\{x\_4\}\}")}
        
\NormalTok{            if str(input.F5x()) != "" : }
\NormalTok{                StaticsSumFx.working\_eqn\_latex = StaticsSumFx.working\_eqn\_latex.replace("F\_x5",str(input.F5x()))}
\NormalTok{                StaticsSumFx.working\_sym = StaticsSumFx.working\_sym.replace("F\_x5",str(input.F5x()))}
\NormalTok{                StaticsSumFx.working\_eqn\_solver = StaticsSumFx.working\_eqn\_solver.replace("F\_x5",str(input.F5x()))}
\NormalTok{            else:}
\NormalTok{                StaticsSumFx.working\_eqn\_latex = StaticsSumFx.working\_eqn\_latex.replace("F\_x5","\textbackslash{}\textbackslash{}boxed\{F\_\{x\_5\}\}")}
                
                
\NormalTok{        \# Dynamic Filling of Moment equations }
\NormalTok{        if StaticsSumM.newline\_math in lookup\_eqns:}
\NormalTok{            StaticsSumM\_list = ["M\_1","M\_2","M\_3","M\_4","M\_5"]}
\NormalTok{            StaticsSumM\_list = StaticsSumM\_list[:input.NumMoments()]}
\NormalTok{            StaticsSumM.working\_sym = ",".join(StaticsSumM\_list)}
\NormalTok{            StaticsSumM.working\_eqn\_latex = "$$" + "+".join(StaticsSumM\_list) + "=0$$"}
\NormalTok{            StaticsSumM.working\_eqn\_solver = "+".join(StaticsSumM\_list)}
            
\NormalTok{            if str(input.M1()) != "" : }
\NormalTok{                StaticsSumM.working\_eqn\_latex = StaticsSumM.working\_eqn\_latex.replace("M\_1",str(input.M1()))}
\NormalTok{                StaticsSumM.working\_sym = StaticsSumM.working\_sym.replace("M\_1",str(input.M1()))}
\NormalTok{                StaticsSumM.working\_eqn\_solver = StaticsSumM.working\_eqn\_solver.replace("M\_1",str(input.M1()))}
\NormalTok{            else:}
\NormalTok{                StaticsSumM.working\_eqn\_latex = StaticsSumM.working\_eqn\_latex.replace("M\_1","\textbackslash{}\textbackslash{}boxed\{M\_1\}")}
        
\NormalTok{            if str(input.M2()) != "" : }
\NormalTok{                StaticsSumM.working\_eqn\_latex = StaticsSumM.working\_eqn\_latex.replace("M\_2",str(input.M2()))}
\NormalTok{                StaticsSumM.working\_sym = StaticsSumM.working\_sym.replace("M\_2",str(input.M2()))}
\NormalTok{                StaticsSumM.working\_eqn\_solver = StaticsSumM.working\_eqn\_solver.replace("M\_2",str(input.M2()))}
\NormalTok{            else:}
\NormalTok{                StaticsSumM.working\_eqn\_latex = StaticsSumM.working\_eqn\_latex.replace("M\_2","\textbackslash{}\textbackslash{}boxed\{M\_2\}")}
        
\NormalTok{            if str(input.M3()) != "" : }
\NormalTok{                StaticsSumM.working\_eqn\_latex = StaticsSumM.working\_eqn\_latex.replace("M\_3",str(input.M3()))}
\NormalTok{                StaticsSumM.working\_sym = StaticsSumM.working\_sym.replace("M\_3",str(input.M3()))}
\NormalTok{                StaticsSumM.working\_eqn\_solver = StaticsSumM.working\_eqn\_solver.replace("M\_3",str(input.M3()))}
\NormalTok{            else:}
\NormalTok{                StaticsSumM.working\_eqn\_latex = StaticsSumM.working\_eqn\_latex.replace("M\_3","\textbackslash{}\textbackslash{}boxed\{M\_3\}")}
        
\NormalTok{            if str(input.M4()) != "" : }
\NormalTok{                StaticsSumM.working\_eqn\_latex = StaticsSumM.working\_eqn\_latex.replace("M\_4",str(input.M4()))}
\NormalTok{                StaticsSumM.working\_sym = StaticsSumM.working\_sym.replace("M\_4",str(input.M4()))}
\NormalTok{                StaticsSumM.working\_eqn\_solver = StaticsSumM.working\_eqn\_solver.replace("M\_4",str(input.M4()))}
\NormalTok{            else:}
\NormalTok{                StaticsSumM.working\_eqn\_latex = StaticsSumM.working\_eqn\_latex.replace("M\_4","\textbackslash{}\textbackslash{}boxed\{M\_4\}")}
        
\NormalTok{            if str(input.M5()) != "" : }
\NormalTok{                StaticsSumM.working\_eqn\_latex = StaticsSumM.working\_eqn\_latex.replace("M\_5",str(input.M5()))}
\NormalTok{                StaticsSumM.working\_sym = StaticsSumM.working\_sym.replace("M\_5",str(input.M5()))}
\NormalTok{                StaticsSumM.working\_eqn\_solver = StaticsSumM.working\_eqn\_solver.replace("M\_5",str(input.M5()))}
\NormalTok{            else:}
\NormalTok{                StaticsSumM.working\_eqn\_latex = StaticsSumM.working\_eqn\_latex.replace("M\_5","\textbackslash{}\textbackslash{}boxed\{M\_5\}")}
          
        
\NormalTok{        \# Dynamic Filling of A equations }
\NormalTok{        if AreaTube.newline\_math in lookup\_eqns:}
\NormalTok{            AreaTube.working\_eqn\_latex = AreaTube.newline\_math}
\NormalTok{            AreaTube.working\_eqn\_solver = "Eq(A\_tube,pi*((r\_o)**2{-}(r\_i)**2))"}
\NormalTok{            AreaTube.working\_sym = "A\_tube,r\_o,r\_i"}
            
\NormalTok{            if str(input.A\_tube()) != "" : }
\NormalTok{                AreaTube.working\_eqn\_latex = AreaTube.working\_eqn\_latex.replace("A\_\{tube\}",str(input.A\_tube()))}
\NormalTok{                AreaTube.working\_sym = AreaTube.working\_sym.replace("A\_tube",str(input.A\_tube()))}
\NormalTok{                AreaTube.working\_eqn\_solver = AreaTube.working\_eqn\_solver.replace("A\_tube",str(input.A\_tube()))}
\NormalTok{            else:}
\NormalTok{                AreaTube.working\_eqn\_latex = AreaTube.working\_eqn\_latex.replace("A\_\{tube\}","\textbackslash{}\textbackslash{}boxed\{A\_\{tube\}\}")}
\NormalTok{            if str(input.Ar\_o()) != "" : }
\NormalTok{                AreaTube.working\_eqn\_latex = AreaTube.working\_eqn\_latex.replace("r\_o",str(input.Ar\_o()))}
\NormalTok{                AreaTube.working\_sym = AreaTube.working\_sym.replace("r\_o",str(input.Ar\_o()))}
\NormalTok{                AreaTube.working\_eqn\_solver = AreaTube.working\_eqn\_solver.replace("r\_o",str(input.Ar\_o()))}
\NormalTok{            else:}
\NormalTok{                AreaTube.working\_eqn\_latex = AreaTube.working\_eqn\_latex.replace("r\_o","\textbackslash{}\textbackslash{}boxed\{r\_o\}")}
\NormalTok{            if str(input.Ar\_i()) != "" : }
\NormalTok{                AreaTube.working\_eqn\_latex = AreaTube.working\_eqn\_latex.replace("r\_i",str(input.Ar\_i()))}
\NormalTok{                AreaTube.working\_sym = AreaTube.working\_sym.replace("r\_i",str(input.Ar\_i()))}
\NormalTok{                AreaTube.working\_eqn\_solver = AreaTube.working\_eqn\_solver.replace("r\_i",str(input.Ar\_i()))}
\NormalTok{            else:}
\NormalTok{                AreaTube.working\_eqn\_latex = AreaTube.working\_eqn\_latex.replace("r\_i","\textbackslash{}\textbackslash{}boxed\{r\_i\}")}
        
\NormalTok{        \# Dynamic Filling of I equations }
\NormalTok{        if ITube.newline\_math in lookup\_eqns:}
\NormalTok{            ITube.working\_eqn\_latex = ITube.newline\_math}
\NormalTok{            ITube.working\_eqn\_solver = "Eq(I\_tube,pi/4*((r\_o)**4{-}(r\_i)**4))"}
\NormalTok{            ITube.working\_sym = "I\_tube,r\_o,r\_i"}
\NormalTok{            if str(input.I\_tube()) != "" : }
\NormalTok{                ITube.working\_eqn\_latex = ITube.working\_eqn\_latex.replace("I\_\{tube\}",str(input.I\_tube()))}
\NormalTok{                ITube.working\_sym = ITube.working\_sym.replace("I\_tube",str(input.I\_tube()))}
\NormalTok{                ITube.working\_eqn\_solver = ITube.working\_eqn\_solver.replace("I\_tube",str(input.I\_tube()))}
\NormalTok{            else:}
\NormalTok{                ITube.working\_eqn\_latex = ITube.working\_eqn\_latex.replace("I\_\{tube\}","\textbackslash{}\textbackslash{}boxed\{I\_\{tube\}\}")}
\NormalTok{            if str(input.Ir\_o()) != "" : }
\NormalTok{                ITube.working\_eqn\_latex = ITube.working\_eqn\_latex.replace("r\_o",str(input.Ir\_o()))}
\NormalTok{                ITube.working\_sym = ITube.working\_sym.replace("r\_o",str(input.Ir\_o()))}
\NormalTok{                ITube.working\_eqn\_solver = ITube.working\_eqn\_solver.replace("r\_o",str(input.Ir\_o()))}
\NormalTok{            else:}
\NormalTok{                ITube.working\_eqn\_latex = ITube.working\_eqn\_latex.replace("r\_o","\textbackslash{}\textbackslash{}boxed\{r\_o\}")}
\NormalTok{            if str(input.Ir\_i()) != "" : }
\NormalTok{                ITube.working\_eqn\_latex = ITube.working\_eqn\_latex.replace("r\_i",str(input.Ir\_i()))        }
\NormalTok{                ITube.working\_sym = ITube.working\_sym.replace("r\_i",str(input.Ir\_i()))}
\NormalTok{                ITube.working\_eqn\_solver = ITube.working\_eqn\_solver.replace("r\_i",str(input.Ir\_i()))}
\NormalTok{            else:}
\NormalTok{                ITube.working\_eqn\_latex = ITube.working\_eqn\_latex.replace("r\_i","\textbackslash{}\textbackslash{}boxed\{r\_i\}")}
            
\NormalTok{        \# Dynamic Filling of Stress equation }
\NormalTok{        if StressEqn.newline\_math in lookup\_eqns:}
\NormalTok{            StressEqn.working\_eqn\_latex = StressEqn.newline\_math}
\NormalTok{            StressEqn.working\_eqn\_solver = "Eq(sigma,(F)/(A))"}
\NormalTok{            StressEqn.working\_sym = "sigma,F,A"}
\NormalTok{            if str(input.sigma()) != "" : }
\NormalTok{                StressEqn.working\_eqn\_latex = StressEqn.working\_eqn\_latex.replace("\textbackslash{}sigma",str(input.sigma()))}
\NormalTok{                StressEqn.working\_eqn\_solver = StressEqn.working\_eqn\_solver.replace("sigma",str(input.sigma()))}
\NormalTok{                StressEqn.working\_sym = StressEqn.working\_sym.replace("sigma",str(input.sigma()))}
\NormalTok{            else:}
\NormalTok{                StressEqn.working\_eqn\_latex = StressEqn.working\_eqn\_latex.replace("\textbackslash{}sigma","\textbackslash{}\textbackslash{}boxed\textbackslash{}sigma")}
\NormalTok{            if str(input.force()) != "" : }
\NormalTok{                StressEqn.working\_eqn\_latex = StressEqn.working\_eqn\_latex.replace("F",str(input.force()))}
\NormalTok{                StressEqn.working\_eqn\_solver = StressEqn.working\_eqn\_solver.replace("F",str(input.force()))}
\NormalTok{                StressEqn.working\_sym = StressEqn.working\_sym.replace("F",str(input.force()))}
\NormalTok{            else:}
\NormalTok{                StressEqn.working\_eqn\_latex = StressEqn.working\_eqn\_latex.replace("F","\textbackslash{}\textbackslash{}boxed\{F\}")}
\NormalTok{            if str(input.area()) != "" : }
\NormalTok{                StressEqn.working\_eqn\_latex = StressEqn.working\_eqn\_latex.replace("A",str(input.area()))}
\NormalTok{                StressEqn.working\_eqn\_solver = StressEqn.working\_eqn\_solver.replace("A",str(input.area()))}
\NormalTok{                StressEqn.working\_sym = StressEqn.working\_sym.replace("A",str(input.area()))}
\NormalTok{            else:}
\NormalTok{                StressEqn.working\_eqn\_latex = StressEqn.working\_eqn\_latex.replace("A","\textbackslash{}\textbackslash{}boxed\{A\}")}
           

\NormalTok{        \# Dynamic Filling of Bending Stress equation }
\NormalTok{        if BendingStress.newline\_math in lookup\_eqns:}
\NormalTok{            BendingStress.working\_eqn\_latex = BendingStress.newline\_math}
\NormalTok{            BendingStress.working\_eqn\_solver = "Eq(sigma\_b,M*y/I)"}
\NormalTok{            BendingStress.working\_sym = "sigma\_b,M,y,I"}
\NormalTok{            if str(input.bendingstress\_sigma\_b()) != "" : }
\NormalTok{                BendingStress.working\_eqn\_latex = BendingStress.working\_eqn\_latex.replace("\textbackslash{}sigma\_b",str(input.bendingstress\_sigma\_b()))}
\NormalTok{                BendingStress.working\_eqn\_solver = BendingStress.working\_eqn\_solver.replace("sigma\_b",str(input.bendingstress\_sigma\_b()))}
\NormalTok{                BendingStress.working\_sym = BendingStress.working\_sym.replace("sigma\_b",str(input.bendingstress\_sigma\_b()))}
\NormalTok{            else:}
\NormalTok{                BendingStress.working\_eqn\_latex = BendingStress.working\_eqn\_latex.replace("\textbackslash{}sigma\_b","\textbackslash{}\textbackslash{}boxed\{\textbackslash{}sigma\_b\}")}
\NormalTok{            if str(input.bendingstress\_M()) != "" : }
\NormalTok{                BendingStress.working\_eqn\_latex = BendingStress.working\_eqn\_latex.replace("M",str(input.bendingstress\_M()))}
\NormalTok{                BendingStress.working\_eqn\_solver = BendingStress.working\_eqn\_solver.replace("M",str(input.bendingstress\_M()))}
\NormalTok{                BendingStress.working\_sym = BendingStress.working\_sym.replace("M",str(input.bendingstress\_M()))}
\NormalTok{            else:}
\NormalTok{                BendingStress.working\_eqn\_latex = BendingStress.working\_eqn\_latex.replace("M","\textbackslash{}\textbackslash{}boxed\{M\}")}
\NormalTok{            if str(input.bendingstress\_y()) != "" : }
\NormalTok{                BendingStress.working\_eqn\_latex = BendingStress.working\_eqn\_latex.replace("y",str(input.bendingstress\_y()))}
\NormalTok{                BendingStress.working\_eqn\_solver = BendingStress.working\_eqn\_solver.replace("y",str(input.bendingstress\_y()))}
\NormalTok{                BendingStress.working\_sym = BendingStress.working\_sym.replace("y",str(input.bendingstress\_y()))}
\NormalTok{            else:}
\NormalTok{                BendingStress.working\_eqn\_latex = BendingStress.working\_eqn\_latex.replace("y","\textbackslash{}\textbackslash{}boxed\{y\}")}
\NormalTok{            if str(input.bendingstress\_I()) != "" : }
\NormalTok{                BendingStress.working\_eqn\_latex = BendingStress.working\_eqn\_latex.replace("I",str(input.bendingstress\_I()))}
\NormalTok{                BendingStress.working\_eqn\_solver = BendingStress.working\_eqn\_solver.replace("I",str(input.bendingstress\_I()))}
\NormalTok{                BendingStress.working\_sym = BendingStress.working\_sym.replace("I",str(input.bendingstress\_I()))}
\NormalTok{            else:}
\NormalTok{                BendingStress.working\_eqn\_latex = BendingStress.working\_eqn\_latex.replace("I","\textbackslash{}\textbackslash{}boxed\{I\}")}
            
                
\NormalTok{        \# Dynamic Filling of Axial Deform equation }
\NormalTok{        if AxialDeform.newline\_math in lookup\_eqns:}
\NormalTok{            AxialDeform.working\_eqn\_latex = AxialDeform.newline\_math}
\NormalTok{            AxialDeform.working\_eqn\_solver = "Eq(delta\_l,P*L/A/E)"}
\NormalTok{            AxialDeform.working\_sym = "delta\_l,P,L,A,E"}
\NormalTok{            if str(input.axial\_delta\_l()) != "" : }
\NormalTok{                AxialDeform.working\_eqn\_latex = AxialDeform.working\_eqn\_latex.replace("\textbackslash{}delta\_l",str(input.axial\_delta\_l()))}
\NormalTok{                AxialDeform.working\_eqn\_solver = AxialDeform.working\_eqn\_solver.replace("delta\_l",str(input.axial\_delta\_l()))}
\NormalTok{                AxialDeform.working\_sym = AxialDeform.working\_sym.replace("delta\_l",str(input.axial\_delta\_l()))}
\NormalTok{            else:}
\NormalTok{                AxialDeform.working\_eqn\_latex = AxialDeform.working\_eqn\_latex.replace("\textbackslash{}delta\_l","\textbackslash{}\textbackslash{}boxed\{\textbackslash{}delta\_l\}")}
\NormalTok{            if str(input.axial\_P()) != "" : }
\NormalTok{                AxialDeform.working\_eqn\_latex = AxialDeform.working\_eqn\_latex.replace("P",str(input.axial\_P()))}
\NormalTok{                AxialDeform.working\_eqn\_solver = AxialDeform.working\_eqn\_solver.replace("P",str(input.axial\_P()))}
\NormalTok{                AxialDeform.working\_sym = AxialDeform.working\_sym.replace("P",str(input.axial\_P()))}
\NormalTok{            else:}
\NormalTok{                AxialDeform.working\_eqn\_latex = AxialDeform.working\_eqn\_latex.replace("P","\textbackslash{}\textbackslash{}boxed\{P\}")}
\NormalTok{            if str(input.axial\_L()) != "" : }
\NormalTok{                AxialDeform.working\_eqn\_latex = AxialDeform.working\_eqn\_latex.replace("L",str(input.axial\_L()))}
\NormalTok{                AxialDeform.working\_eqn\_solver = AxialDeform.working\_eqn\_solver.replace("L",str(input.axial\_L()))}
\NormalTok{                AxialDeform.working\_sym = AxialDeform.working\_sym.replace("L",str(input.axial\_L()))}
\NormalTok{            else:}
\NormalTok{                AxialDeform.working\_eqn\_latex = AxialDeform.working\_eqn\_latex.replace("L","\textbackslash{}\textbackslash{}boxed\{L\}")}
\NormalTok{            if str(input.axial\_A()) != "" : }
\NormalTok{                AxialDeform.working\_eqn\_latex = AxialDeform.working\_eqn\_latex.replace("A",str(input.axial\_A()))}
\NormalTok{                AxialDeform.working\_eqn\_solver = AxialDeform.working\_eqn\_solver.replace("A",str(input.axial\_A()))}
\NormalTok{                AxialDeform.working\_sym = AxialDeform.working\_sym.replace("A",str(input.axial\_A()))}
\NormalTok{            else:}
\NormalTok{                AxialDeform.working\_eqn\_latex = AxialDeform.working\_eqn\_latex.replace("A","\textbackslash{}\textbackslash{}boxed\{A\}")}
\NormalTok{            if str(input.axial\_E()) != "" : }
\NormalTok{                AxialDeform.working\_eqn\_latex = AxialDeform.working\_eqn\_latex.replace("E",str(input.axial\_E()))}
\NormalTok{                AxialDeform.working\_eqn\_solver = AxialDeform.working\_eqn\_solver.replace("E",str(input.axial\_E()))}
\NormalTok{                AxialDeform.working\_sym = AxialDeform.working\_sym.replace("E",str(input.axial\_E()))}
\NormalTok{            else:}
\NormalTok{                AxialDeform.working\_eqn\_latex = AxialDeform.working\_eqn\_latex.replace("E","\textbackslash{}\textbackslash{}boxed\{E\}")}
            
\NormalTok{        \# Dynamic Filling of Thermal Deform equation }
\NormalTok{        if ThermalDeform.newline\_math in lookup\_eqns:}
\NormalTok{            ThermalDeform.working\_eqn\_latex = ThermalDeform.newline\_math}
\NormalTok{            ThermalDeform.working\_eqn\_solver = "Eq(delta\_t,alpha*Delta\_T*L)"}
\NormalTok{            ThermalDeform.working\_sym = "delta\_t,Delta\_T,alpha,L"}
\NormalTok{            if str(input.thermal\_delta\_t()) != "" : }
\NormalTok{                ThermalDeform.working\_eqn\_latex = ThermalDeform.working\_eqn\_latex.replace("\textbackslash{}delta\_t",str(input.thermal\_delta\_t()))}
\NormalTok{                ThermalDeform.working\_eqn\_solver = ThermalDeform.working\_eqn\_solver.replace("delta\_t",str(input.thermal\_delta\_t()))}
\NormalTok{                ThermalDeform.working\_sym = ThermalDeform.working\_sym.replace("delta\_t",str(input.thermal\_delta\_t()))}
\NormalTok{            else:}
\NormalTok{                ThermalDeform.working\_eqn\_latex = ThermalDeform.working\_eqn\_latex.replace("\textbackslash{}delta\_t","\textbackslash{}\textbackslash{}boxed\{\textbackslash{}delta\_t\}")}
\NormalTok{            if str(input.thermal\_alpha()) != "" : }
\NormalTok{                ThermalDeform.working\_eqn\_latex = ThermalDeform.working\_eqn\_latex.replace("\textbackslash{}\textbackslash{}alpha",str(input.thermal\_alpha()))}
\NormalTok{                ThermalDeform.working\_eqn\_solver = ThermalDeform.working\_eqn\_solver.replace("alpha",str(input.thermal\_alpha()))}
\NormalTok{                ThermalDeform.working\_sym = ThermalDeform.working\_sym.replace("alpha",str(input.thermal\_alpha()))}
\NormalTok{            else:}
\NormalTok{                ThermalDeform.working\_eqn\_latex = ThermalDeform.working\_eqn\_latex.replace("\textbackslash{}\textbackslash{}alpha","\textbackslash{}\textbackslash{}boxed\{\textbackslash{}\textbackslash{}alpha\}")}
\NormalTok{            if str(input.thermal\_Delta\_T()) != "" : }
\NormalTok{                ThermalDeform.working\_eqn\_latex = ThermalDeform.working\_eqn\_latex.replace("\textbackslash{}Delta T",str(input.thermal\_Delta\_T()))}
\NormalTok{                ThermalDeform.working\_eqn\_solver = ThermalDeform.working\_eqn\_solver.replace("Delta\_T",str(input.thermal\_Delta\_T()))}
\NormalTok{                ThermalDeform.working\_sym = ThermalDeform.working\_sym.replace("Delta\_T",str(input.thermal\_Delta\_T()))}
\NormalTok{            else:}
\NormalTok{                ThermalDeform.working\_eqn\_latex = ThermalDeform.working\_eqn\_latex.replace("\textbackslash{}Delta T","\textbackslash{}\textbackslash{}boxed\{\textbackslash{}Delta T\}")}
\NormalTok{            if str(input.thermal\_L()) != "" : }
\NormalTok{                ThermalDeform.working\_eqn\_latex = ThermalDeform.working\_eqn\_latex.replace("L",str(input.thermal\_L()))}
\NormalTok{                ThermalDeform.working\_eqn\_solver = ThermalDeform.working\_eqn\_solver.replace("L",str(input.thermal\_L()))}
\NormalTok{                ThermalDeform.working\_sym = ThermalDeform.working\_sym.replace("L",str(input.thermal\_L()))}
\NormalTok{            else:}
\NormalTok{                ThermalDeform.working\_eqn\_latex = ThermalDeform.working\_eqn\_latex.replace("L","\textbackslash{}\textbackslash{}boxed L")}
        
        
\NormalTok{        \# Dynamic Filling of Compatability equation 1 }
\NormalTok{        if Compatability1.newline\_math in lookup\_eqns:}
\NormalTok{            Compatability1\_list\_\_LHS = ["a\_1","a\_2","a\_3","a\_4","a\_5"]}
\NormalTok{            Compatability1\_list\_\_RHS = ["b\_1","b\_2","b\_3","b\_4","b\_5"]}
\NormalTok{            Compatability1\_list\_LHS = Compatability1\_list\_\_LHS[:input.Compatability1\_NumLHS()]}
\NormalTok{            Compatability1\_list\_RHS = Compatability1\_list\_\_RHS[:input.Compatability1\_NumRHS()]}
\NormalTok{            Compatability1\_list = Compatability1\_list\_LHS + Compatability1\_list\_RHS}
\NormalTok{            Compatability1.working\_sym = ",".join(Compatability1\_list)}
\NormalTok{            Compatability1.working\_eqn\_latex = "$$" + "+".join(Compatability1\_list\_LHS) + "=" + "+".join(Compatability1\_list\_RHS)+"$$"}
\NormalTok{            Compatability1.working\_eqn\_solver = "Eq("+ "+".join(Compatability1\_list\_LHS) + "," + "+".join(Compatability1\_list\_RHS)+")"}
            
\NormalTok{            if str(input.a\_1()) != "" : }
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("a\_1",str(input.a\_1()))}
\NormalTok{                Compatability1.working\_sym = Compatability1.working\_sym.replace("a\_1",str(input.a\_1()))}
\NormalTok{                Compatability1.working\_eqn\_solver = Compatability1.working\_eqn\_solver.replace("a\_1",str(input.a\_1()))}
\NormalTok{            else:}
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("a\_1","\textbackslash{}\textbackslash{}boxed\{a\_1\}")}
            
\NormalTok{            if str(input.a\_2()) != "" : }
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("a\_2",str(input.a\_2()))}
\NormalTok{                Compatability1.working\_sym = Compatability1.working\_sym.replace("a\_2",str(input.a\_2()))}
\NormalTok{                Compatability1.working\_eqn\_solver = Compatability1.working\_eqn\_solver.replace("a\_2",str(input.a\_2()))}
\NormalTok{            else:}
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("a\_2","\textbackslash{}\textbackslash{}boxed\{a\_2\}")}
            
\NormalTok{            if str(input.a\_3()) != "" : }
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("a\_3",str(input.a\_3()))}
\NormalTok{                Compatability1.working\_sym = Compatability1.working\_sym.replace("a\_3",str(input.a\_3()))}
\NormalTok{                Compatability1.working\_eqn\_solver = Compatability1.working\_eqn\_solver.replace("a\_3",str(input.a\_3()))}
\NormalTok{            else:}
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("a\_3","\textbackslash{}\textbackslash{}boxed\{a\_3\}")}
            
\NormalTok{            if str(input.a\_4()) != "" : }
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("a\_4",str(input.a\_4()))}
\NormalTok{                Compatability1.working\_sym = Compatability1.working\_sym.replace("a\_4",str(input.a\_4()))}
\NormalTok{                Compatability1.working\_eqn\_solver = Compatability1.working\_eqn\_solver.replace("a\_4",str(input.a\_4()))}
\NormalTok{            else:}
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("a\_4","\textbackslash{}\textbackslash{}boxed\{a\_4\}")}
            
\NormalTok{            if str(input.a\_5()) != "" : }
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("a\_5",str(input.a\_5()))}
\NormalTok{                Compatability1.working\_sym = Compatability1.working\_sym.replace("a\_5",str(input.a\_5()))}
\NormalTok{                Compatability1.working\_eqn\_solver = Compatability1.working\_eqn\_solver.replace("a\_5",str(input.a\_5()))}
\NormalTok{            else:}
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("a\_5","\textbackslash{}\textbackslash{}boxed\{a\_5\}")}
                    
\NormalTok{            if str(input.b\_1()) != "" : }
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("b\_1",str(input.b\_1()))}
\NormalTok{                Compatability1.working\_sym = Compatability1.working\_sym.replace("b\_1",str(input.b\_1()))}
\NormalTok{                Compatability1.working\_eqn\_solver = Compatability1.working\_eqn\_solver.replace("b\_1",str(input.b\_1()))}
\NormalTok{            else:}
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("b\_1","\textbackslash{}\textbackslash{}boxed\{b\_1\}")}
            
\NormalTok{            if str(input.b\_2()) != "" : }
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("b\_2",str(input.b\_2()))}
\NormalTok{                Compatability1.working\_sym = Compatability1.working\_sym.replace("b\_2",str(input.b\_2()))}
\NormalTok{                Compatability1.working\_eqn\_solver = Compatability1.working\_eqn\_solver.replace("b\_2",str(input.b\_2()))}
\NormalTok{            else:}
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("b\_2","\textbackslash{}\textbackslash{}boxed\{b\_2\}")}
            
\NormalTok{            if str(input.b\_3()) != "" : }
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("b\_3",str(input.b\_3()))}
\NormalTok{                Compatability1.working\_sym = Compatability1.working\_sym.replace("b\_3",str(input.b\_3()))}
\NormalTok{                Compatability1.working\_eqn\_solver = Compatability1.working\_eqn\_solver.replace("b\_3",str(input.b\_3()))}
\NormalTok{            else:}
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("b\_3","\textbackslash{}\textbackslash{}boxed\{b\_3\}")}
            
\NormalTok{            if str(input.b\_4()) != "" : }
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("b\_4",str(input.b\_4()))}
\NormalTok{                Compatability1.working\_sym = Compatability1.working\_sym.replace("b\_4",str(input.b\_4()))}
\NormalTok{                Compatability1.working\_eqn\_solver = Compatability1.working\_eqn\_solver.replace("b\_4",str(input.b\_4()))}
\NormalTok{            else:}
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("b\_4","\textbackslash{}\textbackslash{}boxed\{b\_4\}")}
            
\NormalTok{            if str(input.b\_5()) != "" : }
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("b\_5",str(input.b\_5()))}
\NormalTok{                Compatability1.working\_sym = Compatability1.working\_sym.replace("b\_5",str(input.b\_5()))}
\NormalTok{                Compatability1.working\_eqn\_solver = Compatability1.working\_eqn\_solver.replace("b\_5",str(input.b\_5()))}
\NormalTok{            else:}
\NormalTok{                Compatability1.working\_eqn\_latex = Compatability1.working\_eqn\_latex.replace("b\_5","\textbackslash{}\textbackslash{}boxed\{b\_5\}")}

\NormalTok{\# Dynamic Filling of Compatability equation 2}
\NormalTok{        if Compatability2.newline\_math in lookup\_eqns:}
\NormalTok{            Compatability2\_list\_\_LHS = ["c\_1","c\_2","c\_3","c\_4","c\_5"]}
\NormalTok{            Compatability2\_list\_\_RHS = ["d\_1","d\_2","d\_3","d\_4","d\_5"]}
\NormalTok{            Compatability2\_list\_LHS = Compatability2\_list\_\_LHS[:input.Compatability2\_NumLHS()]}
\NormalTok{            Compatability2\_list\_RHS = Compatability2\_list\_\_RHS[:input.Compatability2\_NumRHS()]}
\NormalTok{            Compatability2\_list = Compatability2\_list\_LHS + Compatability2\_list\_RHS}
\NormalTok{            Compatability2.working\_sym = ",".join(Compatability2\_list)}
\NormalTok{            Compatability2.working\_eqn\_latex = "$$" + "+".join(Compatability2\_list\_LHS) + "=" + "+".join(Compatability2\_list\_RHS)+"$$"}
\NormalTok{            Compatability2.working\_eqn\_solver = "Eq("+ "+".join(Compatability2\_list\_LHS) + "," + "+".join(Compatability2\_list\_RHS)+")"}
            
\NormalTok{            if str(input.c\_1()) != "" : }
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("c\_1",str(input.c\_1()))}
\NormalTok{                Compatability2.working\_sym = Compatability2.working\_sym.replace("c\_1",str(input.c\_1()))}
\NormalTok{                Compatability2.working\_eqn\_solver = Compatability2.working\_eqn\_solver.replace("c\_1",str(input.c\_1()))}
\NormalTok{            else:}
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("c\_1","\textbackslash{}\textbackslash{}boxed\{c\_1\}")}
            
\NormalTok{            if str(input.c\_2()) != "" : }
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("c\_2",str(input.c\_2()))}
\NormalTok{                Compatability2.working\_sym = Compatability2.working\_sym.replace("c\_2",str(input.c\_2()))}
\NormalTok{                Compatability2.working\_eqn\_solver = Compatability2.working\_eqn\_solver.replace("c\_2",str(input.c\_2()))}
\NormalTok{            else:}
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("c\_2","\textbackslash{}\textbackslash{}boxed\{c\_2\}")}
            
\NormalTok{            if str(input.c\_3()) != "" : }
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("c\_3",str(input.c\_3()))}
\NormalTok{                Compatability2.working\_sym = Compatability2.working\_sym.replace("c\_3",str(input.c\_3()))}
\NormalTok{                Compatability2.working\_eqn\_solver = Compatability2.working\_eqn\_solver.replace("c\_3",str(input.c\_3()))}
\NormalTok{            else:}
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("c\_3","\textbackslash{}\textbackslash{}boxed\{c\_3\}")}
            
\NormalTok{            if str(input.c\_4()) != "" : }
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("c\_4",str(input.c\_4()))}
\NormalTok{                Compatability2.working\_sym = Compatability2.working\_sym.replace("c\_4",str(input.c\_4()))}
\NormalTok{                Compatability2.working\_eqn\_solver = Compatability2.working\_eqn\_solver.replace("c\_4",str(input.c\_4()))}
\NormalTok{            else:}
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("c\_4","\textbackslash{}\textbackslash{}boxed\{c\_4\}")}
            
\NormalTok{            if str(input.c\_5()) != "" : }
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("c\_5",str(input.c\_5()))}
\NormalTok{                Compatability2.working\_sym = Compatability2.working\_sym.replace("c\_5",str(input.c\_5()))}
\NormalTok{                Compatability2.working\_eqn\_solver = Compatability2.working\_eqn\_solver.replace("c\_5",str(input.c\_5()))}
\NormalTok{            else:}
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("c\_5","\textbackslash{}\textbackslash{}boxed\{c\_5\}")}
                    
\NormalTok{            if str(input.d\_1()) != "" : }
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("d\_1",str(input.d\_1()))}
\NormalTok{                Compatability2.working\_sym = Compatability2.working\_sym.replace("d\_1",str(input.d\_1()))}
\NormalTok{                Compatability2.working\_eqn\_solver = Compatability2.working\_eqn\_solver.replace("d\_1",str(input.d\_1()))}
\NormalTok{            else:}
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("d\_1","\textbackslash{}\textbackslash{}boxed\{d\_1\}")}
            
\NormalTok{            if str(input.d\_2()) != "" : }
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("d\_2",str(input.d\_2()))}
\NormalTok{                Compatability2.working\_sym = Compatability2.working\_sym.replace("d\_2",str(input.d\_2()))}
\NormalTok{                Compatability2.working\_eqn\_solver = Compatability2.working\_eqn\_solver.replace("d\_2",str(input.d\_2()))}
\NormalTok{            else:}
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("d\_2","\textbackslash{}\textbackslash{}boxed\{d\_2\}")}
            
\NormalTok{            if str(input.d\_3()) != "" : }
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("d\_3",str(input.d\_3()))}
\NormalTok{                Compatability2.working\_sym = Compatability2.working\_sym.replace("d\_3",str(input.d\_3()))}
\NormalTok{                Compatability2.working\_eqn\_solver = Compatability2.working\_eqn\_solver.replace("d\_3",str(input.d\_3()))}
\NormalTok{            else:}
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("d\_3","\textbackslash{}\textbackslash{}boxed\{d\_3\}")}
            
\NormalTok{            if str(input.d\_4()) != "" : }
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("d\_4",str(input.d\_4()))}
\NormalTok{                Compatability2.working\_sym = Compatability2.working\_sym.replace("d\_4",str(input.d\_4()))}
\NormalTok{                Compatability2.working\_eqn\_solver = Compatability2.working\_eqn\_solver.replace("d\_4",str(input.d\_4()))}
\NormalTok{            else:}
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("d\_4","\textbackslash{}\textbackslash{}boxed\{d\_4\}")}
            
\NormalTok{            if str(input.d\_5()) != "" : }
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("d\_5",str(input.d\_5()))}
\NormalTok{                Compatability2.working\_sym = Compatability2.working\_sym.replace("d\_5",str(input.d\_5()))}
\NormalTok{                Compatability2.working\_eqn\_solver = Compatability2.working\_eqn\_solver.replace("d\_5",str(input.d\_5()))}
\NormalTok{            else:}
\NormalTok{                Compatability2.working\_eqn\_latex = Compatability2.working\_eqn\_latex.replace("d\_5","\textbackslash{}\textbackslash{}boxed\{d\_5\}")}
                
                
\NormalTok{        eqnbank\_working\_latex = \{}
\NormalTok{        StaticsSumFx.name: StaticsSumFx.working\_eqn\_latex,}
\NormalTok{        StaticsSumFy.name: StaticsSumFy.working\_eqn\_latex,}
\NormalTok{        StaticsSumM.name: StaticsSumM.working\_eqn\_latex,}
\NormalTok{        StressEqn.name: StressEqn.working\_eqn\_latex,}
\NormalTok{        BendingStress.name: BendingStress.working\_eqn\_latex,}
\NormalTok{        AxialDeform.name: AxialDeform.working\_eqn\_latex,}
\NormalTok{        ThermalDeform.name: ThermalDeform.working\_eqn\_latex,}
\NormalTok{        AreaTube.name: AreaTube.working\_eqn\_latex,}
\NormalTok{        ITube.name: ITube.working\_eqn\_latex,}
\NormalTok{        Compatability1.name: Compatability1.working\_eqn\_latex,}
\NormalTok{        Compatability2.name: Compatability2.working\_eqn\_latex}
\NormalTok{        \}}

\NormalTok{        eqnbank\_working\_solver = \{}
\NormalTok{        StaticsSumFx.name: StaticsSumFx.working\_eqn\_solver,}
\NormalTok{        StaticsSumFy.name: StaticsSumFy.working\_eqn\_solver,}
\NormalTok{        StaticsSumM.name: StaticsSumM.working\_eqn\_solver,}
\NormalTok{        StressEqn.name: StressEqn.working\_eqn\_solver,}
\NormalTok{        BendingStress.name: BendingStress.working\_eqn\_solver,}
\NormalTok{        AxialDeform.name: AxialDeform.working\_eqn\_solver,}
\NormalTok{        ThermalDeform.name: ThermalDeform.working\_eqn\_solver,}
\NormalTok{        AreaTube.name: AreaTube.working\_eqn\_solver,}
\NormalTok{        ITube.name: ITube.working\_eqn\_solver,}
\NormalTok{        Compatability1.name: Compatability1.working\_eqn\_solver,}
\NormalTok{        Compatability2.name: Compatability2.working\_eqn\_solver}
\NormalTok{        \}}

\NormalTok{        symbank\_working = \{}
\NormalTok{        StaticsSumFx.name: StaticsSumFx.working\_sym,}
\NormalTok{        StaticsSumFy.name: StaticsSumFy.working\_sym,}
\NormalTok{        StaticsSumM.name: StaticsSumM.working\_sym,}
\NormalTok{        StressEqn.name: StressEqn.working\_sym,}
\NormalTok{        BendingStress.name: BendingStress.working\_sym,}
\NormalTok{        AxialDeform.name: AxialDeform.working\_sym,}
\NormalTok{        ThermalDeform.name: ThermalDeform.working\_sym,}
\NormalTok{        AreaTube.name: AreaTube.working\_sym,}
\NormalTok{        ITube.name: ITube.working\_sym,}
\NormalTok{        Compatability1.name: Compatability1.working\_sym,}
\NormalTok{        Compatability2.name: Compatability2.working\_sym}
\NormalTok{        \}}
        
\NormalTok{        working\_eqns\_latex = [eqnbank\_working\_latex[key] for key in eqns\_keys]}
\NormalTok{        working\_SumFx\_render.set(eqnbank\_working\_latex["Equilibrium Forces in X"])}
\NormalTok{        working\_SumFy\_render.set(eqnbank\_working\_latex["Equilibrium Forces in Y"])}
\NormalTok{        working\_SumM\_render.set(eqnbank\_working\_latex["Equilibrium Moments about O"])}
\NormalTok{        working\_StressEqn\_render.set(eqnbank\_working\_latex["Stress Equation"])}
\NormalTok{        working\_BendingStress\_render.set(eqnbank\_working\_latex["Bending Stress from a Moment"])}
\NormalTok{        working\_AxialDeform\_render.set(eqnbank\_working\_latex["Axial Deformation by Force"])}
\NormalTok{        working\_ThermalDeform\_render.set(eqnbank\_working\_latex["Axial Deformation by Thermal"])}
\NormalTok{        working\_AreaTube\_render.set(eqnbank\_working\_latex["Area of a Tube"])}
\NormalTok{        working\_Itube\_render.set(eqnbank\_working\_latex["Moment of Inertia of a Tube"])}
\NormalTok{        working\_Compatability1\_render.set(eqnbank\_working\_latex["Compatability Equation 1"])}
\NormalTok{        working\_Compatability2\_render.set(eqnbank\_working\_latex["Compatability Equation 2"])}
\NormalTok{        working\_eqns\_solver = [eqnbank\_working\_solver[key] for key in eqns\_keys]}
        
\NormalTok{        temp\_working\_equations\_solver = "\#".join(working\_eqns\_solver)}
\NormalTok{        temp\_working\_equations\_solver = temp\_working\_equations\_solver.replace("Eq","Wrap\_clash")}
\NormalTok{        temp\_working\_equations\_solver = temp\_working\_equations\_solver.replace("E","E\_clash")}
\NormalTok{        temp\_working\_equations\_solver = temp\_working\_equations\_solver.replace("I","I\_clash")}
\NormalTok{        temp\_working\_equations\_solver = temp\_working\_equations\_solver.replace("N","N\_clash")}
\NormalTok{        temp\_working\_equations\_solver = temp\_working\_equations\_solver.replace("Wrap\_clash","Eq")}
\NormalTok{        working\_eqns\_solver = temp\_working\_equations\_solver.split("\#")}
        
\NormalTok{        \#working\_eqns\_solver=[]}
\NormalTok{        \#for j in working\_eqns\_solver\_pre:}
\NormalTok{        \#    temp=j.split(",")}
\NormalTok{        \#    temp2=temp.replace("I","I\_clash")}
\NormalTok{        \#    temp3=temp2.replace("E","E\_clash")}
\NormalTok{        \#    working\_eqns\_solver.append(temp3)}
        
\NormalTok{        working\_syms = [symbank\_working[key] for key in eqns\_keys]}
\NormalTok{        mystring\_working\_eqns = "".join(working\_eqns\_latex)}
\NormalTok{        mystring\_working\_eqns = mystring\_working\_eqns.replace("*","\textbackslash{}\textbackslash{}times")}
\NormalTok{        feedback\_syms.set(working\_syms)}
\NormalTok{        working\_equations\_solver.set(working\_eqns\_solver)}

\NormalTok{        working\_syms\_only=[]}
\NormalTok{        for j in working\_syms:}
\NormalTok{            temp=j.split(",")}
\NormalTok{            for k in temp:}
\NormalTok{                try: }
\NormalTok{                    float(eval(k))  }
\NormalTok{                except:}
\NormalTok{                    temp2=k.replace("I","I\_clash")}
\NormalTok{                    temp3=temp2.replace("E","E\_clash")}
\NormalTok{                    temp4=temp3.replace("N","N\_clash")}
\NormalTok{                    working\_syms\_only.append(temp4)}
\NormalTok{        working\_syms\_only=list(dict.fromkeys(working\_syms\_only))}
\NormalTok{        working\_symbols.set(working\_syms\_only)}
        
\NormalTok{        return [}
\NormalTok{            ui.markdown(mystring\_working\_eqns),}
\NormalTok{            ui.tags.script(}
\NormalTok{                "if (window.MathJax) MathJax.Hub.Queue([\textquotesingle{}Typeset\textquotesingle{}, MathJax.Hub]);"}
\NormalTok{            )}
\NormalTok{        ]}
    
\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def dyn\_ui\_nav():}
      
\NormalTok{        tab\_Instructions = ui.nav(}
\NormalTok{            "Instructions",ui.markdown("Please choose the equations you would like to use in this problem. As you do, tabs will load here which allow you to browse between active equations and define the necessary parameters or variables to set up your solution. As you fill in parameters and variables, the working palette will change to reflect what values you are plugging in and will give you a running update of the number of equations you have relative to the number of unknowns you have. A solve equations button will be available for when you are ready to solve and the system will provide the solution to your system of equations. \textless{}br\textgreater{} \textless{}br\textgreater{} Note: You may put in simple math into the blanks (e.g., 3*4 instead of 12) which can be helpful in specifying Moment values or performing unit conversions in place. At this time, you may not mix and match this math with variables (e.g., typing in 5x in the blank will not parse the 5 as a number and the x as a variable) \textless{}br\textgreater{} \textless{}br\textgreater{} Key issues still needing development include: support for units?, **FEEDBACK**, choosing a solution value from the solution set, parameterized problem statement values...") }
\NormalTok{        )}
    
\NormalTok{        tab\_StaticsSumFy = ui.nav(}
\NormalTok{                str(StaticsSumFy.inline\_math),}
\NormalTok{                \#ui.markdown(working\_SumFy\_string()),}
\NormalTok{                ui.input\_numeric("NumForcesY","How many terms do you want?",value=NumForcesY(),min=2,max=5),}
\NormalTok{                ui.input\_text("F1y","\textbackslash{}(F\_\{y\_1\}=\textbackslash{})", value=F1y(),placeholder="Please type in variable or value"),}
\NormalTok{                ui.input\_text("F2y","\textbackslash{}(F\_\{y\_2\}=\textbackslash{})", value=F2y(),placeholder="Please type in variable or value"),}
\NormalTok{                ui.panel\_conditional("input.NumForcesY\textgreater{}=3", ui.input\_text("F3y","\textbackslash{}(F\_\{y\_3\}=\textbackslash{})", value=F3y(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.panel\_conditional("input.NumForcesY\textgreater{}=4", ui.input\_text("F4y","\textbackslash{}(F\_\{y\_4\}=\textbackslash{})", value=F4y(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.panel\_conditional("input.NumForcesY\textgreater{}=5", ui.input\_text("F5y","\textbackslash{}(F\_\{y\_5\}=\textbackslash{})", value=F5y(),placeholder="Please type in variable or value"))}
\NormalTok{                )}
        
\NormalTok{        tab\_StaticsSumFx = ui.nav(}
\NormalTok{                str(StaticsSumFx.inline\_math),}
\NormalTok{                \#ui.markdown(working\_SumFx\_string()),}
\NormalTok{                ui.input\_numeric("NumForcesX","How many terms do you want?",value=NumForcesX(),min=2,max=5),}
\NormalTok{                ui.input\_text("F1x","\textbackslash{}(F\_\{x\_1\}=\textbackslash{})", value=F1x(),placeholder="Please type in variable or value"),}
\NormalTok{                ui.input\_text("F2x","\textbackslash{}(F\_\{x\_2\}=\textbackslash{})", value=F2x(),placeholder="Please type in variable or value"),}
\NormalTok{                ui.panel\_conditional("input.NumForcesX\textgreater{}=3", ui.input\_text("F3x","\textbackslash{}(F\_\{x\_3\}=\textbackslash{})", value=F3x(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.panel\_conditional("input.NumForcesX\textgreater{}=4", ui.input\_text("F4x","\textbackslash{}(F\_\{x\_4\}=\textbackslash{})", value=F4x(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.panel\_conditional("input.NumForcesX\textgreater{}=5", ui.input\_text("F5x","\textbackslash{}(F\_\{x\_5\}=\textbackslash{})", value=F5x(),placeholder="Please type in variable or value"))}
\NormalTok{                )}
        
\NormalTok{        tab\_StaticsSumM = ui.nav(}
\NormalTok{                str(StaticsSumM.inline\_math),}
\NormalTok{                \#ui.markdown(working\_SumM\_string()),}
\NormalTok{                ui.input\_numeric("NumMoments","How many terms do you want?",value=NumMoments(),min=2,max=5),}
\NormalTok{                ui.input\_text("M1","\textbackslash{}(M\_1=\textbackslash{})", value=M1(),placeholder="Please type in variables, values, or numeric math (e.g., (3*4))"),}
\NormalTok{                ui.input\_text("M2","\textbackslash{}(M\_2=\textbackslash{})", value=M2(),placeholder="Please type in variables, values, or numeric math (e.g., (3*4))"),}
\NormalTok{                ui.panel\_conditional("input.NumMoments\textgreater{}=3", ui.input\_text("M3","\textbackslash{}(M\_3=\textbackslash{})", value=M3(),placeholder="Please type in variable, values, or numeric math (e.g., (3*4))")),}
\NormalTok{                ui.panel\_conditional("input.NumMoments\textgreater{}=4", ui.input\_text("M4","\textbackslash{}(M\_4=\textbackslash{})", value=M4(),placeholder="Please type in variable , values, or numeric math (e.g., (3*4))")),}
\NormalTok{                ui.panel\_conditional("input.NumMoments\textgreater{}=5", ui.input\_text("M5","\textbackslash{}(M\_5=\textbackslash{})", value=M5(),placeholder="Please type in variable , values, or numeric math (e.g., (3*4))"))}
\NormalTok{                )}
        
\NormalTok{        tab\_StressEqn = ui.nav(}
\NormalTok{                str(StressEqn.inline\_math),}
\NormalTok{                \#ui.markdown(working\_StressEqn\_string()),}
\NormalTok{                ui.input\_text("sigma","\textbackslash{}(\textbackslash{}sigma\textbackslash{})", value=axial\_stress\_sigma(),placeholder="Please type in variables or values"),}
\NormalTok{                ui.input\_text("force","\textbackslash{}(F\textbackslash{})", value=axial\_stress\_force(),placeholder="Please type in variables or values"),}
\NormalTok{                ui.input\_text("area","\textbackslash{}(A\textbackslash{})", value=axial\_stress\_area(),placeholder="Please type in variables or values"),}
\NormalTok{                )}
        
\NormalTok{        tab\_BendingStress = ui.nav(}
\NormalTok{                str(BendingStress.inline\_math),}
\NormalTok{                \#ui.markdown(working\_BendingStress\_string()),}
\NormalTok{                ui.input\_text("bendingstress\_sigma\_b","\textbackslash{}(\textbackslash{}sigma\_b\textbackslash{})", value=bending\_stress\_sigma(), placeholder="Please type in variables or values"),}
\NormalTok{                ui.input\_text("bendingstress\_M","\textbackslash{}(M\textbackslash{})", value=bending\_stress\_M(), placeholder="Please type in variables or values"),}
\NormalTok{                ui.input\_text("bendingstress\_y","\textbackslash{}(y\textbackslash{})", value=bending\_stress\_y(), placeholder="Please type in variables or values"),}
\NormalTok{                ui.input\_text("bendingstress\_I","\textbackslash{}(I\textbackslash{})", value= bending\_stress\_I(), placeholder="Please type in variables or values"),}
\NormalTok{                )}
        
\NormalTok{        tab\_AxialDeform = ui.nav(}
\NormalTok{                str(AxialDeform.inline\_math),}
\NormalTok{                \#ui.markdown(working\_AxialDeform\_string()),}
\NormalTok{                ui.input\_text("axial\_delta\_l","\textbackslash{}(\textbackslash{}delta\_l\textbackslash{})", value=axial\_delta\_l(), placeholder="Please type in variables or values"),}
\NormalTok{                ui.input\_text("axial\_P","\textbackslash{}(P\textbackslash{})", value=axial\_P(), placeholder="Please type in variables or values"),}
\NormalTok{                ui.input\_text("axial\_L","\textbackslash{}(L\textbackslash{})", value=axial\_L(), placeholder="Please type in variables or values"),}
\NormalTok{                ui.input\_text("axial\_A","\textbackslash{}(A\textbackslash{})", value=axial\_A(), placeholder="Please type in variables or values"),}
\NormalTok{                ui.input\_text("axial\_E","\textbackslash{}(E\textbackslash{})", value=axial\_E(), placeholder="Please type in variables or values"),}
\NormalTok{                )}
        
\NormalTok{        tab\_ThermalDeform = ui.nav(}
\NormalTok{                str(ThermalDeform.inline\_math),}
\NormalTok{                \#ui.markdown(working\_ThermalDeform\_string()),}
\NormalTok{                ui.input\_text("thermal\_delta\_t","\textbackslash{}(\textbackslash{}delta\_t\textbackslash{})", value=thermal\_delta\_t(), placeholder="Please type in variables or values"),}
\NormalTok{                ui.input\_text("thermal\_alpha","\textbackslash{}(\textbackslash{}\textbackslash{}alpha\textbackslash{})", value=thermal\_alpha(), placeholder="Please type in variables or values"),}
\NormalTok{                ui.input\_text("thermal\_Delta\_T","\textbackslash{}(\textbackslash{}Delta T\textbackslash{})", value=thermal\_Delta\_T(), placeholder="Please type in variables or values"),}
\NormalTok{                ui.input\_text("thermal\_L","\textbackslash{}(L\textbackslash{})", value=thermal\_L(), placeholder="Please type in variables or values"),}
\NormalTok{                )}
        
\NormalTok{        tab\_AreaTube = ui.nav(}
\NormalTok{                str(AreaTube.inline\_math),}
\NormalTok{                \#ui.markdown(working\_AreaTube\_string()),}
\NormalTok{                ui.input\_text("A\_tube","\textbackslash{}(A\_\{tube\}=\textbackslash{})", value=area\_tube\_A\_tube(), placeholder="Please type in variables or values"),}
\NormalTok{                ui.input\_text("Ar\_o","\textbackslash{}(r\_o=\textbackslash{})", value=area\_tube\_Ar\_o(), placeholder="Please type in variables or values"),}
\NormalTok{                ui.input\_text("Ar\_i","\textbackslash{}(r\_i\textbackslash{})", value=area\_tube\_Ar\_i(), placeholder="Please type in variables or values")}
\NormalTok{                )}
        
\NormalTok{        tab\_ITube = ui.nav(}
\NormalTok{                str(ITube.inline\_math),}
\NormalTok{                \#ui.markdown(working\_Itube\_string()),}
\NormalTok{                ui.input\_text("I\_tube","\textbackslash{}(I\_\{tube\}=\textbackslash{})", value=I\_tube\_I\_tube(), placeholder="Please type in variables or values"),}
\NormalTok{                ui.input\_text("Ir\_o","\textbackslash{}(r\_o=\textbackslash{})", value=I\_tube\_Ir\_o(), placeholder="Please type in variables or values"),}
\NormalTok{                ui.input\_text("Ir\_i","\textbackslash{}(r\_i\textbackslash{})", value=i\_tube\_Ir\_i(), placeholder="Please type in variables or values"),}
\NormalTok{                )}
        
\NormalTok{        tab\_Compatability1 = ui.nav(}
\NormalTok{                str(Compatability1.inline\_math),}
\NormalTok{                \#ui.markdown(working\_Compatability1\_string()),}
\NormalTok{                ui.input\_numeric("Compatability1\_NumLHS","How many \textquotesingle{}a\textquotesingle{} terms do you want?",value=Compatability1\_NumLHS(),min=1,max=5),}
\NormalTok{                ui.input\_numeric("Compatability1\_NumRHS","How many \textquotesingle{}b\textquotesingle{} terms do you want?",value=Compatability1\_NumRHS(),min=1,max=5),}
\NormalTok{                ui.input\_text("a\_1","\textbackslash{}(a\_1=\textbackslash{})", value=Compatability1\_a\_1(),placeholder="Please type in variable or value"),}
\NormalTok{                ui.panel\_conditional("input.Compatability1\_NumLHS\textgreater{}=2",ui.input\_text("a\_2","\textbackslash{}(a\_2=\textbackslash{})", value=Compatability1\_a\_2(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.panel\_conditional("input.Compatability1\_NumLHS\textgreater{}=3", ui.input\_text("a\_3","\textbackslash{}(a\_3=\textbackslash{})", value=Compatability1\_a\_3(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.panel\_conditional("input.Compatability1\_NumLHS\textgreater{}=4", ui.input\_text("a\_4","\textbackslash{}(a\_4=\textbackslash{})", value=Compatability1\_a\_4(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.panel\_conditional("input.Compatability1\_NumLHS\textgreater{}=5", ui.input\_text("a\_5","\textbackslash{}(a\_5=\textbackslash{})", value=Compatability1\_a\_5(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.input\_text("b\_1","\textbackslash{}(b\_1=\textbackslash{})", value=Compatability1\_b\_1(),placeholder="Please type in variable or value"),}
\NormalTok{                ui.panel\_conditional("input.Compatability1\_NumRHS\textgreater{}=2",ui.input\_text("b\_2","\textbackslash{}(b\_2=\textbackslash{})", value=Compatability1\_b\_2(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.panel\_conditional("input.Compatability1\_NumRHS\textgreater{}=3",ui.input\_text("b\_3","\textbackslash{}(b\_3=\textbackslash{})", value=Compatability1\_b\_3(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.panel\_conditional("input.Compatability1\_NumRHS\textgreater{}=4",ui.input\_text("b\_4","\textbackslash{}(b\_4=\textbackslash{})", value=Compatability1\_b\_4(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.panel\_conditional("input.Compatability1\_NumRHS\textgreater{}=5",ui.input\_text("b\_5","\textbackslash{}(b\_5=\textbackslash{})", value=Compatability1\_b\_5(),placeholder="Please type in variable or value")),}
\NormalTok{                )}
        
\NormalTok{        tab\_Compatability2 = ui.nav(}
\NormalTok{                str(Compatability2.inline\_math),}
\NormalTok{                \#ui.markdown(working\_Compatability2\_string()),}
\NormalTok{                ui.input\_numeric("Compatability2\_NumLHS","How many \textquotesingle{}c\textquotesingle{} terms do you want?",value=Compatability2\_NumLHS(),min=1,max=5),}
\NormalTok{                ui.input\_numeric("Compatability2\_NumRHS","How many \textquotesingle{}d\textquotesingle{} terms do you want?",value=Compatability2\_NumRHS(),min=1,max=5),}
\NormalTok{                ui.input\_text("c\_1","\textbackslash{}(c\_1=\textbackslash{})", value=Compatability2\_c\_1(),placeholder="Please type in variable or value"),}
\NormalTok{                ui.panel\_conditional("input.Compatability2\_NumLHS\textgreater{}=2",ui.input\_text("c\_2","\textbackslash{}(c\_2=\textbackslash{})", value=Compatability2\_c\_2(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.panel\_conditional("input.Compatability2\_NumLHS\textgreater{}=3", ui.input\_text("c\_3","\textbackslash{}(c\_3=\textbackslash{})", value=Compatability2\_c\_3(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.panel\_conditional("input.Compatability2\_NumLHS\textgreater{}=4", ui.input\_text("c\_4","\textbackslash{}(c\_4=\textbackslash{})", value=Compatability2\_c\_4(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.panel\_conditional("input.Compatability2\_NumLHS\textgreater{}=5", ui.input\_text("c\_5","\textbackslash{}(c\_5=\textbackslash{})", value=Compatability2\_c\_5(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.input\_text("d\_1","\textbackslash{}(d\_1=\textbackslash{})", value=Compatability2\_d\_1(),placeholder="Please type in variable or value"),}
\NormalTok{                ui.panel\_conditional("input.Compatability2\_NumRHS\textgreater{}=2",ui.input\_text("d\_2","\textbackslash{}(d\_2=\textbackslash{})", value=Compatability2\_d\_2(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.panel\_conditional("input.Compatability2\_NumRHS\textgreater{}=3",ui.input\_text("d\_3","\textbackslash{}(d\_3=\textbackslash{})", value=Compatability2\_d\_3(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.panel\_conditional("input.Compatability2\_NumRHS\textgreater{}=4",ui.input\_text("d\_4","\textbackslash{}(d\_4=\textbackslash{})", value=Compatability2\_d\_4(),placeholder="Please type in variable or value")),}
\NormalTok{                ui.panel\_conditional("input.Compatability2\_NumRHS\textgreater{}=5",ui.input\_text("d\_5","\textbackslash{}(d\_5=\textbackslash{})", value=Compatability2\_d\_5(),placeholder="Please type in variable or value")),}
\NormalTok{                )}

\NormalTok{        tab\_bank = \{}
\NormalTok{                StaticsSumFx.name: tab\_StaticsSumFx,}
\NormalTok{                StaticsSumFy.name: tab\_StaticsSumFy,}
\NormalTok{                StaticsSumM.name: tab\_StaticsSumM,}
\NormalTok{                StressEqn.name: tab\_StressEqn,}
\NormalTok{                BendingStress.name: tab\_BendingStress,}
\NormalTok{                AxialDeform.name: tab\_AxialDeform,}
\NormalTok{                ThermalDeform.name: tab\_ThermalDeform,}
\NormalTok{                AreaTube.name: tab\_AreaTube,}
\NormalTok{                ITube.name: tab\_ITube,}
\NormalTok{                Compatability1.name: tab\_Compatability1,}
\NormalTok{                Compatability2.name: tab\_Compatability2,}
\NormalTok{                \}}
\NormalTok{        eqns\_keys = input.selected\_eqns()}
\NormalTok{        tabs = [tab\_bank[key] for key in eqns\_keys]}
\NormalTok{        tabs.insert(0,tab\_Instructions)}
\NormalTok{        equations = ui.navset\_tab\_card(*tabs,id="mytab",selected=active\_eqn\_tab())                    }
    
\NormalTok{        return [equations,}
\NormalTok{               ui.tags.script(}
\NormalTok{                "if (window.MathJax) MathJax.Hub.Queue([\textquotesingle{}Typeset\textquotesingle{}, MathJax.Hub]);"}
\NormalTok{        ),]}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_equation\_bookkeeping():}
\NormalTok{        req(working\_equations\_solver())}
\NormalTok{        num\_working\_equations=len(working\_equations\_solver())}
\NormalTok{        num\_working\_symbols=len(working\_symbols())}
\NormalTok{        string\_working\_symbols= "\textbackslash{}\textbackslash{}\textbackslash{}\textbackslash{}("+"\textbackslash{}\textbackslash{}\textbackslash{}\textbackslash{}),\textbackslash{}\textbackslash{}\textbackslash{}\textbackslash{}(".join(working\_symbols())+"\textbackslash{}\textbackslash{}\textbackslash{}\textbackslash{})"}
\NormalTok{        string\_working\_symbols=string\_working\_symbols.replace("N\_clash","N")}
\NormalTok{        string\_working\_symbols=string\_working\_symbols.replace("I\_clash","I")}
\NormalTok{        string\_working\_symbols=string\_working\_symbols.replace("E\_clash","E")}
\NormalTok{        string\_working\_symbols=string\_working\_symbols.replace("delta","\textbackslash{}delta")}
\NormalTok{        string\_working\_symbols=string\_working\_symbols.replace("Delta","\textbackslash{}Delta")}
\NormalTok{        string\_working\_symbols=string\_working\_symbols.replace("sigma","\textbackslash{}sigma")}
\NormalTok{        return [ui.markdown(f"Your equation{-}solver set up currently has **\{num\_working\_equations\} equations** and **\{num\_working\_symbols\} unknowns**. \textless{}br\textgreater{}  Your current unknowns are \{string\_working\_symbols\}"), }
\NormalTok{                ui.input\_action\_button(}
\NormalTok{                    "solveEquations", "Solve Equations", class\_="btn{-}success", width="240px", style=\textquotesingle{}margin{-}bottom:10px\textquotesingle{}),}
\NormalTok{                ui.tags.script(}
\NormalTok{                "if (window.MathJax) MathJax.Hub.Queue([\textquotesingle{}Typeset\textquotesingle{}, MathJax.Hub]);"}
\NormalTok{                )]}
        
\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    @reactive.event(input.solveEquations)}
\NormalTok{    def ui\_solutions():}
\NormalTok{        for j in working\_symbols():}
\NormalTok{            j=Symbol(j)}
\NormalTok{        print(working\_equations\_solver())}
\NormalTok{        print(working\_symbols())}
\NormalTok{        my\_solver\_equations=[]}
\NormalTok{        for m in working\_equations\_solver():}
\NormalTok{            m=parse\_expr(m)}
\NormalTok{        solve\_eqns = solve(working\_equations\_solver(),working\_symbols(),dict=True)}
\NormalTok{        answers=[]}
\NormalTok{        for k in working\_symbols():}
\NormalTok{            try: }
\NormalTok{                temp=solve\_eqns[0][parse\_expr(k)]}
\NormalTok{                temp2="$$"+k+"="+f\textquotesingle{}\{temp:.2f\}\textquotesingle{}+"$$"}
\NormalTok{                answers.append(temp2)}
\NormalTok{            except:}
\NormalTok{                pass}
\NormalTok{        mystring\_answers="".join(answers)}
\NormalTok{        mystring\_answers=mystring\_answers.replace("pi","\textbackslash{}pi")}
\NormalTok{        mystring\_answers=mystring\_answers.replace("delta","\textbackslash{}delta")}
\NormalTok{        mystring\_answers=mystring\_answers.replace("Delta","\textbackslash{}Delta")}
\NormalTok{        mystring\_answers=mystring\_answers.replace("sigma","\textbackslash{}sigma")}
\NormalTok{        mystring\_answers=mystring\_answers.replace("E\_clash","E")}
\NormalTok{        mystring\_answers=mystring\_answers.replace("I\_clash","I")}
\NormalTok{        mystring\_answers=mystring\_answers.replace("N\_clash","N")}
\NormalTok{        \#feedback\_solns.set(mystring\_answers)}
\NormalTok{        return [ui.markdown(f"Your solution is \{mystring\_answers\}"),}
\NormalTok{                ui.input\_text("answer","Answer:",placeholder="Please type in your answer"),}
\NormalTok{                ui.input\_action\_button("feedback", "Check answer and show feedback"),}
\NormalTok{                ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{                ui.tags.script(}
\NormalTok{                "if (window.MathJax) MathJax.Hub.Queue([\textquotesingle{}Typeset\textquotesingle{}, MathJax.Hub]);"}
\NormalTok{                )]}

\NormalTok{    \#@reactive.Effect}
\NormalTok{    \#def \_():}

\NormalTok{     \#   active\_eqn\_tab.set(input.mytab())}
    
    
\NormalTok{    @reactive.Effect}
\NormalTok{    def \_():}

\NormalTok{        input.selected\_eqns()}
\NormalTok{        active\_eqn\_tab.set(input.mytab())}
        
        
\NormalTok{        \#working\_SumFx\_render():}
\NormalTok{        \#working\_SumFy\_render()}
\NormalTok{        \#working\_SumM\_render()}
\NormalTok{        \#working\_StressEqn\_render()}
\NormalTok{        \#working\_BendingStress\_render()}
\NormalTok{        \#working\_AxialDeform\_render()}
\NormalTok{        \#working\_ThermalDeform\_render()}
\NormalTok{        \#working\_AreaTube\_render()}
\NormalTok{        \#working\_Itube\_render()}
\NormalTok{        \#working\_Compatability1\_render()}
\NormalTok{        \#working\_Compatability2\_render()}
                
\NormalTok{        with reactive.isolate():}
\NormalTok{            if "Equilibrium Forces in Y" in input.selected\_eqns(): }
\NormalTok{                NumForcesY.set(input.NumForcesY())}
\NormalTok{                F1y.set(input.F1y())}
\NormalTok{                F2y.set(input.F2y())}
\NormalTok{                F3y.set(input.F3y())}
\NormalTok{                F4y.set(input.F4y())}
\NormalTok{                F5y.set(input.F5y())}
\NormalTok{                working\_SumFy\_string.set(str(working\_SumFy\_render()))}
\NormalTok{            else:}
\NormalTok{                 pass             }
    
\NormalTok{            if "Equilibrium Forces in X" in input.selected\_eqns(): }
\NormalTok{                NumForcesX.set(input.NumForcesX())}
\NormalTok{                F1x.set(input.F1x())}
\NormalTok{                F2x.set(input.F2x())}
\NormalTok{                F3x.set(input.F3x())}
\NormalTok{                F4x.set(input.F4x())}
\NormalTok{                F5x.set(input.F5x())}
\NormalTok{                working\_SumFx\_string.set(str(working\_SumFx\_render()))}
\NormalTok{            else:}
\NormalTok{                 pass}
                              
\NormalTok{            if "Equilibrium Moments about O" in input.selected\_eqns(): }
\NormalTok{                NumMoments.set(input.NumMoments())}
\NormalTok{                M1.set(input.M1())}
\NormalTok{                M2.set(input.M2())}
\NormalTok{                M3.set(input.M3())}
\NormalTok{                M4.set(input.M4())}
\NormalTok{                M5.set(input.M5())}
\NormalTok{                working\_SumM\_string.set(str(working\_SumM\_render()))}
\NormalTok{            else:}
\NormalTok{                 pass}
                
\NormalTok{            if "Stress Equation" in input.selected\_eqns(): }
\NormalTok{                axial\_stress\_sigma.set(input.sigma())}
\NormalTok{                axial\_stress\_force.set(input.force())}
\NormalTok{                axial\_stress\_area.set(input.area())}
\NormalTok{                working\_StressEqn\_string.set(str(working\_StressEqn\_render()))}
\NormalTok{            else:}
\NormalTok{                 pass}
            
\NormalTok{            if "Axial Deformation by Force" in input.selected\_eqns(): }
\NormalTok{                axial\_delta\_l.set(input.axial\_delta\_l())}
\NormalTok{                axial\_P.set(input.axial\_P())}
\NormalTok{                axial\_L.set(input.axial\_L())}
\NormalTok{                axial\_A.set(input.axial\_A())}
\NormalTok{                axial\_E.set(input.axial\_E())}
\NormalTok{                working\_AxialDeform\_string.set(str(working\_AxialDeform\_render()))}
\NormalTok{            else:}
\NormalTok{                 pass}
            
\NormalTok{            if "Axial Deformation by Thermal" in input.selected\_eqns(): }
\NormalTok{                thermal\_delta\_t.set(input.thermal\_delta\_t())}
\NormalTok{                thermal\_alpha.set(input.thermal\_alpha())}
\NormalTok{                thermal\_Delta\_T.set(input.thermal\_Delta\_T())}
\NormalTok{                thermal\_L.set(input.thermal\_L())}
\NormalTok{                working\_ThermalDeform\_string.set(str(working\_ThermalDeform\_render()))}
\NormalTok{            else:}
\NormalTok{                 pass}
    
\NormalTok{            if "Area of a Tube" in input.selected\_eqns(): }
\NormalTok{                area\_tube\_A\_tube.set(input.A\_tube())}
\NormalTok{                area\_tube\_Ar\_o.set(input.Ar\_o())}
\NormalTok{                area\_tube\_Ar\_i.set(input.Ar\_i())}
\NormalTok{                working\_AreaTube\_string.set(str(working\_AreaTube\_render()))}
\NormalTok{            else:}
\NormalTok{                 pass}
    
\NormalTok{            if "Moment of Inertia of a Tube" in input.selected\_eqns():           }
\NormalTok{                I\_tube\_I\_tube.set(input.I\_tube())}
\NormalTok{                I\_tube\_Ir\_o.set(input.Ir\_o())}
\NormalTok{                i\_tube\_Ir\_i.set(input.Ir\_i())}
\NormalTok{                working\_Itube\_string.set(str(working\_Itube\_render()))}
\NormalTok{            else:}
\NormalTok{                 pass}
    
\NormalTok{            if "Bending Stress from a Moment" in input.selected\_eqns(): }
\NormalTok{                bending\_stress\_sigma.set(input.bendingstress\_sigma\_b())}
\NormalTok{                bending\_stress\_M.set(input.bendingstress\_M())}
\NormalTok{                bending\_stress\_y.set(input.bendingstress\_y())}
\NormalTok{                bending\_stress\_I.set(input.bendingstress\_I())}
\NormalTok{                working\_BendingStress\_string.set(str(working\_BendingStress\_render()))}
\NormalTok{            else:}
\NormalTok{                 pass}
    
\NormalTok{            if "Compatability Equation 1" in input.selected\_eqns(): }
\NormalTok{                Compatability1\_NumLHS.set(input.Compatability1\_NumLHS())}
\NormalTok{                Compatability1\_NumRHS.set(input.Compatability1\_NumRHS())}
\NormalTok{                Compatability1\_a\_1.set(input.a\_1())}
\NormalTok{                Compatability1\_a\_2.set(input.a\_2())}
\NormalTok{                Compatability1\_a\_3.set(input.a\_3())}
\NormalTok{                Compatability1\_a\_4.set(input.a\_4())}
\NormalTok{                Compatability1\_a\_5.set(input.a\_5())}
\NormalTok{                Compatability1\_b\_1.set(input.b\_1())}
\NormalTok{                Compatability1\_b\_2.set(input.b\_2())}
\NormalTok{                Compatability1\_b\_3.set(input.b\_3())}
\NormalTok{                Compatability1\_b\_4.set(input.b\_4())}
\NormalTok{                Compatability1\_b\_5.set(input.b\_5())}
\NormalTok{                working\_Compatability1\_string.set(str(working\_Compatability1\_render()))}
\NormalTok{            else:}
\NormalTok{                 pass}
    
\NormalTok{            if "Compatability Equation 2" in input.selected\_eqns(): }
\NormalTok{                Compatability2\_NumLHS.set(input.Compatability2\_NumLHS())}
\NormalTok{                Compatability2\_NumRHS.set(input.Compatability2\_NumRHS())}
\NormalTok{                Compatability2\_c\_1.set(input.c\_1())}
\NormalTok{                Compatability2\_c\_2.set(input.c\_2())}
\NormalTok{                Compatability2\_c\_3.set(input.c\_3())}
\NormalTok{                Compatability2\_c\_4.set(input.c\_4())}
\NormalTok{                Compatability2\_c\_5.set(input.c\_5())}
\NormalTok{                Compatability2\_d\_1.set(input.d\_1())}
\NormalTok{                Compatability2\_d\_2.set(input.d\_2())}
\NormalTok{                Compatability2\_d\_3.set(input.d\_3())}
\NormalTok{                Compatability2\_d\_4.set(input.d\_4())}
\NormalTok{                Compatability2\_d\_5.set(input.d\_5())}
\NormalTok{                working\_Compatability2\_string.set(str(working\_Compatability2\_render()))}
\NormalTok{            else:}
\NormalTok{                 pass}

                
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.feedback)}
\NormalTok{    def \_():}
\NormalTok{        inst\_eqns=[eqnbank\_newline[key] for key in ["Equilibrium Forces in Y", "Equilibrium Moments about O","Stress Equation", "Area of a Tube","Moment of Inertia of a Tube", "Bending Stress from a Moment","Compatability Equation 1"]]}
\NormalTok{        inst\_soln="6520"}
\NormalTok{        inst\_unknowns=["N","M\_o","\textbackslash{}sigma\_b", "\textbackslash{}sigma\_l","A\_\{tube\}","I\_\{tube\}","\textbackslash{}sigma\_\{max\}"]}
\NormalTok{        attempt\_equations=feedback\_equations()}
\NormalTok{        attempt\_soln=input.answer()}
\NormalTok{        attempt\_unknowns=feedback\_syms()}
\NormalTok{        missing\_inst\_eqns=set(inst\_eqns).difference(attempt\_equations)}
\NormalTok{        extra\_student\_eqns=set(attempt\_equations).difference(inst\_eqns)}
        
\NormalTok{        if inst\_soln==attempt\_soln:}
\NormalTok{          feedback\_message=ui.markdown("Congratulations! You are correct, great work.")}
\NormalTok{        else:}
\NormalTok{          feedback\_message=ui.markdown(f"This feedback is the list method {-}{-} checking your selected equations and associated parameters with instructor provided equations and unknowns. In this check, the instructor used these equations which you did not use \{missing\_inst\_eqns\} and you used these equations that the instructor did not use \{extra\_student\_eqns\}. This may help you think through any errors in your logic or could just be an indicator that you are approaching the problem differently which could still be correct. Further, looking at the unknown variables in each solution, you used these unknowns in your system of equations \{attempt\_unknowns\} and the instructor used the following unknowns \{inst\_unknowns\}. Again, this may help you think through possible errors in your logic or could just be an indicator that you used a different naming convention and/or are approaching the problem differently which could still be correct.")}
        
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback\_message, ui.tags.script(}
\NormalTok{                "if (window.MathJax) MathJax.Hub.Queue([\textquotesingle{}Typeset\textquotesingle{}, MathJax.Hub]);"}
\NormalTok{                ),}
\NormalTok{            title="Feedback on your solution",}
\NormalTok{            easy\_close=True,}
\NormalTok{            footer=None,}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}
        
        
\NormalTok{    @session.download(}
\NormalTok{    filename=lambda: f"Problem\_Log.csv"}
\NormalTok{    )}
\NormalTok{    async def download():}
\NormalTok{        \# This version uses a function to generate the filename. It also yields data}
\NormalTok{        \# multiple times.}
\NormalTok{          await asyncio.sleep(0.25)}
\NormalTok{          yield f"\{working\_equations\_solver()\}\textbackslash{}n"}
\NormalTok{          yield f"\{working\_equations\_latex\_render()\}\textbackslash{}n"}

\NormalTok{app = App(app\_ui, server)}



\end{Highlighting}
\end{Shaded}

\part{List of Working Problems}

\chapter*{Problem 2.23}\label{problem-2.23}
\addcontentsline{toc}{chapter}{Problem 2.23}

\markboth{Problem 2.23}{Problem 2.23}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-10}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/168.png}

}

\caption{Figure 1: A square bar of length is pinned at one end and rests
on a circular rod.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="168"}
\NormalTok{L1=reactive.Value("\_\_")}
\NormalTok{L2=reactive.Value("\_\_")}
\NormalTok{d=reactive.Value("\_\_")}
\NormalTok{F=reactive.Value("\_\_")}


\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of psi", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A square bar of length L\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{L1()\} in. and L\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{L2()\} in. is pinned at one end and rests on a circular rod of diameter d = \{d()\} in. A force F = \{F()\} lb is applied at the free end. What is the average shear stress in the circular rod? ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        L1.set(random.randrange(50, 150, 1)/10)}
\NormalTok{        L2.set(round(L1() * 1.4, 2))}
\NormalTok{        d.set(random.randrange(4, 9, 1)/10)}
\NormalTok{        F.set(random.randrange(30, 100, 1))}

\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
    
\NormalTok{        M = F()*(L1()+L2())}
\NormalTok{        R = M/L1()}
\NormalTok{        A = math.pi*(d()/2)**2}
\NormalTok{        instr= R/(2*A)}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 2.40}\label{problem-2.40}
\addcontentsline{toc}{chapter}{Problem 2.40}

\markboth{Problem 2.40}{Problem 2.40}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-11}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/169.png}

}

\caption{Figure 1: A steel connector plate is hung from a brass rod.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length))}

\NormalTok{problem\_ID="169"}
\NormalTok{d=reactive.Value("\_\_")}
\NormalTok{t=reactive.Value("\_\_")}
\NormalTok{w=reactive.Value("\_\_")}
\NormalTok{Fbrass = 70}
\NormalTok{Fsteel = 75}


\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of kips", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A steel connector plate is hung from a brass rod of diameter d = \{d()\} in. The plate has dimensions t = \{t()\} in. and w = \{w()\} in. Find the minimum load that will cause the connector or rod to fail. Assume the tensile and compressive failure stress for brass is 70 ksi and for steel is 75 ksi. Assume the shear failure stress for each material is one half of the tensile{-}compressive failure stress. ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        d.set(random.randrange(8, 20, 1)/10)}
\NormalTok{        t.set(random.randrange(3, 7, 1)/10)}
\NormalTok{        w.set(round(d() * 2, 2))}
        

\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.  }
      
\NormalTok{        instr= (Fsteel/2)*(2*.866*(w(){-}d())/2)}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 2.39}\label{problem-2.39}
\addcontentsline{toc}{chapter}{Problem 2.39}

\markboth{Problem 2.39}{Problem 2.39}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-12}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/180.png}

}

\caption{Figure 1: A link mechanism is connected with diameter pins.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="180"}
\NormalTok{F=reactive.Value("\_\_")}
\NormalTok{d=reactive.Value("\_\_")}
\NormalTok{t=reactive.Value("\_\_")}
\NormalTok{w=reactive.Value("\_\_")}



\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of ksi", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)  }
  
\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A link mechanism is connected with pins of diameter d = \{d()\} in. A force F = \{F()\} lb is applied to the mechanism as shown. The mechanism has thickness width w = \{w()\} in. and thickness t = \{t()\} in. What is the bearing stress in member BC at joint B due to the pin at B? ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        F.set(random.randrange(200, 900, 10))}
\NormalTok{        d.set(random.randrange(20, 150, 10)/100)}
\NormalTok{        t.set(random.randrange(2, 10, 1)/10)}
\NormalTok{        w.set(round(d() * 2, 2))}
        

\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        Fb=((18+8)*F())/18}
\NormalTok{        instr= Fb/((w()/2)*(d()/2))}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.11}\label{problem-5.11}
\addcontentsline{toc}{chapter}{Problem 5.11}

\markboth{Problem 5.11}{Problem 5.11}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-13}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/183.png}

}

\caption{Figure 1: A series of solid, steel, circular bars are loaded
with forces.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{problem\_ID="183"}
\NormalTok{F1=reactive.Value("\_\_")}
\NormalTok{F2=reactive.Value("\_\_")}
\NormalTok{F3=reactive.Value("\_\_")}
\NormalTok{F4=reactive.Value("\_\_")}
\NormalTok{E=210}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length))  }

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of mm", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A series of solid, steel, circular bars are loaded with forces as shown, where F\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{F1()\} kN, F\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{F2()\} kN, F\textless{}sub\textgreater{}3\textless{}/sub\textgreater{} = \{F3()\} kN, and F\textless{}sub\textgreater{}4\textless{}/sub\textgreater{} = \{F4()\} kN. What is the total change in length of the system? Assume E = 210 GPa for steel.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        F1.set(random.randrange(10, 100, 1)/10)}
\NormalTok{        F2.set(random.randrange(10, 100, 1)/10)}
\NormalTok{        F3.set(random.randrange(10, 100, 1)/10)}
\NormalTok{        F4.set(random.randrange(10, 100, 1)/10)}
        

\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        instr= ((F1()*3)/(E*math.pi*0.5**2)+((F1()+F2())*3)/(E*math.pi*1**2)+((F1()+F2()+F3())*4)/(E*math.pi*0.25**2)+((F1()+F2()+F3()+F4())*2)/(E*math.pi*0.5**2))*1000}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.12}\label{problem-5.12}
\addcontentsline{toc}{chapter}{Problem 5.12}

\markboth{Problem 5.12}{Problem 5.12}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-14}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/184.png}

}

\caption{Figure 1: Two forces are applied to the system of cylinders.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="184"}
\NormalTok{F1=reactive.Value("\_\_")}
\NormalTok{F2=reactive.Value("\_\_")}
\NormalTok{L1=reactive.Value("\_\_")}
\NormalTok{L2=reactive.Value("\_\_")}
\NormalTok{L3=reactive.Value("\_\_")}
\NormalTok{Esteel = 210}
\NormalTok{Ealuminum = 70}



\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of meters", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"Two forces, F\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{F1()\} kN and F\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{F2()\} kN, are applied to the system of cylinders as shown. If L\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{L1()\} m, L\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{L2()\} m, and L\textless{}sub\textgreater{}3\textless{}/sub\textgreater{} = \{L3()\} m, what is the total change in length of the system? Assume E\textless{}sub\textgreater{}steel\textless{}/sub\textgreater{} = \{Esteel\} GPa and E\textless{}sub\textgreater{}aluminum\textless{}/sub\textgreater{} = \{Ealuminum\} GPa.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        F1.set(random.randrange(100, 300, 1)/10)}
\NormalTok{        F2.set(round(F1()/1.5, 2))}
\NormalTok{        L1.set(random.randrange(20, 80, 1)/10)}
\NormalTok{        L2.set(round(L1()*0.6, 2))}
\NormalTok{        L3.set(round(L1()*0.8, 2))}
        

\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
       
\NormalTok{        instr= (F2()*L2())/(math.pi*0.3**2*Esteel*10**9) + ((F2(){-}F1())*L1())/(math.pi*0.5**2*Ealuminum*10**9)}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.13}\label{problem-5.13}
\addcontentsline{toc}{chapter}{Problem 5.13}

\markboth{Problem 5.13}{Problem 5.13}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-15}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/185.png}

}

\caption{Figure 1: Two forces are applied to the system of cylinders.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length))}

\NormalTok{problem\_ID="185"}
\NormalTok{F1=reactive.Value("\_\_")}
\NormalTok{F2=reactive.Value("\_\_")}
\NormalTok{L1=reactive.Value("\_\_")}
\NormalTok{L2=reactive.Value("\_\_")}
\NormalTok{Ebrass = 100}
\NormalTok{Ealuminum = 70}



\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of mm", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"Two forces, F\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{F1()\} kN and F\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{F2()\} kN, are applied to the system of cylinders as shown. If L\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{L1()\} mm and L\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{L2()\} mm, what is the total change in length of the system. Assume E\textless{}sub\textgreater{}brass\textless{}/sub\textgreater{} = \{Ebrass\} GPa and E\textless{}sub\textgreater{}aluminum\textless{}/sub\textgreater{} = \{Ealuminum\} GPa.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        F1.set(random.randrange(10, 100, 1)/10)}
\NormalTok{        F2.set(round(F1()*2, 2))}
\NormalTok{        L1.set(random.randrange(50, 150, 1))}
\NormalTok{        L2.set(round(L1()*1.5, 2))}
        

\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        instr= (((F2(){-}F1())*L1())/(math.pi*.002**2*Ebrass*10**6)) + (F2()*L2())/(math.pi*.003**2*Ealuminum*10**6)}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.14}\label{problem-5.14}
\addcontentsline{toc}{chapter}{Problem 5.14}

\markboth{Problem 5.14}{Problem 5.14}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-16}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/186.png}

}

\caption{Figure 1: A series of solid circular steel bars are loaded with
three loads.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length))}

\NormalTok{problem\_ID="186"}
\NormalTok{F1=reactive.Value("\_\_")}
\NormalTok{F2=reactive.Value("\_\_")}
\NormalTok{F3=reactive.Value("\_\_")}
\NormalTok{L1=reactive.Value("\_\_")}
\NormalTok{L3=reactive.Value("\_\_")}
\NormalTok{Esteel = 210}


\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of mm", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A series of solid circular steel bars are loaded as shown, where F\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{F1()\} N, F\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{F2()\} N, and F\textless{}sub\textgreater{}3\textless{}/sub\textgreater{} = \{F3()\} N. If lengths L\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = L\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{L1()\} cm and L\textless{}sub\textgreater{}3\textless{}/sub\textgreater{} = \{L3()\} cm, determine the total change in length of the system. Assume E\textless{}sub\textgreater{}steel\textless{}/sub\textgreater{} = 210 GPa.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        F1.set(random.randrange(20, 100, 1))}
\NormalTok{        F2.set(random.randrange(20, 100, 1))}
\NormalTok{        F3.set(random.randrange(20, 100, 1))}
\NormalTok{        L1.set(random.randrange(20, 60, 1))}
\NormalTok{        L3.set(round(L1()*1.25, 2))}
        
        

\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        instr= 0 + ((F1()*L1())/(math.pi*.003**2*Esteel*10**6)) + ((F3()*L3())/(math.pi*.005**2*Esteel*10**6))}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}

\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.15}\label{problem-5.15}
\addcontentsline{toc}{chapter}{Problem 5.15}

\markboth{Problem 5.15}{Problem 5.15}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-17}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/187.png}

}

\caption{Figure 1: A crate is attached to a cable made from steel and
aluminum.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="187"}
\NormalTok{W=reactive.Value("\_\_")}
\NormalTok{L1=reactive.Value("\_\_")}
\NormalTok{L2=reactive.Value("\_\_")}
\NormalTok{A1=reactive.Value("\_\_")}
\NormalTok{A2=reactive.Value("\_\_")}
\NormalTok{Esteel = 29000}
\NormalTok{Ealuminum = 10000}


\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of inches", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A crate weight W = \{W()\} lb is attached to a cable constructed from steel of length L\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{L1()\} in. and Area A\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{A1()\} in.\textless{}sup\textgreater{}2\textless{}/sup\textgreater{} and aluminum of length L\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{L2()\} in. and area A\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{A2()\} in.\textless{}sup\textgreater{}2\textless{}/sup\textgreater{}. What is the total deflection of the crate after it is attached to the wire? Assume E\textless{}sub\textgreater{}steel\textless{}/sub\textgreater{} = \{Esteel\} ksi and E\textless{}sub\textgreater{}aluminum\textless{}/sub\textgreater{} = \{Ealuminum\} ksi. Neglect the weight of the wires.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        W.set(random.randrange(50, 250, 1))}
\NormalTok{        L1.set(random.randrange(10, 30, 1))}
\NormalTok{        L2.set(round(L1()*2, 2))}
\NormalTok{        A1.set(random.randrange(1, 5, 1)/100)}
\NormalTok{        A2.set(random.randrange(1, 5, 1)/100)}
        
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
        
\NormalTok{        instr=(W()*L1())/(A1()*Esteel) + (W()*L2()/A2()*Ealuminum)}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 4.5}\label{problem-4.5}
\addcontentsline{toc}{chapter}{Problem 4.5}

\markboth{Problem 4.5}{Problem 4.5}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-18}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/188.png}

}

\caption{Figure 1: A single force pulls on three cylindrical rods that
are fixed to a wall.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length))}

\NormalTok{problem\_ID="188"}
\NormalTok{F=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{d1=reactive.Value("\_\_")}
\NormalTok{d2=reactive.Value("\_\_")}
\NormalTok{Esteel = 29000}
\NormalTok{Ealuminum = 10000}


\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of inches/inches", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A single force F = \{F()\} kips pulls on three cylindrical rods, each of length L = \{L()\} in., Diameter d\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{d1()\} in., and d\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{d2()\} in. What is the strain in the steel cylinder? Assume E\textless{}sub\textgreater{}steel\textless{}/sub\textgreater{} = 29,000 ksi and E\textless{}sub\textgreater{}aluminum\textless{}/sub\textgreater{} = 10,000 ksi.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        F.set(random.randrange(20, 300, 1)/10)}
\NormalTok{        L.set(random.randrange(50, 200, 1)/10)}
\NormalTok{        d1.set(random.randrange(10, 50, 1)/10)}
\NormalTok{        d2.set(round(d1()/2, 2))}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        instr=(F()/(((d2()/2)**2)*math.pi))/Esteel}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.27}\label{problem-5.27}
\addcontentsline{toc}{chapter}{Problem 5.27}

\markboth{Problem 5.27}{Problem 5.27}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-19}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/191.png}

}

\caption{Figure 1: A bar is attached to two wires, one steel and one
aluminum.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length))}

\NormalTok{problem\_ID="191"}
\NormalTok{L1=reactive.Value("\_\_")}
\NormalTok{L2=reactive.Value("\_\_")}
\NormalTok{F=reactive.Value("\_\_")}
\NormalTok{A=reactive.Value("\_\_")}
\NormalTok{Esteel = 29000}
\NormalTok{Ealuminum = 10000}


\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of inches", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A bar is attached to two wires, one steel and one aluminum. If the lengths of the wires L\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{L1()\} in. and L\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{L2()\} in., find the distance x that load F = \{F()\} kips must be placed at so that the bar remains horizontal after the load is applied. Both wires have the same cross{-}section area A = \{A()\} in. \textless{}sup\textgreater{}2\textless{}/sup\textgreater{}. Assume E\textless{}sub\textgreater{}steel\textless{}/sub\textgreater{} = 29,000 ksi and E\textless{}sub\textgreater{}aluminum\textless{}/sub\textgreater{} = 10,000 ksi.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        L1.set(random.randrange(50, 150, 1)/10)}
\NormalTok{        L2.set(round(L1()*2, 2))}
\NormalTok{        F.set(random.randrange(30, 150, 1)/10)}
\NormalTok{        A.set(random.randrange(2, 25, 1)/100)}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        PsPa = (L1()*Esteel*A())/(L2()*Ealuminum*A())}
\NormalTok{        Ps = (F()/(PsPa+1))*PsPa}
\NormalTok{        instr=(Ps*12)/F()}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.34}\label{problem-5.34}
\addcontentsline{toc}{chapter}{Problem 5.34}

\markboth{Problem 5.34}{Problem 5.34}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-20}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/192.png}

}

\caption{Figure 1: A copper circular rod is inserted into an aluminum
tube as shown.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="192"}
\NormalTok{r=reactive.Value("\_\_")}
\NormalTok{ri=reactive.Value("\_\_")}
\NormalTok{ro=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{dL=reactive.Value("\_\_")}
\NormalTok{Ecopper = 110}
\NormalTok{Ealuminum = 70}



\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of kN", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A copper circular rod of radius r = \{r()\} cm is inserted into an aluminum tube with inner radius r\textless{}sub\textgreater{}i\textless{}/sub\textgreater{} = \{ri()\} cm and outer radius r\textless{}sub\textgreater{}o\textless{}/sub\textgreater{} = \{ro()\} cm as shown. Load P is applied to the rigid top plate. If length L = \{L()\} cm, what load P will cause the plate to deflect dL = \{dL()\} mm downward? Assume E\textless{}sub\textgreater{}copper\textless{}/sub\textgreater{} = 110 GPa and E\textless{}sub\textgreater{}aluminum\textless{}/sub\textgreater{} = 70 GPa")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        r.set(random.randrange(20, 60, 1)/10)}
\NormalTok{        ri.set(round(r()*1.25, 2))}
\NormalTok{        ro.set(round(r()*1.5, 2))}
\NormalTok{        L.set(random.randrange(150, 300, 1)/10)}
\NormalTok{        dL.set(random.randrange(10, 50, 1)/100)}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        instr=((dL()*Ecopper*r()**2*math.pi)/L()) + ((dL()*Ealuminum*(ro(){-}ri())**2*math.pi)/L())}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.35}\label{problem-5.35}
\addcontentsline{toc}{chapter}{Problem 5.35}

\markboth{Problem 5.35}{Problem 5.35}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-21}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/193.png}

}

\caption{Figure 1: Two blocks with square cross sections are stacked and
loaded at the top.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="193"}
\NormalTok{F=reactive.Value("\_\_")}
\NormalTok{w1=reactive.Value("\_\_")}
\NormalTok{w2=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{Esteel = 29000}
\NormalTok{Ealuminum = 10000}



\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of inches", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"Two blocks with square cross{-}sections are stacked as shown, with the top block inserted into the bottom block and subjected to load F = \{F()\} kips. The top block is aluminum (E = 10,000 ksi) with side length w\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{w1()\} in.  and the bottom block is steel (E = 29,000 ksi) with side length w\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{w2()\} in. If length L = \{L()\} in., what is the total change in length of the aluminum block? Ignore the weight of the blocks. ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        F.set(random.randrange(20, 100, 1)/10)}
\NormalTok{        w1.set(random.randrange(15, 50, 1)/10)}
\NormalTok{        w2.set(round(w1()*1.5))}
\NormalTok{        L.set(random.randrange(50, 200, 1)/10)}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        instr=F()*L()*((1/((w1()**2)*Ealuminum)) + (1/((w2()**2)*Esteel)))}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 4.6}\label{problem-4.6}
\addcontentsline{toc}{chapter}{Problem 4.6}

\markboth{Problem 4.6}{Problem 4.6}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-22}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/194.png}

}

\caption{Figure 1: A polymer test specimen is pulled from the top and
bottom.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="194"}
\NormalTok{F=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{w=reactive.Value("\_\_")}
\NormalTok{t=reactive.Value("\_\_")}
\NormalTok{dL=reactive.Value("\_\_")}


\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of ksi", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A polymer test specimen is subjected to an axial load of F = \{F()\} kips. The central portion of the specimen has an initial length L = \{L()\} in., w = \{w()\} in., and t = \{t()\} in. If the length increases by dL = \{dL()\} in., determine the elastic modulus of the material. ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        F.set(random.randrange(100, 500, 1)/10)}
\NormalTok{        L.set(random.randrange(50, 150, 1)/10)}
\NormalTok{        w.set(round(L()*0.375, 2))}
\NormalTok{        t.set(random.randrange(10, 50, 1)/100)}
\NormalTok{        dL.set(random.randrange(3, 9, 1)/100)}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        instr= (F()*L())/(dL()*(w()*t()))}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 4.23}\label{problem-4.23}
\addcontentsline{toc}{chapter}{Problem 4.23}

\markboth{Problem 4.23}{Problem 4.23}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-23}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/204.png}

}

\caption{Figure 1: A block is pulled in by two forces.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="204"}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{t=reactive.Value("\_\_")}
\NormalTok{Fx=reactive.Value("\_\_")}
\NormalTok{Fy=reactive.Value("\_\_")}
\NormalTok{E=29000}
\NormalTok{v=0.29}


\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of inches", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A square steel plate of side length L = \{L()\} in. and thickness t = \{t()\} in. is uniformly pulled by two forces F\textless{}sub\textgreater{}x\textless{}/sub\textgreater{} = \{Fx()\} kips and F\textless{}sub\textgreater{}y\textless{}/sub\textgreater{} = \{Fy()\} kips as shown. If E = 29,000 ksi and Poisson\textquotesingle{}s ratio v = 0.29, determine the change in thickness of the plate. ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        L.set(random.randrange(50, 150, 1)/10)}
\NormalTok{        t.set(random.randrange(2, 10, 1)/10)}
\NormalTok{        Fx.set(random.randrange(100, 500, 1)/10)}
\NormalTok{        Fy.set(random.randrange(100, 500, 1)/10)}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        sigmax = Fx()/(L()*t())}
\NormalTok{        sigmay = Fy()/(L()*t())}
\NormalTok{        instr= t()*({-}v/E)*(sigmax+sigmay)}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 4.24}\label{problem-4.24}
\addcontentsline{toc}{chapter}{Problem 4.24}

\markboth{Problem 4.24}{Problem 4.24}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-24}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/205.png}

}

\caption{Figure 1: A strain gauge is placed on a test sample and a
vertical load is applied to the test sample.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="205"}
\NormalTok{P1=reactive.Value("\_\_")}
\NormalTok{E=reactive.Value("\_\_")}
\NormalTok{v=reactive.Value("\_\_")}
\NormalTok{SG=reactive.Value("\_\_")}



\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in percent", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A strain gauge is placed on a polymer test sample with an elastic modulus E =  \{E()\} x 10\textless{}sup\textgreater{}6\textless{}/sup\textgreater{} psi and a Poisson\textquotesingle{}s ratio of v = \{v()\}. When a P\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{P1()\} kip vertical load is applied to the test sample, the strain gauge reads a strain of SG = \{SG()\} x 10\textless{}sup\textgreater{}{-}6\textless{}/sup\textgreater{} in the x{-}direction. What is the relative error of the strain gauge compared to the theoretical strain of the test sample? Note: relative error is defined to be the difference between the measured value and the theoretical value divided by the theoretical value ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        P1.set(random.randrange(20, 200, 1)/10)}
\NormalTok{        E.set(random.randrange(5, 20, 1))}
\NormalTok{        v.set(random.randrange(20, 40, 1)/100)}
\NormalTok{        SG.set(round((v()*P1()*1000)/(12*E()){-}(0.3{-}2)*0.1, 2))}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        sigmaz = ({-}P1()*1000)/(4*3)}
\NormalTok{        Ex = (({-}v()*(sigmaz))/(E()*10**6))}
\NormalTok{        instr=  ((Ex {-} SG()*10**{-}6)/Ex)*100}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 4.10}\label{problem-4.10}
\addcontentsline{toc}{chapter}{Problem 4.10}

\markboth{Problem 4.10}{Problem 4.10}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-25}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/206.png}

}

\caption{Figure 1: A circular road is placed in tension with an axial
load.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="206"}
\NormalTok{P=reactive.Value("\_\_")}
\NormalTok{E=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{d=reactive.Value("\_\_")}



\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A circular rod of an unknown metallic alloy is placed in tension with a P = \{P()\} kip axial load. The length of the rod is L = \{L()\} in. and the diameter is d = \{d()\} in.. After applying the load, the rod length increases by .0035 in and the diameter decreases by .00014 in. The Young\textquotesingle{}s modulus is E = \{E()\} x 10\textless{}sup\textgreater{}6\textless{}/sup\textgreater{}. What is the Poisson\textquotesingle{}s ratio of the alloy?")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        P.set(random.randrange(20, 200, 1)/10)}
\NormalTok{        L.set(random.randrange(10, 20, 1))}
\NormalTok{        E.set(random.randrange(20, 40, 1)/100)}
\NormalTok{        d.set(round((.00014*L())/(.0035*E()), 2))}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
       
\NormalTok{        instr= {-}({-}.00014/d())/(.0035/L())}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 4.25}\label{problem-4.25}
\addcontentsline{toc}{chapter}{Problem 4.25}

\markboth{Problem 4.25}{Problem 4.25}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-26}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/208.png}

}

\caption{Figure 1: A block is pulled in all three directions.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="208"}
\NormalTok{Px=reactive.Value("\_\_")}
\NormalTok{Py=reactive.Value("\_\_")}
\NormalTok{Pz=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{E=reactive.Value("\_\_")}
\NormalTok{v=reactive.Value("\_\_")}


\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in percent", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A block with sides is pulled in all three directions (P\textless{}sub\textgreater{}x\textless{}/sub\textgreater{} = \{Px()\} kN, P\textless{}sub\textgreater{}y\textless{}/sub\textgreater{} = \{Py()\} kN, P\textless{}sub\textgreater{}z\textless{}/sub\textgreater{} = \{Pz()\} kN). What is the percent change in volume after all three loads are applied? Assume E = \{E()\} MPa and v = \{v()\}. ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        Px.set(random.randrange(1, 20, 1))}
\NormalTok{        Py.set(random.randrange(1, 20, 1))}
\NormalTok{        Pz.set(random.randrange(1, 20, 1))}
\NormalTok{        E.set(random.randrange(1000, 2000, 100))}
\NormalTok{        v.set(random.randrange(20, 40, 1)/100)}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        sigmax = (Px()/(5*2))*10}
\NormalTok{        sigmay = (Py()/(6*2))*10}
\NormalTok{        sigmaz = (Pz()/(5*6))*10}
\NormalTok{        Ex = (sigmax {-} v()*(sigmay+sigmaz))/(E())}
\NormalTok{        Ey = (sigmay {-} v()*(sigmaz+sigmax))/(E())}
\NormalTok{        Ez = (sigmaz {-} v()*(sigmax+sigmay))/(E())}
\NormalTok{        Lx = 6 + 6*Ex}
\NormalTok{        Ly = 5 + 5*Ey}
\NormalTok{        Lz = 2 + 2*Ez}
\NormalTok{        instr= (((Lx*Ly*Lz){-}60)/60)*100}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 4.11}\label{problem-4.11}
\addcontentsline{toc}{chapter}{Problem 4.11}

\markboth{Problem 4.11}{Problem 4.11}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-27}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/213.png}

}

\caption{Figure 1: A circular rod is inserted into a space slightly
wider than the rod.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="213"}
\NormalTok{r1=reactive.Value("\_\_")}
\NormalTok{r2=reactive.Value("\_\_")}
\NormalTok{E=15000}
\NormalTok{v=0.33}


\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of kip", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"An aluminum circular rod of radius r\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{r1()\} in is inserted into space that is slightly wider than the rod, where r\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{r2()\} in. What load P is needed so that the rod expands and fills the space in the radial direction? Assume E = 15,000 ksi and v = 0.33. ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        r1.set(random.randrange(10, 50, 1)/10)}
\NormalTok{        r2.set((r1() + (.002{-}0.2))*.001)}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        Ex = (r1() {-} r2())/r1()}
\NormalTok{        sigmay = (Ex*E)/({-}v)}
\NormalTok{        instr= sigmay*math.pi*r1()**2}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 4.12}\label{problem-4.12}
\addcontentsline{toc}{chapter}{Problem 4.12}

\markboth{Problem 4.12}{Problem 4.12}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-28}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/216.png}

}

\caption{Figure 1: A rectangular rod is pulled in tension in the
x-direction.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="216"}
\NormalTok{d1=reactive.Value("\_\_")}
\NormalTok{d2=reactive.Value("\_\_")}


\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A rectangular bar is pulled in tension by a load P in the x{-}direction. The bar deflects by d\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{d1()\} in and d\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{d2()\} in, in the x{-} and y{-}direction, respectively. The length in the x{-}direction is 5 in, and the length in the y direction is 1 in. What is the Poisson\textquotesingle{}s Ratio of the material? The z{-}direction deflection is not known. ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        d1.set(random.randrange(10, 50, 1)/1000)}
\NormalTok{        d2.set(random.randrange(10, 50, 1)/10000)}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        instr= {-}({-}d2()/1)/(d1()/5)}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.50}\label{problem-5.50}
\addcontentsline{toc}{chapter}{Problem 5.50}

\markboth{Problem 5.50}{Problem 5.50}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-29}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\begin{figure}[H]

{\centering \includegraphics{images/222.png}

}

\caption{Figure 1: A solid circular bar is between two fixed walls.}

\end{figure}%

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="222"}
\NormalTok{stress=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{E=29000}
\NormalTok{alpha=6.5*10**{-}6}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"The axial stress in a solid circular bar between two fixed walls is \{stress()\} ksi. Find the temperature change necessary to relieve the stress. Assume L = \{L()\} in., E = 29,000 ksi, and alpha = 6.5 x 10\textless{}sup\textgreater{}{-}6\textless{}/sup\textgreater{} / °F. ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        stress.set(random.randrange(10, 150, 5))}
\NormalTok{        L.set(random.randrange(15, 75, 1))}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        instr= stress()/(alpha*E)}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.51}\label{problem-5.51}
\addcontentsline{toc}{chapter}{Problem 5.51}

\markboth{Problem 5.51}{Problem 5.51}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-30}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/223.png}\{fig-alt='' A weight is placed on a
tall brass bar. The brass bar has a circular cross section of diameter
d.~``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="223"}
\NormalTok{W=reactive.Value("\_\_")}
\NormalTok{d=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{TC=reactive.Value("\_\_")}
\NormalTok{E=100*10**9}
\NormalTok{alpha=10*10**{-}6}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of mm", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"The W = \{W()\} kg weight is placed on a L = \{L()\} m tall brass bar with a cross section of d = \{d()\} cm. If the bar undergoes a temperature change of \{TC()\} °C, what is the total deformation of the bar? Assume the Young\textquotesingle{}s Modulus and thermal coefficient of expansion is 100 GPa and 10 x 10\textless{}sup\textgreater{}{-}6\textless{}/sup\textgreater{} / °C, respectively. Also, assume no buckling. ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        W.set(random.randrange(500, 2000, 100))}
\NormalTok{        L.set(random.randrange(10, 50, 1)/10)}
\NormalTok{        d.set(random.randrange(15, 40, 1)/10)}
\NormalTok{        TC.set(random.randrange(20, 150, 5))}
        
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        deltaT = L()*alpha*TC()}
\NormalTok{        deltaM = (W()*9.81*L())/(E*math.pi*(d()/2)**2)}
\NormalTok{        instr= deltaT {-} deltaM}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.52}\label{problem-5.52}
\addcontentsline{toc}{chapter}{Problem 5.52}

\markboth{Problem 5.52}{Problem 5.52}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-31}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/224.png}\{fig-alt='' Two cylindrical rods are
connected and heated until they expand to close the gap to the wall on
the right hand side. The left hand side is fixed. Rod A is attached to
the wall on the left hand side. Rod B is attached to Rod A. ``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="224"}
\NormalTok{d=reactive.Value("\_\_")}
\NormalTok{rA=reactive.Value("\_\_")}
\NormalTok{rB=reactive.Value("\_\_")}
\NormalTok{L1=reactive.Value("\_\_")}
\NormalTok{L2=reactive.Value("\_\_")}
\NormalTok{alphaA=6*10**{-}6}
\NormalTok{alphaB=10*10**{-}6}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of °F", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"Two cylindrical rods are heated until they expand, just closing the gap of d = \{d()\} in. The coefficient of thermal expansion, α, for material A and B is 6 x 10\textless{}sup\textgreater{}{-}6\textless{}/sup\textgreater{}/°F and 10 x 10\textless{}sup\textgreater{}{-}6\textless{}/sup\textgreater{}/°F, respectively. The radius of A r\textless{}sub\textgreater{}A\textless{}/sub\textgreater{} = \{rA()\} in and the length is L\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{L1()\} in. The radius of B is r\textless{}sub\textgreater{}B\textless{}/sub\textgreater{} = \{rB()\} in and the length is L\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{L2()\} in. What is the change in temperature.  ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        d.set(random.randrange(1, 20, 1)/100)}
\NormalTok{        rA.set(random.randrange(5, 20, 1)/10)}
\NormalTok{        rB.set(round(rA()*1.6, 2))}
\NormalTok{        L1.set(random.randrange(5, 20, 1))}
\NormalTok{        L2.set(round(L1()*0.6, 2))}
        
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        instr= d()/(alphaA*L1()+alphaB*L2())}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.53}\label{problem-5.53}
\addcontentsline{toc}{chapter}{Problem 5.53}

\markboth{Problem 5.53}{Problem 5.53}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-32}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/225.png}\{fig-alt='' Three cylindrical rods are
rigidly connected togehter with a load applied to the free end. The left
hand side is connected to the wall and is attached to rod A. Rod B is
attached to rod A on the left and rod C on the right. The load is
applied to the free end of rod C. The diameter of rod A is 3 cm, the
diameter of rod B is 1 cm, and the diameter of rod C is 2 cm.''\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="225"}
\NormalTok{L1=reactive.Value("\_\_")}
\NormalTok{L2=reactive.Value("\_\_")}
\NormalTok{L3=reactive.Value("\_\_")}
\NormalTok{F=reactive.Value("\_\_")}
\NormalTok{dT=reactive.Value("\_\_")}
\NormalTok{alphaA=10*10**{-}6}
\NormalTok{alphaB=5*10**{-}6}
\NormalTok{alphaC=7*10**{-}6}
\NormalTok{EA=40*10**9}
\NormalTok{EB=120*10**9}
\NormalTok{EC=80*10**9}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of m", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"Three cylindrical rods of lengths L\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{L1()\} in., L\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{L2()\} in., and L\textless{}sub\textgreater{}3\textless{}/sub\textgreater{} = \{L3()\} in. are connected together. A force F = \{F()\} kN is applied to the free end and all three rods are heated by \{dT()\} °C. The coefficient of thermal expansion, α, and elastic modulus, E, for each material are α\textless{}sub\textgreater{}A\textless{}/sub\textgreater{} = 10 x 10\textless{}sup\textgreater{}{-}6\textless{}/sup\textgreater{} /°C, α\textless{}sub\textgreater{}B\textless{}/sub\textgreater{} = 5 x 10\textless{}sup\textgreater{}{-}6\textless{}/sup\textgreater{} /°C, α\textless{}sub\textgreater{}C\textless{}/sub\textgreater{} = 7 x 10\textless{}sup\textgreater{}{-}6\textless{}/sup\textgreater{} /°C, E\textless{}sub\textgreater{}A\textless{}/sub\textgreater{} = 40 GPa, E\textless{}sub\textgreater{}B\textless{}/sub\textgreater{} = 120 GPa, and E\textless{}sub\textgreater{}C\textless{}/sub\textgreater{} = 80 GPa. What is the total deflection of the right rod tip?  ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        L1.set(random.randrange(10, 90, 1))}
\NormalTok{        L2.set(round(L1()*0.8))}
\NormalTok{        L3.set(round(L1()*(2/3)))}
\NormalTok{        F.set(random.randrange(5, 50, 1))}
\NormalTok{        dT.set(random.randrange(100, 300, 10))}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        deltaL = (F()*L1()/100)/(EA*math.pi*.015**2) + (F()*L2()/100)/(EB*math.pi*.005**2) + (F()*L3()/100)/(EC*math.pi*.01**2)}
\NormalTok{        deltaT = alphaA*dT()*L1()/100 + alphaB*dT()*L2()/100 + alphaC*dT()*L3()/100 }
\NormalTok{        instr= deltaL + deltaT}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.54}\label{problem-5.54}
\addcontentsline{toc}{chapter}{Problem 5.54}

\markboth{Problem 5.54}{Problem 5.54}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-33}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/226.png}\{fig-alt='' A long square brass bar is
placed between two fixed walls. The bar has length L. The cross section
is square with sides h. ``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="226"}
\NormalTok{T1=reactive.Value("\_\_")}
\NormalTok{T2=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{h=reactive.Value("\_\_")}
\NormalTok{alpha=20*10**{-}6}
\NormalTok{E=100*10**9}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of MPa", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A long square brass bar is placed between two fixed walls and heated from \{T1()\} °C to \{T2()\} °C. If L = \{L()\} mm, h = \{h()\} mm, E = 100 GPa, and α = 20 x 10\textless{}sup\textgreater{}{-}6\textless{}/sup\textgreater{} /°C, determine the stress in the bar.  ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        T1.set(random.randrange(5, 20, 1))}
\NormalTok{        T2.set(round(T1() + random.randrange(20, 50, 1), 2))}
\NormalTok{        L.set(random.randrange(250, 750, 10))}
\NormalTok{        h.set(random.randrange(10, 30, 1))}
       
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        instr= (E*alpha*(T2(){-}T1()))/10**6}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.36}\label{problem-5.36}
\addcontentsline{toc}{chapter}{Problem 5.36}

\markboth{Problem 5.36}{Problem 5.36}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-34}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/246.png}\{fig-alt='' Two square members are
placed between two fixed walls. The wood piece is on the left and the
plastic piece is on the right. Point B is at the intersection of the
wood and plastic members. The members are each length L. ``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="246"}
\NormalTok{d=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{Eplastic=reactive.Value("\_\_")}
\NormalTok{Ewood=1750}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of lb", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"Two square members are attached to two fixed walls as shown. Force F is applied at point B and point B is displaced d =  \{d()\} in. to the right. If L = \{L()\} in., E\textless{}sub\textgreater{}wood\textless{}/sub\textgreater{} = 1,750 ksi, and E\textless{}sub\textgreater{}plastic\textless{}/sub\textgreater{} = \{Eplastic()\} ksi, determine the applied force F. ")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        d.set(random.randrange(2, 8, 1)/1000)}
\NormalTok{        L.set(random.randrange(4, 15, 1))}
\NormalTok{        Eplastic.set(random.randrange(350, 900, 10))}
       
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        instr= (d()*1*Ewood*1000)/5 {-} ({-}d()*4*Eplastic()*1000)/5 }
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.37}\label{problem-5.37}
\addcontentsline{toc}{chapter}{Problem 5.37}

\markboth{Problem 5.37}{Problem 5.37}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-35}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/247.png}\{fig-alt='' Two aluminum circular rods
are placed between two fixed walls. Member 1 is on the left and member 2
is on the right. Member 2 has diameter d{[}1{]} and length L{[}1{]}.
Member 2 has diameter d{[}2{]} and length L{[}2{]} ``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="247"}
\NormalTok{F=reactive.Value("\_\_")}
\NormalTok{d1=reactive.Value("\_\_")}
\NormalTok{d2=reactive.Value("\_\_")}
\NormalTok{L1=reactive.Value("\_\_")}
\NormalTok{L2=reactive.Value("\_\_")}
\NormalTok{Ewood=70}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of MPa", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"Two aluminum circular rods are attached to two fixed walls as shown. Assume E = 70 MPa for both cylinders, F = \{F()\} kN, d\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{d1()\} mm, d\textless{}sub\textgreater{}2\textless{}/sub\textgreater{}  = \{d2()\} mm, L\textless{}sub\textgreater{}1\textless{}/sub\textgreater{}  = \{L1()\} mm, and L\textless{}sub\textgreater{}2\textless{}/sub\textgreater{}  = \{L2()\} mm. Determine the normal stress in member 1.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        F.set(random.randrange(20, 100, 1))}
\NormalTok{        d1.set(random.randrange(15, 50, 1))}
\NormalTok{        d2.set(round(d1()*1.5, 2))}
\NormalTok{        L1.set(random.randrange(200, 800, 10))}
\NormalTok{        L2.set(round(L1()*(2/3), 2))}
       
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        LHS = (L1()/100)/(math.pi*(d1()/200)**2) + (L2()/100)/(math.pi*(d2()/200)**2)}
\NormalTok{        RHS = (F()*L2()/100)/(math.pi*(d2()/200)**2)}
\NormalTok{        instr= (RHS/LHS)/(math.pi*(d1()/200)**2)}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.38}\label{problem-5.38}
\addcontentsline{toc}{chapter}{Problem 5.38}

\markboth{Problem 5.38}{Problem 5.38}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-36}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/248.png}\{fig-alt='' A pressure load is applied
to a short column made of wood and concrete. Concerete is the center of
the column and it is surrounded by wood. The side of the column is 3 *
b, with the width of the wood, concrete, and wood each being b. The
other side of the column is h{[}1{]} + h{[}2{]} + h{[}1{]}, with the
length of the wood being h{[}1{]} and the length of the concrete being
h{[}2{]}. ``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="248"}
\NormalTok{w=reactive.Value("\_\_")}
\NormalTok{b=reactive.Value("\_\_")}
\NormalTok{h1=reactive.Value("\_\_")}
\NormalTok{h2=reactive.Value("\_\_")}
\NormalTok{Econcrete=25}
\NormalTok{Ewood=12}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of kN", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A distributed load w = \{w()\} N/cm\textless{}sup\textgreater{}2\textless{}/sup\textgreater{} is applied to a short column made from wood and concrete. Assume E\textless{}sub\textgreater{}concrete \textless{}/sub\textgreater{}= 25 GPa, E\textless{}sub\textgreater{}wood\textless{}/sub\textgreater{} = 12 GPa, b = \{b()\} cm, h\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{h1()\} cm, and h\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{h2()\} cm. What load is carried by the concrete center?")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        w.set(random.randrange(50, 750, 10))}
\NormalTok{        b.set(random.randrange(20, 100, 1)/10)}
\NormalTok{        h1.set(b()*1)}
\NormalTok{        h2.set(b()*2)}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        Wside = (h2()*b()*2+3*b()*b()*2)*Ewood*10**9}
\NormalTok{        Cside = (h2()*b()*2)*Econcrete*10**9}
\NormalTok{        RHS = Wside+Cside}
\NormalTok{        LHS = (w()*(h1()+h2()+h1())*(3*b()))*Cside}
\NormalTok{        instr= LHS/RHS}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.55}\label{problem-5.55}
\addcontentsline{toc}{chapter}{Problem 5.55}

\markboth{Problem 5.55}{Problem 5.55}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-37}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/249.png}\{fig-alt='' Two bars are pinned at
joint B between two walls. Joint AB is on the left hand side and joint
BC is on the right hand side. Both bars are length L and thickness t and
height h. The diameter of the bolt holding them together is d.~``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="249"}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{d=reactive.Value("\_\_")}
\NormalTok{t=reactive.Value("\_\_")}
\NormalTok{h=reactive.Value("\_\_")}
\NormalTok{dT=reactive.Value("\_\_")}
\NormalTok{E=200}
\NormalTok{v=0.32}
\NormalTok{a=11.7*10**{-}6}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of MPa", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"Bars AB and BC are pinned at joint B. Both bars are made from the same material with E = 200 GPa, v = 0.32, and a = 11.7 x 10\textless{}sup\textgreater{}{-}6\textless{}/sup\textgreater{} /°C. Dimensions L = \{L()\}  mm, t = \{t()\} mm, h = \{h()\} mm, and d = \{d()\} mm. If both bars are heated by \{dT()\} °C, determine the shear stress generated in the pin at B.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        L.set(random.randrange(300, 900, 10))}
\NormalTok{        t.set(random.randrange(30, 80, 1))}
\NormalTok{        h.set(t()/2)}
\NormalTok{        d.set(round(t()/3,2))}
\NormalTok{        dT.set(random.randrange(10, 40, 1))}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        deltaM = a*dT()*(t()/1000)*(h()/1000)*E*10**9}
\NormalTok{        instr= (deltaM/(math.pi*(d()/2000)**2))/10**6}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 5.39}\label{problem-5.39}
\addcontentsline{toc}{chapter}{Problem 5.39}

\markboth{Problem 5.39}{Problem 5.39}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-38}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/250.png}\{fig-alt='' A concrete post with 6
steel rebar rods embedded in the concrete supports a load, F. The post
has diamete d{[}c{]} and the rebar rods have diamete d{[}s{]}. ``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="250"}
\NormalTok{F=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{dc=reactive.Value("\_\_")}
\NormalTok{ds=reactive.Value("\_\_")}
\NormalTok{Econcrete=25}
\NormalTok{Esteel=200}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of MPa", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A concrete post of length L = \{L()\}  m and diameter d\textless{}sub\textgreater{}c\textless{}/sub\textgreater{} = \{dc()\} mm supports a load F = \{F()\} kN. The concrete is reinforced with 6 steel rods of diameter d\textless{}sub\textgreater{}s\textless{}/sub\textgreater{} = \{ds()\} mm. Assume Econcrete = 25 GPa and Esteel = 200 GPa. Determine the stress in the concrete.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        L.set(random.randrange(10, 50, 1)/10)}
\NormalTok{        dc.set(random.randrange(100, 500, 10))}
\NormalTok{        ds.set(round(dc()/12,2))}
\NormalTok{        F.set(random.randrange(100, 500, 10))}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        As = (math.pi*6*(ds()/20)**2)}
\NormalTok{        Ac = (math.pi*(dc()/20)**2) {-} As}
\NormalTok{        Cside = Ac*Econcrete}
\NormalTok{        Sside = As*Esteel}
\NormalTok{        LHS = F()*Cside}
\NormalTok{        RHS = Cside+Sside}
\NormalTok{        instr= ((LHS/RHS)/(Ac/100**2))/10**3}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 6.1}\label{problem-6.1}
\addcontentsline{toc}{chapter}{Problem 6.1}

\markboth{Problem 6.1}{Problem 6.1}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-39}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/265.png}\{fig-alt='' A bar is fixed to a wall at
one end. The bar has diameter d.~``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="265"}
\NormalTok{T=reactive.Value("\_\_")}
\NormalTok{d=reactive.Value("\_\_")}


\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of kN{-}m", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"What torque is required to create a maximum shear stress of τ = \{T()\} MPa in a solid circular bar of diameter d  = \{d()\} mm? .")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        T.set(random.randrange(20, 50, 1))}
\NormalTok{        d.set(random.randrange(50, 200, 1))}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        J = (math.pi/2)*(d()/2000)**4}
\NormalTok{        instr= (T()*1000*J)/(d()/2000)}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 6.11}\label{problem-6.11}
\addcontentsline{toc}{chapter}{Problem 6.11}

\markboth{Problem 6.11}{Problem 6.11}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-40}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/266.png}\{fig-alt='' A hollow copper rod is
fixed to a wall at one end and a torque is applied. The rod has an outer
diameter of d{[}o{]} and inner diameter of d{[}i{]} and length L. ``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="266"}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{do=reactive.Value("\_\_")}
\NormalTok{di=reactive.Value("\_\_")}
\NormalTok{angle=(reactive.Value("\_\_"))}
\NormalTok{E = 110}
\NormalTok{v = 0.33}


\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of kN{-}m", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A hollow copper rod (E = 110 GPa, v = 0.33) is subjected to torque T as shown. If length L = \{L()\} m, outer diameter d\textless{}sub\textgreater{}o\textless{}/sub\textgreater{} = \{do()\} mm, and inner diameter d\textless{}sub\textgreater{}i\textless{}/sub\textgreater{} = \{di()\} mm, determine torque T if the rod twists \{angle()\} ° .")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        L.set(random.randrange(5, 30, 1)/10)}
\NormalTok{        do.set(random.randrange(50, 200, 1))}
\NormalTok{        di.set(round(do()/2, 2))}
\NormalTok{        angle.set(random.randrange(1, 10, 1))}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        G = E*10**9/(2*(1+v))}
\NormalTok{        J = (math.pi/2)*((do()/2000)**4 {-}(di()/2000)**4 )}
\NormalTok{        instr= ((math.radians(angle())*G*J)/L())/10**3}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 6.2}\label{problem-6.2}
\addcontentsline{toc}{chapter}{Problem 6.2}

\markboth{Problem 6.2}{Problem 6.2}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-41}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/267.png}\{fig-alt='' A hand crank is attached to
the wall. Member AB is attached the wall and member CD is where the
force is applied. AB and CD are length L and BC has length y. ``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="267"}
\NormalTok{F=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{y=reactive.Value("\_\_")}
\NormalTok{d=(reactive.Value("\_\_"))}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of ksi", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A force F = \{F()\} lb is applied to a hand crank that is stuck and will not turn. If L = \{L()\} in. and y = \{y()\} in., determine the maximum shear stress due to torsion in the crank rod between A and B. Assume the crank has diameter d = \{d()\} in. .")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        F.set(random.randrange(100, 750, 10))}
\NormalTok{        L.set(random.randrange(100, 200, 1)/10)}
\NormalTok{        y.set(round(L()/2, 2))}
\NormalTok{        d.set(random.randrange(3, 15, 1)/10)}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        T = F()*y()}
\NormalTok{        J = (math.pi/2)*(d()/2)**4}
\NormalTok{        instr= ((T*d()/2)/J)/10**3}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 6.12}\label{problem-6.12}
\addcontentsline{toc}{chapter}{Problem 6.12}

\markboth{Problem 6.12}{Problem 6.12}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-42}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/268.png}\{fig-alt='' A bar is attached to a
wall. The bar has an inner diameter of 1 in and outer diameter of 2 in.
Torque, T{[}1{]} is applied halfway down the bar. The bar length is 10
in total. ``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="268"}
\NormalTok{T1=reactive.Value("\_\_")}
\NormalTok{angle=reactive.Value("\_\_")}
\NormalTok{G=reactive.Value("\_\_")}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of ft{-}lb", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A bar with a shear modulus G = \{G()\} x 10\textless{}sup\textgreater{}6\textless{}/sup\textgreater{} psi is subjected to torques T\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{T1()\} lb{-}ft at its center and T\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} at its free end. The inner diamter is 1 in and the outer diameter is 2 in and the total length of the bar is 10 in. If the rotation of the rod at its free end is Θ =  \{angle()\} ° clockwise, what is the magnitude of torque T\textless{}sub\textgreater{}2\textless{}/sub\textgreater{}?")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        G.set(random.randrange(90, 130, 1)/10)}
\NormalTok{        T1.set(random.randrange(1000, 5000, 100))}
\NormalTok{        angle.set(random.randrange(10, 50, 1)/10)}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        J = (math.pi/2)*((2/2)**4{-}(1/2)**4)}
\NormalTok{        LHS = (T1()*12*5) + math.radians(angle())*(G()*10**6*J)}
\NormalTok{        RHS = 12*5 + 12*5 }
\NormalTok{        instr= LHS/RHS}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 6.13}\label{problem-6.13}
\addcontentsline{toc}{chapter}{Problem 6.13}

\markboth{Problem 6.13}{Problem 6.13}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-43}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/269.png}\{fig-alt='' A system of cylinders are
attached to the wall at one end. The first torque is applied at the
connection of the cylidner attached to the wall made of steel with the
cylinder made of aluminum. The second torque is applied at the
connection between the cylinder made of aluminum and the second cylinder
made of steel. The third torque is applied at the free end. The first
cyliner has length 10 cm and diamter 5 cm. The second cyliner has length
15 cm and diamter 3 cm. The third cyliner has length 8 cm and diamter 4
cm. ``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="269"}
\NormalTok{T1=reactive.Value("\_\_")}
\NormalTok{T2=reactive.Value("\_\_")}
\NormalTok{T3=reactive.Value("\_\_")}
\NormalTok{Es=77}
\NormalTok{Ea=27}
\NormalTok{vs=0.3}
\NormalTok{va=0.33}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of degrees", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"Three moments are applied to the system of cylinders as shown. Assume T\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{T1()\} kN{-}m, T\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{T2()\} kN{-}m, and T\textless{}sub\textgreater{}3\textless{}/sub\textgreater{} = \{T3()\} kN{-}m. If E\textless{}sub\textgreater{}steel\textless{}/sub\textgreater{} = 77 GPa and E\textless{}sub\textgreater{}aluminum\textless{}/sub\textgreater{} = 27 GPa, determine the total angle of twist at the free end.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        T1.set(random.randrange(20, 100, 1)/10)}
\NormalTok{        T2.set(T1()+random.randrange(20, 100, 1)/10)}
\NormalTok{        T3.set(round(T2()*random.randrange(5, 8, 1)/10, 2))}
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        F1 = T1()+T2(){-}T3()}
\NormalTok{        F2 = T2(){-}T3()}
\NormalTok{        F3 = {-}T3()}
\NormalTok{        J1 = (math.pi/2)*((5/200)**4)}
\NormalTok{        J2 = (math.pi/2)*((3/200)**4)}
\NormalTok{        J3 = (math.pi/2)*((4/200)**4)}
\NormalTok{        Gs = Es/(2*(1+vs))}
\NormalTok{        Ga = Ea/(2+(1+va))}
\NormalTok{        instr= (T1()*.1)/(J1*Gs*10**6) + (T2()*.15)/(J2*Ga*10**6) + (T3()*.08)/(J3*Gs*10**6)}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 6.14}\label{problem-6.14}
\addcontentsline{toc}{chapter}{Problem 6.14}

\markboth{Problem 6.14}{Problem 6.14}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-44}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/270.png}\{fig-alt='' A circular rod is attached
to a wall. The rod has length L and an inner radius r{[}i{]} and outer
radius r{[}o{]}. The torque is apllied at the free end. ``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="270"}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{ro=reactive.Value("\_\_")}
\NormalTok{T=reactive.Value("\_\_")}
\NormalTok{G=reactive.Value("\_\_")}
\NormalTok{stress=reactive.Value("\_\_")}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of cm", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A circular rod of length L = \{L()\} mm, outer radius r\textless{}sub\textgreater{}o\textless{}/sub\textgreater{} = \{ro()\} mm, and unknown inner radius r\textless{}sub\textgreater{}i\textless{}/sub\textgreater{} has a shear modulus G = \{G()\} GPa. The rod is subjected to torque T = \{T()\} kN{-}m at the free end. If the angle of twist must not exceed 2° and the shear stress must not exceed \{stress()\} MPa, what is the minimum required inner radius?")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        L.set(random.randrange(250, 500, 10))}
\NormalTok{        ro.set(random.randrange(30, 75, 1))}
\NormalTok{        G.set(random.randrange(60, 100, 1))}
\NormalTok{        T.set(random.randrange(10, 100, 1)/10)}
\NormalTok{        stress.set(random.randrange(75, 150, 1))}
        
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        LHS = (((math.pi/2)*stress()*10**6)*(ro()/1000)**4){-}(T()*(ro()/1000))}
\NormalTok{        RHS = ((math.pi/2)*stress()*10**6)}
\NormalTok{        instr= ((LHS/RHS)**.25)*100}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 6.3}\label{problem-6.3}
\addcontentsline{toc}{chapter}{Problem 6.3}

\markboth{Problem 6.3}{Problem 6.3}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-45}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/273.png}\{fig-alt='' A torque is applied two
part circular rod, with one end attached to the wall. The part attached
to the wall has diameter d{[}1{]} and length 40 in. T{[}1{]} is applied
at the intersection of the rods. The second rod has diameter d{[}2{]}
and length 30 in. T{[}2{]} is applied at the free end. ``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="273"}
\NormalTok{T1=reactive.Value("\_\_")}
\NormalTok{T2=reactive.Value("\_\_")}
\NormalTok{d1=reactive.Value("\_\_")}
\NormalTok{d2=reactive.Value("\_\_")}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of psi", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"Two torques are applied to a two part circular rod as shown. If T\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{T1()\} kip{-}in., T\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{T2()\} kip{-}in., d\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{d1()\} in., and d\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{d2()\} in., what is the magnitude of the maximum shear stress?")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        T1.set(random.randrange(5, 50, 1))}
\NormalTok{        T2.set(T1()*random.randrange(3, 5, 1)/10)}
\NormalTok{        d1.set(random.randrange(40, 80, 1)/10)}
\NormalTok{        d2.set(round(d1()*0.8, 2))}
        
        
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        F1 = {-}T1()+T2()}
\NormalTok{        F2 = T2()}
\NormalTok{        J1 = (math.pi/2)*(d1()/2)**4}
\NormalTok{        J2 = (math.pi/2)*(d2()/2)**4}
\NormalTok{        instr= ({-}1*F1*(d1()/2)/J1)*1000}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 6.15}\label{problem-6.15}
\addcontentsline{toc}{chapter}{Problem 6.15}

\markboth{Problem 6.15}{Problem 6.15}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-46}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/274.png}\{fig-alt='' A hollow circualr rod is
attached to a wall and subjected to a torque at the free end. The rod
has inner diameter 8 cm and outer diameter 10 cm. The rod is length, L.
``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="274"}
\NormalTok{T=reactive.Value("\_\_")}
\NormalTok{x=reactive.Value("\_\_")}
\NormalTok{G=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of degrees", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A hollow circular rod is attached to a wall and subjected to a torque T = \{T()\} kN{-}m at the free end.The rod has inner diameter 8 cm and outer diameter 10 cm.  Determine the angle of twist at x = \{x()\} mm. Assume G = \{G()\} GPa and L = \{L()\} mm.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        T.set(random.randrange(20, 200, 1)/10)}
\NormalTok{        G.set(random.randrange(30, 60, 1))}
\NormalTok{        L.set(random.randrange(300, 800, 10))}
\NormalTok{        x.set(L()*random.randrange(2,7,1)/10)}
        
        
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        J = (math.pi/2)*((10/200)**4 {-} (8/200)**4)}
\NormalTok{        angle = (T()*1000*x()/1000)/(G()*10**9*J)}
\NormalTok{        instr= math.degrees(angle)}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 6.4}\label{problem-6.4}
\addcontentsline{toc}{chapter}{Problem 6.4}

\markboth{Problem 6.4}{Problem 6.4}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-47}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/276.png}\{fig-alt='' Three belt pullets are
connected to a solid shaft. The shaft is dixed at points A and E.
F{[}1{]} is applied at the first pulley, or point B. F{[}2{]} is applied
at the second pulley or point C. F{[}3{]} is applied at the third pulley
or point D. The shaft has diameter d.~``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="276"}
\NormalTok{d=reactive.Value("\_\_")}
\NormalTok{F1=reactive.Value("\_\_")}
\NormalTok{F2=reactive.Value("\_\_")}
\NormalTok{F3=reactive.Value("\_\_")}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of ksi", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"Three belt pulleys are connected to a solid circular shaft of diameter d = \{d()\} in. that rotates freely at joints A and E. The pulleys are subjected to forces F\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{F1()\} kips, F\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{F2()\} kips, and F\textless{}sub\textgreater{}3\textless{}/sub\textgreater{} = \{F3()\} kips. What is the maximum shear stress in the shaft between pulleys B and C?")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        d.set(random.randrange(20, 40, 1)/10)}
\NormalTok{        F1.set(random.randrange(20, 200, 2)/10)}
\NormalTok{        F2.set(F1()/2)}
\NormalTok{        F3.set(round(F1()*0.9, 2))}
        
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        T = 6*F1()}
\NormalTok{        instr= (T*(d()/2))/((math.pi/2)*(d()/2)**4)}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 6.5}\label{problem-6.5}
\addcontentsline{toc}{chapter}{Problem 6.5}

\markboth{Problem 6.5}{Problem 6.5}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-48}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/278.png}\{fig-alt='' Two torques are applied to
a hollow piped attached to the wall. The pipe has inner radius r{[}i{]}
and outer radius r{[}o{]}. The torque T{[}B{]} is applied at a distance
L from the wall. The torque T{[}C{]} is applied at a distance L from
T{[}B{]} at the free end. ``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="278"}
\NormalTok{ro=reactive.Value("\_\_")}
\NormalTok{ri=reactive.Value("\_\_")}
\NormalTok{TB=reactive.Value("\_\_")}
\NormalTok{TC=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of psi", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"Two torques ,T\textless{}sub\textgreater{}B\textless{}/sub\textgreater{} = \{TB()\} kip{-}ft and T\textless{}sub\textgreater{}C\textless{}/sub\textgreater{} = \{TC()\} kip{-}ft, are applied to the hollow pipe as shown. If L = \{L()\} ft., r\textless{}sub\textgreater{}o\textless{}/sub\textgreater{} = \{ro()\} in., and r\textless{}sub\textgreater{}i\textless{}/sub\textgreater{} = \{ri()\} in., determine the maximum shear stress in the pipe.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        TB.set(random.randrange(500, 5000, 100))}
\NormalTok{        TC.set(TB()/2)}
\NormalTok{        L.set(random.randrange(10, 90, 1)/10)}
\NormalTok{        ro.set(random.randrange(15, 60, 1)/10)}
\NormalTok{        ri.set(round(ro()*0.8))}
        
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        Tmax = TB(){-}TC()}
\NormalTok{        J = (math.pi/2)*(ro()**4 {-} ri()**4)}
\NormalTok{        instr= (Tmax*L()*12*ro())/J}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 6.27}\label{problem-6.27}
\addcontentsline{toc}{chapter}{Problem 6.27}

\markboth{Problem 6.27}{Problem 6.27}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-49}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/287.png}\{fig-alt='' A steel rod is attached
between two walls. The load is applied to a perpendicular rod at a
distance L from the steel rod. The steel rod has diameter d, the
distance between the AB is 40 cm, and the distance between BC is 30 cm.
``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="287"}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{F=reactive.Value("\_\_")}
\NormalTok{d=reactive.Value("\_\_")}
\NormalTok{G = 75}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of MPa", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A steel rod of diameter d = \{d()\} mm is attached to walls A and C as shown. Two forces F = \{F()\} kN are applied at distance L = \{L()\} mm. If the shear modulus of the rod G = 75 GPa, determine the maximum shear stress in the rod.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        d.set(random.randrange(20, 60, 1))}
\NormalTok{        F.set(random.randrange(2, 20, 1))}
\NormalTok{        L.set(random.randrange(80, 120, 1))}
        
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        TB = 2*F()*L()/1000}
\NormalTok{        J = (math.pi/2)*(d()/2000)**4}
\NormalTok{        TA = (0.3*0.4)/(0.4+0.3)}
\NormalTok{        TC = TB{-}TA}
\NormalTok{        instr= (TC*(d()/2000))/J}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 6.28}\label{problem-6.28}
\addcontentsline{toc}{chapter}{Problem 6.28}

\markboth{Problem 6.28}{Problem 6.28}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-50}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/288.png}\{fig-alt='' A composite circular rod is
made from two different plastics. A torque is applied at the midpoint.
One end is fixed to the wall. The length of each half of rod is L. The
inner material is material 1 and the outer material is material 2. The
inner radius is 2 cm and the outer radius is 3 cm. ``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="288"}
\NormalTok{T=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{G1=reactive.Value("\_\_")}
\NormalTok{G2=reactive.Value("\_\_")}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of MPa", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A composite circular rod is made from two different plastics. A torque of T = \{T()\} kN{-}m is applied at the midpoint. The right end is free. What is the maximum stress in either material? Assume length L = \{L()\} cm and the shear modulus of the two materials are G\textless{}sub\textgreater{}1\textless{}/sub\textgreater{} = \{G1()\} GPa and G\textless{}sub\textgreater{}2\textless{}/sub\textgreater{} = \{G2()\} GPa.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        T.set(random.randrange(10, 200, 1)/10)}
\NormalTok{        L.set(random.randrange(10, 50, 1))}
\NormalTok{        G1.set(random.randrange(20, 50, 2)/10)}
\NormalTok{        G2.set(G1()/2)}
        
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        J1 = (math.pi/2)*(2/100)**4}
\NormalTok{        J2 = (math.pi/2)*((3{-}2)/100)**4}
\NormalTok{        RHS = G1()*10**9*J1+G2()*10**9*J2}
\NormalTok{        LHS = T()*G2()*10**9*J2}
\NormalTok{        T2 = LHS/RHS}
\NormalTok{        T1 = T(){-}T2}
\NormalTok{        instr= ((T1*(3/100))/J1)/1000}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\chapter*{Problem 6.29}\label{problem-6.29}
\addcontentsline{toc}{chapter}{Problem 6.29}

\markboth{Problem 6.29}{Problem 6.29}

This is a dynamic rendering of the problem with dynamic variables based
on the username entered.

\section*{Problem Image}\label{problem-image-51}
\addcontentsline{toc}{section}{Problem Image}

\markright{Problem Image}

\includegraphics{images/289.png}\{fig-alt='' A composite circular rod is
made from two aluminum and steel. Aluminum is the outer material with a
radius r{[}o{]} and steel is the inner material with radius r{[}i{]}. A
torque is applied at the free end. The length of the rod is L. ``\}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#| standalone: true}
\NormalTok{\#| viewerHeight: 600}
\NormalTok{\#| components: [viewer]}

\NormalTok{from shiny import App, render, ui, reactive}
\NormalTok{import random}
\NormalTok{import asyncio}
\NormalTok{import io}
\NormalTok{import math}
\NormalTok{import string}
\NormalTok{from datetime import datetime}
\NormalTok{from pathlib import Path}

\NormalTok{def generate\_random\_letters(length):}
\NormalTok{    \# Generate a random string of letters of specified length}
\NormalTok{    return \textquotesingle{}\textquotesingle{}.join(random.choice(string.ascii\_lowercase) for \_ in range(length)) }

\NormalTok{problem\_ID="289"}
\NormalTok{T=reactive.Value("\_\_")}
\NormalTok{L=reactive.Value("\_\_")}
\NormalTok{ro=reactive.Value("\_\_")}
\NormalTok{ri=reactive.Value("\_\_")}
\NormalTok{Ga = 3800}
\NormalTok{Gs = 11000}

\NormalTok{attempts=["Timestamp,Attempt,Answer,Feedback\textbackslash{}n"]}

\NormalTok{app\_ui = ui.page\_fluid(}
\NormalTok{    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),}
\NormalTok{    ui.input\_text("ID","", placeholder="Enter ID Number Here"),}
\NormalTok{    ui.input\_action\_button("generate\_problem", "Generate Problem", class\_="btn{-}primary"),}
\NormalTok{    ui.markdown("**Problem Statement**"),}
\NormalTok{    ui.output\_ui("ui\_problem\_statement"),}
\NormalTok{    ui.input\_text("answer","Your Answer in units of ksi", placeholder="Please enter your answer"),}
\NormalTok{    ui.input\_action\_button("submit", "Submit Answer", class\_="btn{-}primary"),}
\NormalTok{    ui.download\_button("download", "Download File to Submit", class\_="btn{-}success"),}
\NormalTok{)}


\NormalTok{def server(input, output, session):}
\NormalTok{    \# Initialize a counter for attempts}
\NormalTok{    attempt\_counter = reactive.Value(0)}

\NormalTok{    @output}
\NormalTok{    @render.ui}
\NormalTok{    def ui\_problem\_statement():}
\NormalTok{        return[ui.markdown(f"A composite circular rod is made from aluminum (Ga = 3,800 ksi) and steel (Gs = 11,000 ksi) as shown. A torque T = \{T()\} lb{-}ft is applied to the free end. What is the maximum stress in either material? Assume length L = \{L()\} in., outer radius r\textless{}sub\textgreater{}o\textless{}/sub\textgreater{} = \{ro()\} in., and inner radius r\textless{}sub\textgreater{}i\textless{}/sub\textgreater{} = \{ri()\} in.")]}
    
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.generate\_problem)}
\NormalTok{    def randomize\_vars():}
\NormalTok{        random.seed(input.ID())}
\NormalTok{        T.set(random.randrange(300, 2000, 100))}
\NormalTok{        L.set(random.randrange(10, 60, 1))}
\NormalTok{        ro.set(random.randrange(10, 60, 1)/10)}
\NormalTok{        ri.set(round(ro()/1.5, 2))}
        
        
\NormalTok{    @reactive.Effect}
\NormalTok{    @reactive.event(input.submit)}
\NormalTok{    def \_():}
\NormalTok{        attempt\_counter.set(attempt\_counter() + 1)  \# Increment the attempt counter on each submission.}
\NormalTok{        Tnew = T()*12}
\NormalTok{        Js = (math.pi/2)*(ro())**4}
\NormalTok{        Ja = (math.pi/2)*(ro(){-}ri())**4}
\NormalTok{        LHS = Ga*Ja+Gs*Js}
\NormalTok{        RHS = Tnew*Ga*Ja}
\NormalTok{        Ta = RHS/LHS}
\NormalTok{        Ts = Tnew{-}Ta}
\NormalTok{        instr= ((Ts*ri()/Js))}
\NormalTok{        if math.isclose(float(input.answer()), instr, rel\_tol=0.001):}
\NormalTok{            check = "*Correct*"}
\NormalTok{            correct\_indicator = "JL"}
\NormalTok{        else:}
\NormalTok{            check = "*Not Correct.*"}
\NormalTok{            correct\_indicator = "JG"}

\NormalTok{        \# Generate random parts for the encoded attempt.}
\NormalTok{        random\_start = generate\_random\_letters(4)}
\NormalTok{        random\_middle = generate\_random\_letters(4)}
\NormalTok{        random\_end = generate\_random\_letters(4)}
\NormalTok{        encoded\_attempt = f"\{random\_start\}\{problem\_ID\}{-}\{random\_middle\}\{attempt\_counter()\}\{correct\_indicator\}{-}\{random\_end\}\{input.ID()\}"}

\NormalTok{        \# Store the most recent encoded attempt in a reactive value so it persists across submissions}
\NormalTok{        session.encoded\_attempt = reactive.Value(encoded\_attempt)}

\NormalTok{        \# Append the attempt data to the attempts list without the encoded attempt}
\NormalTok{        attempts.append(f"\{datetime.now()\}, \{attempt\_counter()\}, \{input.answer()\}, \{check\}\textbackslash{}n")}

\NormalTok{        \# Show feedback to the user.}
\NormalTok{        feedback = ui.markdown(f"Your answer of \{input.answer()\} is \{check\}. For reference in debugging this, the calculated instructor answer is \{instr\}")}
\NormalTok{        m = ui.modal(}
\NormalTok{            feedback,}
\NormalTok{            title="Feedback",}
\NormalTok{            easy\_close=True}
\NormalTok{        )}
\NormalTok{        ui.modal\_show(m)}

\NormalTok{    @session.download(filename=lambda: f"Problem\_Log{-}\{problem\_ID\}{-}\{input.ID()\}.csv")}
\NormalTok{    async def download():}
\NormalTok{        \# Start the CSV with the encoded attempt (without label)}
\NormalTok{        final\_encoded = session.encoded\_attempt() if session.encoded\_attempt is not None else "No attempts"}
\NormalTok{        yield f"\{final\_encoded\}\textbackslash{}n\textbackslash{}n"}
        
\NormalTok{        \# Write the header for the remaining CSV data once}
\NormalTok{        yield "Timestamp,Attempt,Answer,Feedback\textbackslash{}n"}
        
\NormalTok{        \# Write the attempts data, ensure that the header from the attempts list is not written again}
\NormalTok{        for attempt in attempts[1:]:  \# Skip the first element which is the header}
\NormalTok{            await asyncio.sleep(0.25)  \# This delay may not be necessary; adjust as needed}
\NormalTok{            yield attempt}


\NormalTok{\# App installation}
\NormalTok{app = App(app\_ui, server)}
\end{Highlighting}
\end{Shaded}

\bookmarksetup{startatroot}

\chapter{Summary}\label{summary}

In summary, this book has no content whatsoever.

\bookmarksetup{startatroot}

\chapter*{References}\label{references}
\addcontentsline{toc}{chapter}{References}

\markboth{References}{References}

\phantomsection\label{refs}
\begin{CSLReferences}{0}{1}
\end{CSLReferences}



\end{document}
