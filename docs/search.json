[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Problem Set for Strength of Materials",
    "section": "",
    "text": "Welcome to the Problem Set for Strength of Materials",
    "crumbs": [
      "Welcome to the Problem Set for Strength of Materials"
    ]
  },
  {
    "objectID": "index.html#how-to-use-this-resource",
    "href": "index.html#how-to-use-this-resource",
    "title": "Problem Set for Strength of Materials",
    "section": "How to Use This Resource",
    "text": "How to Use This Resource\nNote: This version of the problem set is a review copy for in-class piloting. This is not the final, published version of the problem set.\nThe navigation bar of this site will allow you to browse to the specific problems you want to view and solve. The Problem Submission App enables you to create your own unique problem used to solve homework problems. Once your problem is generated, you will be able to submit an answer to the problem and receive instantaneous right/wrong feedback before attempting another solution. At the end of your work, you can download a file log of your submissions to share with your instructor. The problem generation process is based on the ID number you use and so if you attempt the problem from a different computer or at a different time, the variables generated for you will be stable across these runs. However, the log downloader is specific to your current session and so attempting the problem across devices does not save attempt across devices\nAdditionally, there are versions of the problems with fixed variables that do not use the Problem Submission App. These are available to you also in the sidebar should you want a more traditional textbook listing of problems.\nIf you have any questions or issues while using this system, you are encouraged to contact your instructor and they will help work through the issues with the developers.",
    "crumbs": [
      "Welcome to the Problem Set for Strength of Materials"
    ]
  },
  {
    "objectID": "index.html#copyright-information",
    "href": "index.html#copyright-information",
    "title": "Problem Set for Strength of Materials",
    "section": "Copyright Information",
    "text": "Copyright Information\n©2024. James Lord and Jacob Grohs, eds., Problem Set for Strength of Materials is licensed under a Creative Commons Attribution NonCommercial ShareAlike 4.0 International License, except where otherwise noted. \nYou are free to copy, share, adapt, remix, transform, and build on the material for any purpose as long as you follow the terms of the license: https://creativecommons.org/licenses/by-nc-sa/4.0. \nYou must: \n\nAttribute—You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.\nShareAlike — If you remix, transform, or build upon the material, you must distribute your contributions under the same licenseas the original.\n\nYou may not: \n\nNonCommercial — You may not use the material for commercial purposes.\nAdditional restrictions—You may not add any legal terms or technological measures that legally restrict others from doing anything the license permits.",
    "crumbs": [
      "Welcome to the Problem Set for Strength of Materials"
    ]
  },
  {
    "objectID": "index.html#acknowledgments",
    "href": "index.html#acknowledgments",
    "title": "Problem Set for Strength of Materials",
    "section": "ACKNOWLEDGMENTS",
    "text": "ACKNOWLEDGMENTS\nThe team gratefully acknowledges the generosity of Kurt Gramoll. Many of the problems were adapted from Kurt Gramoll’s collection in the Apple Store and Google Play and released with permission under a CC BY NC SA 4.0 license.\nProblem Set Editor and Content Coordinator\nJames K. Lord, Associate Collegiate Professor, Virginia Tech\nAuthors of Problems\nKurt Gramoll, Emeritus Professor, University of Oklahoma\nJames K. Lord, Mechanical Engineering, Virginia Tech\nChris Galitz, Mechanical Engineering, Virginia Tech\nFrances Davis, Department of Engineering, Brightpoint Community College\nSneha Davison. Mechanical Engineering, Virginia Tech\nRichard Kent, Department of Mechanical & Aerospace Engineering, University of Virginia\nNina Lord, Department of Engineering, North Virginia Community College\nAmy Richardson, Dept of Engineering, North Virginia Community College / Engineering Education, Virginia Tech\nJoao Soares, Department of Mechanical and Nuclear Engineering, Virginia Commonwealth University\nSevak Tahmasian, Mechanical Engineering, Virginia Tech\nFigure Design of Problems\nKindred Grey, Graphic Design and Production Specialist, University Libraries, Virginia Tech\nSoftware Editor\nJacob Grohs, Associate Professor, Engineering Education, Virginia Tech\nReview, Problem Redevelopment, and Programming\nJames K. Lord, Associate Collegiate Professor, Mechanical Engineering, Virginia Tech\nOlivia Ryan, Doctoral Student, Engineering Education, Virginia Tech\nBenjamin E. Chaback, Doctoral Student, Engineering Education, Virginia Tech\nLayout and Design\nKindred Grey, Graphic Design and Production Specialist, University Libraries, Virginia Tech\nProject Coordination and Management\nAnita Walz, Associate Professor, University Libraries, Virginia Tech\nFUNDING\nThis project was made possible in part through funding from an Open Course Grant from VIVA (The Virtual Library of Virginia) and the Open Education Initiative of the University Libraries at Virginia Tech.\nSuggested citation:  James Lord and Jacob Grohs, eds. (2024). Problem Set for Strength of Materials. Blacksburg: Virginia Tech Publishing. https://engineeringmechanicsoer.github.io/StrengthOfMaterialsExercises. Licensed with CC BY NC-SA 4.0 https://creativecommons.org/licenses/by-nc-sa/4.0.\nPublisher: This work is published by the Department of Mechanical Engineering and Department of Engineering Education at Virginia Tech in association with the Open Education Initiative and Virginia Tech Publishing.\nVirginia Tech Department of Mechanical Engineering\n445 Goodwin Hall, 635 Prices Fork Road\nBlacksburg,, VA 24061 USA\nhttps://me.vt.edu \nDepartment of Engineering Education at Virginia Tech\n345 Goodwin Hall, 635 Prices Fork Rd,\n Blacksburg,  VA 24061 USA\nhttps://enge.vt.edu \nOpen Education Initiative\nUniversity Libraries at Virginia Tech \n560 Drillfield Drive Blacksburg, VA 24061 USA \nopeneducation@vt.edu \nVirginia Tech Publishing\nUniversity Libraries at Virginia Tech \n560 Drillfield Drive Blacksburg, VA 24061 USA \nhttps://publishing.vt.edu   |   publishing@vt.edu",
    "crumbs": [
      "Welcome to the Problem Set for Strength of Materials"
    ]
  },
  {
    "objectID": "problem1_1dynamicsubmit.html",
    "href": "problem1_1dynamicsubmit.html",
    "title": "Problem 1.1 - Equilibrium in 2D",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"641\"\nP = reactive.Value(\"__\")\nw = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of kip\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of kip\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"The simply-supported beam is subjected to the loading shown. Determine the support reactions at A and B given P = {P()} kips and w = {w()} kip/ft.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        P.set(random.randrange(5,50,1))\n        w.set(random.randrange(20,100,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        instr1 = 4*w()+P()-(20*w()+12*P())/14\n        instr2 = (20*w()+12*P())/14\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 1 Problems",
      "Problem 1.1 - Equilibrium in 2D"
    ]
  },
  {
    "objectID": "problem1_2dynamicsubmit.html",
    "href": "problem1_2dynamicsubmit.html",
    "title": "Problem 1.2 - Equilibrium in 2D",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"642\"\nP = reactive.Value(\"__\")\nw = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of kN\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of kN-m\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"The cantilever beam is subjected to the loading shown. Determine the reactions at A given P = {P()} kN and w = {w()} kN/m.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        P.set(random.randrange(5,30,1))\n        w.set(random.randrange(20,50,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        instr1 = P()+w()*6.2\n        instr2 = P()*(2.1+6.2+1.5)+w()*6.2*5.2\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 1 Problems",
      "Problem 1.2 - Equilibrium in 2D"
    ]
  },
  {
    "objectID": "problem1_3dynamicsubmit.html",
    "href": "problem1_3dynamicsubmit.html",
    "title": "Problem 1.3 - Equilibrium in 2D",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"643\"\nd = reactive.Value(\"__\")\nw = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of kip\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of kip\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"The simply-supported roof beam AB is subjected to snow loads as a uniform load with snow depth d = {d()} in. A mechanical room on the roof is also covered by snow, and transmits half of the the snow load between points B and C to the roof at point B and the other half at point C. Additionally, there is a snow drift as shown with maximum height, 3*d, above the roof. If the distributed weight of snow is W = {w()} lb/ft per inch of thickness, determine the reactions at supports A and B.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(10,30,1))\n        w.set(random.randrange(40,80,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        w1 = w()*12*d()\n        w2 = w()*21*d()\n        w3 = 0.5*w()*2*d()*12\n        instr1 = (w1+w2+w3-(10.5*w2+17*w3+21*w1/2+33*w1/2)/33)/1000\n        instr2 = ((10.5*w2+17*w3+21*w1/2+33*w1/2)/33)/1000\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 1 Problems",
      "Problem 1.3 - Equilibrium in 2D"
    ]
  },
  {
    "objectID": "problem1_4dynamicsubmit.html",
    "href": "problem1_4dynamicsubmit.html",
    "title": "Problem 1.4 - Internal Reactions",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"644\"\nx1 = reactive.Value(\"__\")\nx2 = reactive.Value(\"__\")\nP = reactive.Value(\"__\")\nw = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Answer3,Answer4,Answer5,Answer6,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of kip\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of kip\", placeholder=\"Please enter your answer 2\"),\n    ui.input_text(\"answer3\", \"Your Answer 3 in units of kip-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_text(\"answer4\", \"Your Answer 4 in units of kip\", placeholder=\"Please enter your answer 2\"),\n    ui.input_text(\"answer5\", \"Your Answer 5 in units of kip\", placeholder=\"Please enter your answer 2\"),\n    ui.input_text(\"answer6\", \"Your Answer 6 in units of kip-ft\", placeholder=\"Please enter your answer 2\"),\n\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"The simply-supported beam is subjected to the loading shown. Determine the internal normal force, N, shear force, V, and bending moment, M, at locations x&lt;sub&gt;1&lt;/sub&gt; = {x1()} ft and x&lt;sub&gt;2&lt;/sub&gt; = {x2()} ft. Assume loads P = {P()} kips and w = {w()} kips/ft. Use appropriate signs in your answers.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        x1.set(random.randrange(41,69,1)/10)\n        x2.set(random.randrange(75,115,1)/10)\n        P.set(random.randrange(5,25,1))\n        w.set(random.randrange(20,50,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        instr1 = 0\n        Ay = (P()*2+w()*4*9)/14\n        instr2 = Ay-w()*(x1()-3)\n        instr3 = w()*(x1()-3)*(3+(x1()-3)/2)+instr2*x1()\n        instr4=0\n        instr5= Ay-w()*4\n        instr6= w()*4*5-instr5*x2()\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        correct3 = math.isclose(float(input.answer3()), instr3, rel_tol=0.01)\n        correct4 = math.isclose(float(input.answer3()), instr4, rel_tol=0.01)\n        correct5 = math.isclose(float(input.answer3()), instr5, rel_tol=0.01)\n        correct6 = math.isclose(float(input.answer3()), instr6, rel_tol=0.01)\n\n        if correct1 and correct2 and correct3 and correct4 and correct5 and correct6:\n            check = \"All answers are correct.\"\n        else:\n            conditions = []\n            for i, correct in enumerate([correct1, correct2, correct3, correct4, correct5, correct6], start=1):\n                if correct:\n                    conditions.append(f\"correct for answer {i}\")\n                else:\n                    conditions.append(f\"incorrect for answer {i}\")\n            check = \"; \".join(conditions) + \".\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 and correct3 and correct4 and correct5 and correct6 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()}, {input.answer2()}, {input.answer3()}, {input.answer4()}, {input.answer5()}, and {input.answer6()}  are {check}. For reference in debugging this, the calculated instructor answers are {instr1}, {instr2}, {instr3}, {instr4}, {instr5}, and {instr6}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 1 Problems",
      "Problem 1.4 - Internal Reactions"
    ]
  },
  {
    "objectID": "problem1_5dynamicsubmit.html",
    "href": "problem1_5dynamicsubmit.html",
    "title": "Problem 1.5 - Internal Reactions",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"645\"\nx = reactive.Value(\"__\")\nF1 = reactive.Value(\"__\")\nF2 = reactive.Value(\"__\")\nF3 = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Answer3,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of kN\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of kN\", placeholder=\"Please enter your answer 2\"),\n    ui.input_text(\"answer3\", \"Your Answer 3 in units of kN-m\", placeholder=\"Please enter your answer 2\"),\n\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"The simply-supported beam is subjected to the loading shown. Determine the internal normal force, N, shear force, V, and bending moment, M, at x = {x()} m. Assume forces F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} kN. Use appropriate signs in your answers.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        x.set(random.randrange(31,89,1)/10)\n        F1.set(random.randrange(5,15,1))\n        F2.set(random.randrange(20,40,1))\n        F3.set(random.randrange(5,15,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        Ax = F1()*math.cos(math.pi/3)-F3()*math.cos(math.pi/3)\n        Ay = (-F1()*math.sin(math.pi/3)*9-F3()*math.sin(math.pi/3)*3+F2()*6)/12\n        instr1 = F1()*math.cos(math.pi/3)\n        instr2 = Ay+F1()*math.sin(math.pi/3)\n        instr3 = -F1()*math.sin(math.pi/3)*3+instr2*x()\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        correct3 = math.isclose(float(input.answer3()), instr3, rel_tol=0.01)\n\n        if correct1 and correct2 and correct3:\n            check = \"All answers are correct.\"\n        else:\n            conditions = []\n            for i, correct in enumerate([correct1, correct2, correct3], start=1):\n                if correct:\n                    conditions.append(f\"correct for answer {i}\")\n                else:\n                    conditions.append(f\"incorrect for answer {i}\")\n            check = \"; \".join(conditions) + \".\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 and correct3 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()}, {input.answer2()}, and {input.answer3()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1}, {instr2}, and {instr3}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 1 Problems",
      "Problem 1.5 - Internal Reactions"
    ]
  },
  {
    "objectID": "problem1_6dynamicsubmit.html",
    "href": "problem1_6dynamicsubmit.html",
    "title": "Problem 1.6 - Internal Reactions",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"646\"\nP = reactive.Value(\"__\")\ntheta = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Answer3,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of lb\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of lb\", placeholder=\"Please enter your answer 2\"),\n    ui.input_text(\"answer3\", \"Your Answer 3 in units of lb-in\", placeholder=\"Please enter your answer 2\"),\n\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A gear shift, once engaged, can be modeled as the bent cantilever beam shown. If a force, P = {P()} lb at angle Θ = {theta()}, was used to engage the shifter, determine the magnitude of the internal normal force, N, shear force, V, and bending moment, M, at point B.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        P.set(random.randrange(20,75,1))\n        theta.set(random.randrange(10,25,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        instr1 = abs(P()*math.cos((70+theta())*math.pi/180))\n        instr2 = abs(P()*math.sin((70+theta())*math.pi/180))\n        instr3 = abs(P()*math.sin((70+theta())*math.pi/180)*(15+14*math.cos(70*math.pi/180))-P()*math.cos((70+theta())*math.pi/180)*14*math.sin(70*math.pi/180))\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        correct3 = math.isclose(float(input.answer3()), instr3, rel_tol=0.01)\n\n        if correct1 and correct2 and correct3:\n            check = \"All answers are correct.\"\n        else:\n            conditions = []\n            for i, correct in enumerate([correct1, correct2, correct3], start=1):\n                if correct:\n                    conditions.append(f\"correct for answer {i}\")\n                else:\n                    conditions.append(f\"incorrect for answer {i}\")\n            check = \"; \".join(conditions) + \".\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 and correct3 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()}, {input.answer2()}, and {input.answer3()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1}, {instr2}, and {instr3}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 1 Problems",
      "Problem 1.6 - Internal Reactions"
    ]
  },
  {
    "objectID": "problem1_7dynamicsubmit.html",
    "href": "problem1_7dynamicsubmit.html",
    "title": "Problem 1.7 - Equilibrium & Rections in 3D",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"647\"\nW = reactive.Value(\"__\")\nP = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Answer3,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of kN\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of kN\", placeholder=\"Please enter your answer 2\"),\n    ui.input_text(\"answer3\", \"Your Answer 3 in units of kN\", placeholder=\"Please enter your answer 2\"),\n\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A 3-wheeled forklift weighing W = {W()} kN centered at G is carrying an imbalanced load, P = {P()} kN, centered at F. determine the reactions at tires A, B, and C.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        P.set(random.randrange(100,200,1)/10)\n        W.set(random.randrange(10,30,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        instr1 = ((0.6*W()+2.8*P())/2+(0.15*P())/0.55)/2\n        instr2 = (0.6*W()+2.8*P())/2-instr1\n        instr3 = P()+W()-instr1-instr2\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        correct3 = math.isclose(float(input.answer3()), instr3, rel_tol=0.01)\n\n        if correct1 and correct2 and correct3:\n            check = \"All answers are correct.\"\n        else:\n            conditions = []\n            for i, correct in enumerate([correct1, correct2, correct3], start=1):\n                if correct:\n                    conditions.append(f\"correct for answer {i}\")\n                else:\n                    conditions.append(f\"incorrect for answer {i}\")\n            check = \"; \".join(conditions) + \".\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 and correct3 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()}, {input.answer2()}, and {input.answer3()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1}, {instr2}, and {instr3}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 1 Problems",
      "Problem 1.7 - Equilibrium & Rections in 3D"
    ]
  },
  {
    "objectID": "problem1_8dynamicsubmit.html",
    "href": "problem1_8dynamicsubmit.html",
    "title": "Problem 1.8 - Equilibrium & Reactions in 3D",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"648\"\nw = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\nweight = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Answer3,Answer4,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of lb\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of lb\", placeholder=\"Please enter your answer 2\"),\n    ui.input_text(\"answer3\", \"Your Answer 3 in units of lb\", placeholder=\"Please enter your answer 2\"),\n    ui.input_text(\"answer4\", \"Your Answer 4 in units of lb\", placeholder=\"Please enter your answer 2\"),\n\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"An awning frame of width w = {w()} ft and length L = {L()} ft is attached to a wall by two anchors and two cables as shown. The awning weighs {weight()} lb. If the cables are installed such that their tensions are all equal, determine the tension, T, and each reaction at the anchors.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(3,10,1))\n        L.set(w()*random.randrange(20,30,1)/10)\n        weight.set(random.randrange(50,100,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        instr1 = 2.5*weight()/(1.106*w())\n        instr2 = -0.3869*instr1\n        Ay = (L()*0.552*instr1-7.5*weight())/(-L())\n        instr3 = weight()-Ay-instr1*(0.552)-instr1*(0.554)\n        Az = (L()*w()/7.238*instr1-0.0921*instr1*w()+w()*0.0461*instr1)/L()\n        instr4 = -Az+instr1*w()/7.238+instr1*w()/7.22\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        correct3 = math.isclose(float(input.answer3()), instr3, rel_tol=0.01)\n        correct4 = math.isclose(float(input.answer4()), instr4, rel_tol=0.01)\n\n\n        if correct1 and correct2 and correct3 and correct4:\n            check = \"All answers are correct.\"\n        else:\n            conditions = []\n            for i, correct in enumerate([correct1, correct2, correct3, correct4], start=1):\n                if correct:\n                    conditions.append(f\"correct for answer {i}\")\n                else:\n                    conditions.append(f\"incorrect for answer {i}\")\n            check = \"; \".join(conditions) + \".\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 and correct3 and correct4 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()}, {input.answer2()}, {input.answer3()}, and {input.answer4()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1}, {instr2}, {instr3} and {instr4}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 1 Problems",
      "Problem 1.8 - Equilibrium & Reactions in 3D"
    ]
  },
  {
    "objectID": "problem1_9dynamicsubmit.html",
    "href": "problem1_9dynamicsubmit.html",
    "title": "Problem 1.9",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"649\"\nw = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\nweight = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Answer3,Answer4,Answer5,Answer6,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of lb\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of lb\", placeholder=\"Please enter your answer 2\"),\n    ui.input_text(\"answer3\", \"Your Answer 3 in units of lb\", placeholder=\"Please enter your answer 3\"),\n    ui.input_text(\"answer4\", \"Your Answer 4 in units of lb\", placeholder=\"Please enter your answer 4\"),\n    ui.input_text(\"answer5\", \"Your Answer 5 in units of lb\", placeholder=\"Please enter your answer 5\"),\n    ui.input_text(\"answer6\", \"Your Answer 6 in units of lb\", placeholder=\"Please enter your answer 6\"),\n\n\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"During engine work, a car's hood of length L = {L()} in. and width w = {w()} in., is propped up by rod AB. Hinges at C and D resist translation in the y- and z-directions but only D resists motion in the x-direction. If the hood weighs {weight()} lb, evenly distributed, determine the compressive force in rod AB and the reactions at C and D.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50,70,1))\n        w.set(L()+random.randrange(10,20,1))\n        weight.set(random.randrange(30,80,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        RDB = [-w()+12, 34.13, 37.9]\n        RDA = [-w()+6, 0, L()-2]\n        RDC = [-w(), 0, 0]\n        RDG = [-w()/2, L()/2*0.6691, L()/2*0.7431]\n        def vector_subtraction(RDB, RDA):\n            return [x - y for x, y in zip(RDB, RDA)]\n        RAB = vector_subtraction(RDB,RDA)\n        def vector_magnitude(RAB):\n            return math.sqrt(sum(x ** 2 for x in RAB))\n        RABmag = vector_magnitude(RAB)\n        FbarAB = [x/RABmag for x in RAB]\n        comp1 = RDB[1]*FbarAB[2]-RDB[2]*FbarAB[1]\n        comp2 = RDB[2]*FbarAB[0]-RDB[0]*FbarAB[2]\n        comp3 = RDB[0]*FbarAB[1]-RDB[1]*FbarAB[0]\n        FABCross = [comp1, comp2, comp3]\n        Weightj = [0, -weight(), 0]\n        comp4 = RDG[1]*Weightj[2]-RDG[2]*Weightj[1]\n        comp5 = RDG[2]*Weightj[0]-RDG[0]*Weightj[2]\n        comp6 = RDG[0]*Weightj[1]-RDG[1]*Weightj[0]\n        RDGCross = [comp4, comp5, comp6]\n        instr1 = comp4/comp1\n        Cract = [0,1,1]\n        comp7 = RDC[1]*Cract[2]-RDC[2]*Cract[1]\n        comp8 = RDC[2]*Cract[0]-RDC[0]*Cract[2]\n        comp9 = RDC[0]*Cract[1]-RDC[1]*Cract[0]\n        RDCCross = [comp7, comp8, comp9]\n        instr2 = comp2*instr1/comp8\n        instr3 = (comp3*instr1-comp6)/comp9\n        instr4 = -FbarAB[0]*instr1\n        instr5 = -FbarAB[1]*instr1+weight()-instr3\n        instr6 = -FbarAB[2]-instr2 \n  \n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        correct3 = math.isclose(float(input.answer3()), instr3, rel_tol=0.01)\n        correct4 = math.isclose(float(input.answer4()), instr4, rel_tol=0.01)\n        correct5 = math.isclose(float(input.answer5()), instr5, rel_tol=0.01)\n        correct6 = math.isclose(float(input.answer6()), instr6, rel_tol=0.01)\n\n        if correct1 and correct2 and correct3 and correct4 and correct5 and correct6:\n            check = \"All answers are correct.\"\n        else:\n            conditions = []\n            for i, correct in enumerate([correct1, correct2, correct3, correct4, correct5, correct6], start=1):\n                if correct:\n                    conditions.append(f\"correct for answer {i}\")\n                else:\n                    conditions.append(f\"incorrect for answer {i}\")\n            check = \"; \".join(conditions) + \".\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 and correct3 and correct4 and correct5 and correct6 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()}, {input.answer2()}, {input.answer3()}, {input.answer4()}, {input.answer5()}, and {input.answer6()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1}, {instr2}, {instr3}, {instr4}, {instr5} and {instr6}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Answer3,Answer4,Answer5,Answer6,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 1 Problems",
      "Problem 1.9"
    ]
  },
  {
    "objectID": "problem2_1dynamicsubmit.html",
    "href": "problem2_1dynamicsubmit.html",
    "title": "Problem 2.1 - Average Normal Stress",
    "section": "",
    "text": "Figure 1: A series of solid circular bars are loaded with three loads\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"138\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\nd1=8\nd2=6\nd3=10\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n    \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A series of solid circular bars are loaded with three loads as shown, F&lt;sub&gt;1&lt;/sub&gt; = {F1()} N, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} N, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} N. What is the largest absolute normal stress, 𝜎, in any bar?\")]\n     \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(50, 70, 1))\n        F2.set(random.randrange(10, 30, 1))\n        F3.set(F1()-F2())\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        \n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        instr= (F1()/(math.pi*(d2/(1000*2))**2))/10**6\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.1 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_2dynamicsubmit.html",
    "href": "problem2_2dynamicsubmit.html",
    "title": "Problem 2.2 - Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"139\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nFA=reactive.Value(\"__\")\nFB=reactive.Value(\"__\")\nE = 30*10**6\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two cylinders are stacked on top of one another and two forces are applied at the top surface and at the joint between the cylinders as shown. If L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in., L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in., F&lt;sub&gt;A&lt;/sub&gt; = {FA()} lb, and F&lt;sub&gt;B&lt;/sub&gt; = {FB()} lb, determine the average normal stress in cylinder B. Enter a positive answer for tensile stress or a negative answer for compressive stress. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        FA.set(random.randrange(300, 700, 10))\n        FB.set(random.randrange(100, 300, 10))\n        L1.set(random.randrange(2, 7, 1))\n        L2.set(round(L1() * 1.3,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        instr = -(FA()+FB())/(math.pi*1.5**2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.2 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_3dynamicsubmit.html",
    "href": "problem2_3dynamicsubmit.html",
    "title": "Problem 2.3 - Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"144\"\nF=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A plastic cylindrical peg is constrained by a metal cap as shown. An axial load of F = {F()} lb is applied to the peg. If d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in and d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in, determine the largest normal stress in the peg. Assume the axial load is evenly distributed across the peg and that the metal cap is fixed and does not move.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(20, 80, 5))\n        d1.set(random.randrange(3, 8, 1)/10)\n        d2.set(round(d1() * 1.6, 2))\n        \n \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= F()/(math.pi*((d1()/2)**2))\n        #check=math.isclose(float(input.answer()),instr,rel_tol=0.001)\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.3 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_4dynamicsubmit.html",
    "href": "problem2_4dynamicsubmit.html",
    "title": "Problem 2.4 - Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"146\"\nW=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nangle1=math.radians(45)\nangle2=math.radians(30)\nangle3=math.radians(75)\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A crate weighing {W()} kN is suspended by a set of cables. The diameter of each cable is {d()}  mm. What is the maximum stress in any cable, that is the highest average normal stress, excluding the cable attached to the crate.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W.set(random.randrange(30, 90, 1))\n        d.set(random.randrange(20, 60, 1))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        R1 = W()/(((math.cos(angle1)/math.cos(angle2))*math.sin(angle2))+math.sin(angle1))\n        instr = (R1*10**3/(math.pi*((d()/(1000*2))**2)))/10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.4 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_5dynamicsubmit.html",
    "href": "problem2_5dynamicsubmit.html",
    "title": "Problem 2.5 - Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"141\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two circular rods are attached and loaded with forces F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN as shown. If diameters d&lt;sub&gt;1&lt;/sub&gt; = {d1()} mm and d&lt;sub&gt;2&lt;/sub&gt; = {d2()} mm, determine the magnitude of the largest normal stress in either rod.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(10, 50, 1))\n        F2.set(random.randrange(10, 50, 1))\n        d1.set(random.randrange(10, 40, 1))\n        d2.set(d1()*random.randrange(12, 14, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sa = abs((F2()-F1())/((d1()/2000)**2*math.pi)/1000)\n        sb = abs(F2()/((d2()/2000)**2*math.pi)/1000)\n        if sa&gt;sb:\n            instr = sa\n        else:\n            instr=sb\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.5 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_6dynamicsubmit.html",
    "href": "problem2_6dynamicsubmit.html",
    "title": "Problem 2.6 - Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"142\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A truss is subjected to loads F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kips, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kips, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} kips as shown. All members of the truss have the same circular cross-section shown. Determine the magnitude of the normal stress in member DF.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(10, 100, 1)/10)\n        F2.set(random.randrange(10, 100, 1)/10)\n        F3.set(random.randrange(10, 100, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Hy = (8*F3()+5*F2()+2*F1())/10\n        FDF = (-Hy*5+F3()*3)/2\n        A = math.pi*(1**2-0.75**2)\n        instr = abs(FDF/A)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.6 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_7dynamicsubmit.html",
    "href": "problem2_7dynamicsubmit.html",
    "title": "Problem 2.7 - Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"143\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nd0=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A tapered cylindrical rod is pulled by a force F = {F()} N. If length L = {L()} m, diameter d&lt;sub&gt;0&lt;/sub&gt; = {d0()} mm and diameter d&lt;sub&gt;1&lt;/sub&gt; = {d1()} mm, determine the average normal stress on the circular cross-section  at x = {x()} m from the wall.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(200, 1000, 10))\n        L.set(random.randrange(10, 100, 1)/10)\n        d0.set(random.randrange(300, 700, 10))\n        d1.set(d0()/2)\n        x.set(L()*random.randrange(2, 4, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        d = d0()/10-(x()/L())*(d0()/10-d1()/10)\n        instr = F()/((d/2)**2*math.pi)*10\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.7 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_8dynamicsubmit.html",
    "href": "problem2_8dynamicsubmit.html",
    "title": "Problem 2.8 - Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"149\"\nA=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A truss is constructed using solid square members of area A = {A()} mm&lt;sup&gt;2&lt;/sup&gt;. If load F = {F()} kN and length L = {L()} m, determine the stress in member EF. Recall that, by convention, compressive stresses are negative.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        A.set(random.randrange(500, 1500, 10))\n        F.set(random.randrange(20, 75, 1))\n        L.set(random.randrange(5, 10, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Fx = (2*F()*L()+F()*3*L())/(3*L())\n        FEF = -Fx*2.236\n        instr = FEF/A()*10**3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.8 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_9dynamicsubmit.html",
    "href": "problem2_9dynamicsubmit.html",
    "title": "Problem 2.9 - Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"150\"\nA=reactive.Value(\"__\")\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A truss is constructed using members of area A = {A()} in&lt;sup&gt;2&lt;/sup&gt;. If loads F&lt;sub&gt;1&lt;/sub&gt; = {F1()} lb and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} lb, determine the stress in member EG.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        A.set(random.randrange(20, 100, 1)/10)\n        F1.set(random.randrange(300, 1000, 10))\n        F2.set(random.randrange(300, 1000, 10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        FEG = (F1()*12+F2()*24)/4.615\n        instr = FEG/A()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.9 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_10dynamicsubmit.html",
    "href": "problem2_10dynamicsubmit.html",
    "title": "Problem 2.10 - Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"152\"\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A truss is constructed of members with rectangular cross-sections of base b = {b()} in. and height h = {h()} in. If loads F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kips and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kips, determine the normal stress in member EF. Recall that, by convention, compressive stresses are negative.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b.set(random.randrange(10, 50, 1)/10)\n        h.set(b()*2)\n        F1.set(random.randrange(10, 100, 1)/10)\n        F2.set(random.randrange(10, 100, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        FD = (6*F2()+3*F1())/9\n        FEF = -FD*3/(3*math.sin(63.43*math.pi/180))\n        instr = FEF/(b()*h())*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.10 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_11dynamicsubmit.html",
    "href": "problem2_11dynamicsubmit.html",
    "title": "Problem 2.11 -Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"154\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A truss is constructed of members with the circular cross-section shown. If loads F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kips, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kips, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} kips, determine the normal stress in member EC.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(10, 100, 1)/10)\n        F2.set(random.randrange(10, 100, 1)/10)\n        F3.set(random.randrange(10, 100, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Hy = (F3()*8+F2()*4-F1()*4)/16\n        FEC = (F3()-Hy)/math.cos(45*math.pi/180)\n        instr = FEC/1.374\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.11 -Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_12dynamicsubmit.html",
    "href": "problem2_12dynamicsubmit.html",
    "title": "Problem 2.12 -Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"155\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\nF4=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A series of solid circular bars are connected together as shown. If loads F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN, F&lt;sub&gt;3&lt;/sub&gt; = {F3()} kN, and F&lt;sub&gt;4&lt;/sub&gt; = {F4()} kN, determine the average normal stress at section a. Recall that, by convention, compressive stresses are negative.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(50, 200, 1)/10)\n        F2.set(random.randrange(50, 200, 1)/10)\n        F3.set(random.randrange(50, 140, 1)/10)\n        F4.set(random.randrange(50, 200, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        F = F1()+F2()-F3()+F4()\n        instr = F/227*10**4\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.12 -Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_13dynamicsubmit.html",
    "href": "problem2_13dynamicsubmit.html",
    "title": "Problem 2.13 - Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"158\"\nF=reactive.Value(\"__\")\ntheta=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is held in place by a rope that loops over a pulley as shown. If load F = {F()} kN and angle Θ = {theta()}°, determine the average normal stress in the rope if it has diameter d = {d()} mm.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(10, 100, 1))\n        theta.set(random.randrange(33, 55, 1))\n        d.set(random.randrange(15, 30, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Fr = F()*1.5/(2+math.sin(theta()*math.pi/180))*1000\n        r = d()/2000\n        A = math.pi*r**2\n        instr = Fr/A/10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.13 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_14dynamicsubmit.html",
    "href": "problem2_14dynamicsubmit.html",
    "title": "Problem 2.14 - Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"159\"\nw=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cable supports a beam with a uniform distributed load w = {w()} kN/m as shown. The cable has diameter d = {d()} mm and the beam length L = {L()} m. Determine the average normal stress in the cable.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10,50,1))\n        d.set(random.randrange(15,30,1))\n        L.set(random.randrange(10,30,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        theta = math.atan(1/L())\n        Fc = (w()*L()*L()/2)/(L()*math.sin(theta))\n        instr = Fc/(math.pi*(d()/2000)**2)/10**3\n\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.14 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_15dynamicsubmit.html",
    "href": "problem2_15dynamicsubmit.html",
    "title": "Problem 2.15 - Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"160\"\nW=reactive.Value(\"__\")\ndAC=reactive.Value(\"__\")\ndBC=reactive.Value(\"__\")\nalpha=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of degrees\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A box weighing W = {W()} lb is suspended by two cables as shown. Cable AC has diameter d&lt;sub&gt;AC&lt;/sub&gt; = {dAC()} in. and cable BC has diameter d&lt;sub&gt;BC&lt;/sub&gt; = {dBC()} in. If angle α = {alpha()}°, what angle Θ is required so that both cables experience the same average normal stress?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W.set(random.randrange(300,1500,10))\n        dBC.set(random.randrange(10,50,1)/10)\n        dAC.set(dBC()+random.randrange(10,20,1)/10)\n        alpha.set(random.randrange(50,60,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        AAC = (dAC()/2)**2*math.pi\n        ACB = (dBC()/2)**2*math.pi\n        ratio = ACB/AAC\n        instr = math.acos(ratio*math.cos(alpha()*math.pi/180))*180/math.pi\n\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.15 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_16dynamicsubmit.html",
    "href": "problem2_16dynamicsubmit.html",
    "title": "Problem 2.16 - Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"162\"\nF1 = reactive.Value(\"__\")\nF2 = reactive.Value(\"__\")\nd1 = reactive.Value(\"__\")\nd2 = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\n        \"**Please enter your ID number from your instructor and click to generate your problem**\"\n    ),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\n        \"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"\n    ),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\n        \"answer\", \"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"\n    ),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"Two forces, F&lt;sub&gt;1&lt;/sub&gt; = {F1()} KN and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN are applied to the cylinders as shown. If diameters d&lt;sub&gt;1&lt;/sub&gt; = {d1()} mm and d&lt;sub&gt;2&lt;/sub&gt; = {d2()} mm, determine the largest axial stress in either cylinder.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(10, 50, 1))\n        F2.set(F1() + random.randrange(10, 50, 1))\n        d1.set(random.randrange(15, 30, 1))\n        d2.set(d1() * 1.5)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        FB = F2() - F1()\n        sigmaB = FB / ((d1() / 2) ** 2 * math.pi) * 10**3\n        FA = F2()\n        sigmaA = FA / ((d2() / 2) ** 2 * math.pi) * 10**3\n        if sigmaB &gt;= sigmaA:\n            instr = sigmaB\n        else:\n            instr = sigmaA\n\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(\n            f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\"\n        )\n\n        # Show feedback to the user.\n        feedback = ui.markdown(\n            f\"Your answer of {input.answer()} is {check}.\"\n        )\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = (\n            session.encoded_attempt()\n            if session.encoded_attempt is not None\n            else \"No attempts\"\n        )\n        yield f\"{final_encoded}\\n\\n\"\n\n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n\n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(\n                0.25\n            )  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.16 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_17dynamicsubmit.html",
    "href": "problem2_17dynamicsubmit.html",
    "title": "Problem 2.17 - Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"163\"\nw0 = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\nAA = reactive.Value(\"__\")\nAB = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\n        \"**Please enter your ID number from your instructor and click to generate your problem**\"\n    ),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\n        \"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"\n    ),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\n        \"answer\", \"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"\n    ),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A beam structure supported by a tube at each end is loaded with a distributed load as shown, where w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kip/ft and length L = {L()} ft. If tube A has cross-sectional area A&lt;sub&gt;A&lt;/sub&gt; = {AA()} in.&lt;sup&gt;2&lt;/sup&gt; and tube B has area A&lt;sub&gt;b&lt;/sub&gt; = {AB()} in.&lt;sup&gt;2&lt;/sup&gt;, determine the largest average normal stress in either tube.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w0.set(random.randrange(20,100,1)/10)\n        L.set(random.randrange(6,15,3))\n        AA.set(random.randrange(20,40,1)/10)\n        AB.set(random.randrange(50,70,1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        FB = w0()*L()*0.5*2/3\n        FA = w0()*L()*0.5-FB\n        sigmaA = FA/AA()\n        sigmaB = FB/AB()\n        if sigmaA &gt;= sigmaB:\n            instr = sigmaA\n        else:\n            instr = sigmaB\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(\n            f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\"\n        )\n\n        # Show feedback to the user.\n        feedback = ui.markdown(\n            f\"Your answer of {input.answer()} is {check}.\"\n        )\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = (\n            session.encoded_attempt()\n            if session.encoded_attempt is not None\n            else \"No attempts\"\n        )\n        yield f\"{final_encoded}\\n\\n\"\n\n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n\n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(\n                0.25\n            )  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.17 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_21dynamicsubmit.html",
    "href": "problem2_21dynamicsubmit.html",
    "title": "Problem 2.21 - Average Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"164\"\nτfail=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kips\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A double lap joint is glued together using glue with a shear stress failure strength of {τfail()} psi. If dimensions L = {L()} in. and t = {t()} in., what is the maximum load P that the joint can withstand? Assume the load is evenly distributed across the joint on both sides.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        τfail.set(random.randrange(7000, 9000, 100))\n        L.set(random.randrange(40, 100, 1)/10)\n        t.set(random.randrange(40, 100, 1)/10)\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        A = L()*t()*2\n        instr= (τfail()*A)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.21 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_22dynamicsubmit.html",
    "href": "problem2_22dynamicsubmit.html",
    "title": "Problem 2.22 - Average Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"165\"\nF=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A bracket is attached to a wall with two circular rivets of diameter d = {d()} mm. A load F = {F()} kN is applied in the center of the bracket. Assuming the load is split evenly between the two rivits, determine the shear stress in each rivet. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(30, 100, 1))\n        d.set(random.randrange(10, 40, 1))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.  \n      \n        A = math.pi*(d()/(1000*2))**2\n        instr= ((F()/2)/A)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.22 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_23dynamicsubmit.html",
    "href": "problem2_23dynamicsubmit.html",
    "title": "Problem 2.23 - Average Shear Stress",
    "section": "",
    "text": "Figure 1: A square bar of length is pinned at one end and rests on a circular rod.\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"168\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A square bar of length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in. is pinned at one end and rests on a circular rod of diameter d = {d()} in. A force F = {F()} lb is applied at the free end. What is the average shear stress in the circular rod? \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(50, 150, 1)/10)\n        L2.set(round(L1() * 1.4, 1))\n        d.set(random.randrange(4, 9, 1)/10)\n        F.set(random.randrange(30, 100, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        M = F()*(L1()+L2())\n        R = M/L1()\n        A = math.pi*(d()/2)**2\n        instr= R/(2*A)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.23 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_24dynamicsubmit.html",
    "href": "problem2_24dynamicsubmit.html",
    "title": "Problem 2.24 - Average Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"170\"\nd = reactive.Value(\"__\")\ntau_fail = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\n        \"**Please enter your ID number from your instructor and click to generate your problem**\"\n    ),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\n        \"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"\n    ),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\n        \"answer\", \"Your Answer in units of kN\", placeholder=\"Please enter your answer\"\n    ),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A double lap joint is held together with two steel bolts. Each bolt has a diameter d = {d()} mm. If the bolts fail in shear at {tau_fail()} MPa, determine the largest permissable load, P.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(10,30,1))\n        tau_fail.set(random.randrange(200,300,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        instr = tau_fail()*2*2*((d()/2)**2*math.pi)/10**3\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(\n            f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\"\n        )\n\n        # Show feedback to the user.\n        feedback = ui.markdown(\n            f\"Your answer of {input.answer()} is {check}.\"\n        )\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = (\n            session.encoded_attempt()\n            if session.encoded_attempt is not None\n            else \"No attempts\"\n        )\n        yield f\"{final_encoded}\\n\\n\"\n\n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n\n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(\n                0.25\n            )  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.24 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_25dynamicsubmit.html",
    "href": "problem2_25dynamicsubmit.html",
    "title": "Problem 2.25 - Average Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"173\"\nL = reactive.Value(\"__\")\nw = reactive.Value(\"__\")\nF = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\n        \"**Please enter your ID number from your instructor and click to generate your problem**\"\n    ),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\n        \"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"\n    ),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\n        \"answer\", \"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"\n    ),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A lap joint is constructed with layers as shown. If dimensions L = {L()} mm and w = {w()} mm, determine the maximum shear stress at any surface. Assume load F = {F()} kN is evenly distributed across the joint on any surface.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10, 50, 1))\n        w.set(round(L() * 1.6,1))\n        F.set(random.randrange(5, 75, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        A = w()/1000*L()/1000*4\n        instr = F()*1000/A/10**6\n\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.25 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_26dynamicsubmit.html",
    "href": "problem2_26dynamicsubmit.html",
    "title": "Problem 2.26 - Average Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"174\"\nw = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\nt = reactive.Value(\"__\")\ntau_fail = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\n        \"**Please enter your ID number from your instructor and click to generate your problem**\"\n    ),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\n        \"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"\n    ),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\n        \"answer\", \"Your Answer in units of kip\", placeholder=\"Please enter your answer\"\n    ),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A rectangular hole punch is configured to punch a hole of L = {L()} in. by w = {w()} in. through a metal plate of thickness t = {t()} in. If the failure shear stress for the plate is {tau_fail()} ksi, what force F is needed to punch the hole?\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(20,60,1)/10)\n        L.set(round(w()*2,1))\n        t.set(random.randrange(10,75,1)/100)\n        tau_fail.set(random.randrange(5,40,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        A = (2*L()+2*w())*t()\n        instr = tau_fail()*A\n\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.26 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_27dynamicsubmit.html",
    "href": "problem2_27dynamicsubmit.html",
    "title": "Problem 2.27 - Average Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"175\"\ntheta = reactive.Value(\"__\")\nd = reactive.Value(\"__\")\nw0 = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\n        \"**Please enter your ID number from your instructor and click to generate your problem**\"\n    ),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\n        \"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"\n    ),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\n        \"answer\", \"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"\n    ),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"One side of a beam rests on a sloping wall at angle Θ = {theta()}°. The other end is bolted to a wall with a bolt of diameter d = {d()} mm. If load w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kN/m and length L = {L()} m, determine the shear stres in the bolt.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        theta.set(random.randrange(55,65,1))\n        d.set(random.randrange(10,30,1))\n        w0.set(random.randrange(5,20,1))\n        L.set(random.randrange(10,50,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        By = w0()*L()/2/3\n        Ay = w0()*L()/2-By\n        Ax = Ay*math.tan(theta()*math.pi/180)\n        Bx = Ax\n        Babs = (By**2+Bx**2)**0.5\n        P = Babs/2\n        instr = P/((d()/2)**2*math.pi)*10**3\n\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.27 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_28dynamicsubmit.html",
    "href": "problem2_28dynamicsubmit.html",
    "title": "Problem 2.28 - Average Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \nproblem_ID=\"177\"\nd=reactive.Value(\"__\")\na=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two structural members are connected with a pin of diameter d = {d()} in. as shown. If dimension a = {a()} ft, b = {b()} ft, adn load F = {F()} kips, determine the shear stress in the pin.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(20,100,5)/100)\n        a.set(random.randrange(10,50,1)/10)\n        b.set(round(a(),1)*round(random.randrange(12,17,1)/10))\n        F.set(random.randrange(10,100,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        FB = F()/2\n        instr = FB/((d()/2)**2*math.pi)        \n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.28 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_29dynamicsubmit.html",
    "href": "problem2_29dynamicsubmit.html",
    "title": "Problem 2.29 - Average Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \nproblem_ID=\"178\"\nd=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\ntau_fail=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kips\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A circular hole punch is configured to punch a hold of diameter d = {d()} in. through a metal plate of thickness t = {t()} in. If the failure shear stress for the metal plate is {tau_fail()} ksi, determine the force F needed to punch the hole.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(25,95,5)/100)\n        t.set(random.randrange(3,15,1)/10)\n        tau_fail.set(random.randrange(20,40,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        A = t()*d()*math.pi\n        instr = tau_fail()*A        \n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.29 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_30dynamicsubmit.html",
    "href": "problem2_30dynamicsubmit.html",
    "title": "Problem 2.30 - Average Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"179\"\nd=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A bolt of diameter d = {d()} mm is used at a pin support in a structure. If the structure is subjected to load F = {F()} kN, determine the shear stress in the bolt.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(20,50,1))\n        F.set(random.randrange(50,150,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        V = F()/2\n        A = math.pi*(d()/2)**2\n        instr = V/(A)*10**3\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.30 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_31dynamicsubmit.html",
    "href": "problem2_31dynamicsubmit.html",
    "title": "Problem 2.31 - Average Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \nproblem_ID=\"181\"\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A plastic cylindrical peg is constrained by a metal cap as shown. Assume dimensions d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in., d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in., and L = {L()} in. Determine the shear stress in the peg when a load F = {F()} kips is applied.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d1.set(random.randrange(2,10,1)/10)\n        d2.set(round(d1(),2)*round(random.randrange(12,18,1)/10))\n        L.set(random.randrange(5,15,1)/10)\n        F.set(random.randrange(10,50,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        A = d1()*math.pi*L()\n        instr = F()/A\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.31 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_32dynamicsubmit.html",
    "href": "problem2_32dynamicsubmit.html",
    "title": "Problem 2.32 - Average Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"182\"\nW=reactive.Value(\"__\")\ntau_fail=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A plaque weighing W = {W()} lb is hung from a rafter by a single nail. The failure shear stress of the nail is {tau_fail()} ksi. Determine the minimum required diameter of the nail.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W.set(random.randrange(50,150,1))\n        tau_fail.set(random.randrange(20,40,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr = (4*W()/(math.pi*tau_fail()*1000))**0.5\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.32 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_33dynamicsubmit.html",
    "href": "problem2_33dynamicsubmit.html",
    "title": "Problem 2.33 - Average Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"167\"\nL = reactive.Value(\"__\")\nw = reactive.Value(\"__\")\ntau_glue = reactive.Value(\"__\")\nd = reactive.Value(\"__\")\ntau_bolt = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\n        \"**Please enter your ID number from your instructor and click to generate your problem**\"\n    ),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\n        \"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"\n    ),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\n        \"answer\", \"Your Answer in units of lb\", placeholder=\"Please enter your answer\"\n    ),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"Three bars of length L = {L()} in. and width w = {w()} in. are attached to each other and a wall. One joint is connected with glue that has a failure shear stress of {tau_glue()} psi. The other joint is connected with a bolt of diameter d = {d()} in. that has a failure shear stress of {tau_bolt()} ksi. Determine the minimum load P at which one joint will fail.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(4,10,1))\n        w.set(random.randrange(10,30,1)/10)\n        tau_glue.set(random.randrange(500,1000,10))\n        d.set(random.randrange(3,8,1)/10)\n        tau_bolt.set(random.randrange(50,150,1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        Pg = tau_glue()*w()*.25*L()\n        Pb = tau_bolt()*1000*((d()/2)**2*math.pi)\n        if Pg &gt;= Pb:\n            instr = Pb\n        else:\n            instr = Pg\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(\n            f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\"\n        )\n\n        # Show feedback to the user.\n        feedback = ui.markdown(\n            f\"Your answer of {input.answer()} is {check}.\"\n        )\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = (\n            session.encoded_attempt()\n            if session.encoded_attempt is not None\n            else \"No attempts\"\n        )\n        yield f\"{final_encoded}\\n\\n\"\n\n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n\n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(\n                0.25\n            )  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.33 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_38dynamicsubmit.html",
    "href": "problem2_38dynamicsubmit.html",
    "title": "Problem 2.38 - Bearing Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"166\"\nW=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n    \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A crate of weight {W()} = lb hangs from a solid circular metal rod of diameter {d1()} = in.. The cable is wrapped around a support collar of diameter {d2()} = in. and thickness {t()} = in. to evenly distribute the cable load. What is the bearing stress on the support collar due to the rod? \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W.set(random.randrange(4000, 9000, 100))\n        d1.set(random.randrange(5, 30, 1)/10)\n        d2.set(d1()*3)\n        t.set(d1()*2)\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        \n        instr= W()/(d1()*t()*1000)\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.38 - Bearing Stress"
    ]
  },
  {
    "objectID": "problem2_39dynamicsubmit.html",
    "href": "problem2_39dynamicsubmit.html",
    "title": "Problem 2.39 - Bearing Stress",
    "section": "",
    "text": "Figure 1: A link mechanism is connected with pins.\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"180\"\nF=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\n\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)  \n  \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A link mechanism is connected with pins of diameter d = {d()} in. A force F = {F()} lb is applied to the mechanism as shown. The mechanism has width w = {w()} in. and thickness t = {t()} in. What is the bearing stress in member BC at joint B due to the pin at B? \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(200, 900, 10))\n        d.set(random.randrange(20, 150, 10)/100)\n        t.set(random.randrange(2, 10, 1)/10)\n        w.set(round(d()*2, 2))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Fb=((18+8)*F())/18\n        instr= Fb/(d()*t())/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.39 - Bearing Stress"
    ]
  },
  {
    "objectID": "problem2_40dynamicsubmit.html",
    "href": "problem2_40dynamicsubmit.html",
    "title": "Problem 2.40 - Bearing Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"161\"\nW=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A crate weighing W = {W()} kips is supported by the structure as shown. The dimensions shown at point D are h = {h()} in., t = {t()} in., and pin diameter d = {d()} in. Determine the bearing stress at joint D due to the pin on member DC.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W.set(random.randrange(5,100,1))\n        t.set(random.randrange(25, 75, 1)/100)\n        d.set(t()*4)\n        h.set(d()*2)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        theta = 29.05*math.pi/180\n        FDC = W()/math.sin(theta)\n        instr= FDC/(d()*t())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.40 - Bearing Stress"
    ]
  },
  {
    "objectID": "problem2_41dynamicsubmit.html",
    "href": "problem2_41dynamicsubmit.html",
    "title": "Problem 2.41 - Bearing Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"169\"\nd=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kips\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A steel connector plate is hung from a brass rod of diameter d = {d()} in. The plate has dimensions t = {t()} in. and w = {w()} in. Considering only bearing stress, find the minimum load (P) that will cause the connector or rod to fail. Assume the failure bearing stress for brass is 70 ksi and for steel is 75 ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(8, 20, 1)/10)\n        t.set(random.randrange(3, 7, 1)/10)\n        w.set((d()*2))        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= 70*t()*d()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.41 - Bearing Stress"
    ]
  },
  {
    "objectID": "problem2_42dynamicsubmit.html",
    "href": "problem2_42dynamicsubmit.html",
    "title": "Problem 2.42 - Bearing Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"172\"\na = reactive.Value(\"__\")\nb = reactive.Value(\"__\")\nF = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\n        \"**Please enter your ID number from your instructor and click to generate your problem**\"\n    ),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\n        \"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"\n    ),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\n        \"answer\", \"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"\n    ),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A hanger is mounted to a wall with a rectangular bar as shown. Let dimension a = {a()} mm and b = {b()} mm. Determine the largest stress in either the hanger or the bar holding it to the wall. Assume load F = {F()} kN. Consider the normal stress in both components, the shear stress in both components, and the bearing stress between the components.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        a.set(random.randrange(100,300,2)/10)\n        b.set(round(a()*1.2,1))\n        F.set(random.randrange(10,70,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        sigmaN = F()/2/(b()*a())*10**3\n        sigmaBH = F()/(a()*a())*10**3\n        tauH = F()/2/(a()*a())*10**3\n        tauR = F()/(a()*b())*10**3\n        instr = max(sigmaN, sigmaBH, tauH, tauR)\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(\n            f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\"\n        )\n\n        # Show feedback to the user.\n        feedback = ui.markdown(\n            f\"Your answer of {input.answer()} is {check}.\"\n        )\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = (\n            session.encoded_attempt()\n            if session.encoded_attempt is not None\n            else \"No attempts\"\n        )\n        yield f\"{final_encoded}\\n\\n\"\n\n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n\n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(\n                0.25\n            )  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.42 - Bearing Stress"
    ]
  },
  {
    "objectID": "problem2_43dynamicsubmit.html",
    "href": "problem2_43dynamicsubmit.html",
    "title": "Problem 2.43 - Bearing Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"176\"\nsigma_s = reactive.Value(\"__\")\nsigma_b = reactive.Value(\"__\")\nF = reactive.Value(\"__\")\na = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of in\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of in\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A metal end cap is secured to a wood structural member with grooves as shown. The failure shear and bearing stresses for the wood are τ&lt;sub&gt;s&lt;/sub&gt; = {sigma_s()} ksi and σ&lt;sub&gt;b&lt;/sub&gt; = {sigma_b()} ksi respectively. If load F = {F()} kips and dimension a = {a()} in., determine the dimensions, d and b, required for the wood not to fail.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_s.set(random.randrange(20,50,1)/10)\n        sigma_b.set(sigma_s()*2)\n        F.set(random.randrange(15,40,1))\n        a.set(random.randrange(50,100,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        P = F()/2\n        Ab = P/sigma_b()\n        instr1 = Ab/a()\n        As = P/sigma_s()\n        instr2 = As/a()\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.43 - Bearing Stress"
    ]
  },
  {
    "objectID": "problem2_47dynamicsubmit.html",
    "href": "problem2_47dynamicsubmit.html",
    "title": "Problem 2.47 - Stress on an Inclined Plane",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"153\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nΘ=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two slanted brackets are glued together as shown. If F = {F()} lb, L = {L()} in., and Θ = {Θ()} °, determine the shear stress parallel to the inclined plane. Assume loads are inline and there is no rotation.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(200, 800, 10))\n        L.set(random.randrange(20, 80, 1)/10)\n        Θ.set(random.randrange(15, 30, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        instr= (F()*math.cos(math.radians(Θ()))/(L()*2))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.47 - Stress on an Inclined Plane"
    ]
  },
  {
    "objectID": "problem2_48dynamicsubmit.html",
    "href": "problem2_48dynamicsubmit.html",
    "title": "Problem 2.48 - Stress on an Inclined Plane",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"156\"\nF=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nΘ=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A 2 inch thick board is cut and then glued back together along a line that is Θ = {Θ()} ° off the vertical as shown. If height h = {h()} in. and F = {F()} lb, determine the normal stress along the cut line.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(2000, 6000, 100))\n        h.set(random.randrange(50, 150, 1)/10)\n        Θ.set(random.randrange(10, 20, 1))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        \n        instr= (F()/(2*h()))*(math.cos(math.radians(Θ()))**2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.48 - Stress on an Inclined Plane"
    ]
  },
  {
    "objectID": "problem3_1dynamicsubmit.html",
    "href": "problem3_1dynamicsubmit.html",
    "title": "Problem 3.1 - Normal Strain",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"196\"\npercent=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A rubber cylinder experiences a {percent()}% reduction in length ofter being exposed to a force F = {F()} lb. The cylinder has length L = {L()} in. after the load is applied. Determine the strain in the cylinder.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        percent.set(random.randrange(10,25,1))\n        F.set(random.randrange(20,100,1))\n        L.set(random.randrange(10,100,1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Lo = L()/(1-percent()/100)\n        instr = (Lo-L())/Lo\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 3 Problems",
      "Problem 3.1 - Normal Strain"
    ]
  },
  {
    "objectID": "problem3_2dynamicsubmit.html",
    "href": "problem3_2dynamicsubmit.html",
    "title": "Problem 3.2 - Normal Strain",
    "section": "",
    "text": "Figure 1: A rectangular prism is subjected to a tension test.\n\n\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"650\"\nL=reactive.Value(\"__\")\nLp=reactive.Value(\"__\")\n\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm/mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"During a tension test of a rectangular prism, the original gage length L = {L()} mm is increased to L' = {Lp()} mm. determine the normal strain, ε, in the prism.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(100, 400, 1))\n        Lp.set(L()+random.randrange(100, 300, 1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (Lp()-L())/L()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 3 Problems",
      "Problem 3.2 - Normal Strain"
    ]
  },
  {
    "objectID": "problem3_3dynamicsubmit.html",
    "href": "problem3_3dynamicsubmit.html",
    "title": "Problem 3.3 - Normal Strain",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"139\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nFA=reactive.Value(\"__\")\nFB=reactive.Value(\"__\")\nE = 30*10**6\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two cylinders are stacked on top of one another and two forces are applied at the top surface and at the joint between the cylinders as shown. If L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in., L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in., F&lt;sub&gt;A&lt;/sub&gt; = {FA()} lb, and F&lt;sub&gt;B&lt;/sub&gt; = {FB()} lb, find the total deflection in the stack of cylinders. Assume E = 30 x 10&lt;sup&gt;6&lt;/sup&gt; psi for both cylinders. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        FA.set(random.randrange(300, 700, 10))\n        FB.set(random.randrange(100, 300, 10))\n        L1.set(random.randrange(2, 7, 1))\n        L2.set(L1() * 1.3)\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        instr= (FA()*L1())/((math.pi*(5/2)**2)*E) + (FB()*L2())/((math.pi*(3/2)**2)*E)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 3 Problems",
      "Problem 3.3 - Normal Strain"
    ]
  },
  {
    "objectID": "problem3_7dynamicsubmit.html",
    "href": "problem3_7dynamicsubmit.html",
    "title": "Problem 3.7 - Shear Strain",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"652\"\nL=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\n\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of radians\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A square plate is deformed due to shear with the new shape shown. If length L = {L()} mm and x = {x()} mm, determine the shear strain at corner A.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(200, 500, 10))\n        x.set(random.randrange(20, 50, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= math.atan(x()/L())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 3 Problems",
      "Problem 3.7 - Shear Strain"
    ]
  },
  {
    "objectID": "problem3_8dynamicsubmit.html",
    "href": "problem3_8dynamicsubmit.html",
    "title": "Problem 3.8 - Shear Strain",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"653\"\nh=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of radians\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A rectangular plate of dimensions L = {L()} in. and h = {h()} in. is deformed to the new shape shown. Determine the shear strain at corner C.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        h.set(random.randrange(50,100,1)/10)\n        L.set(h()+random.randrange(50,100,1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        alpha2 = math.atan(0.227/(L()-0.071+0.084))\n        alpha3 = math.atan(0.206/(h()+0.32-0.37))\n        instr = alpha2-alpha3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 3 Problems",
      "Problem 3.8 - Shear Strain"
    ]
  },
  {
    "objectID": "problem3_9dynamicsubmit.html",
    "href": "problem3_9dynamicsubmit.html",
    "title": "Problem 3.9 - Shear Strain",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"654\"\nt=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of radians\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two plates are connected by a neoprense pad of thickness t = {t()} mm that is bonded to each plate. The top plate shifts to the right by x = {x()} mm. It is observed that the edge of the pad forms symmetric circular arcs rather than a straight line. Determine the maximum strain in the neoprene.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        t.set(random.randrange(10,30,1))\n        x.set(random.randrange(10,30,1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        y = (t()**2/4-x()**2/4)/x()\n        r = y+x()/2\n        theta = math.acos(x()/r)\n        instr = math.pi/2-theta\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 3 Problems",
      "Problem 3.9 - Shear Strain"
    ]
  },
  {
    "objectID": "problem3_10dynamicsubmit.html",
    "href": "problem3_10dynamicsubmit.html",
    "title": "Problem 3.10 - Shear Strain",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"655\"\nL=reactive.Value(\"__\")\nstrain=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A triangular plate of side length L = {L()} mm is subjected to a shear strain of {strain()} radians. Determine the distance that corner B displaces.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(100,800,10))\n        strain.set(random.randrange(2,20,1)/100)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        ang = math.pi/3-2/3*strain()\n        NewHor = 2*L()*math.sin(math.pi/3)/math.tan(ang)\n        instr = NewHor-L()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 3 Problems",
      "Problem 3.10 - Shear Strain"
    ]
  },
  {
    "objectID": "problem4_2dynamicsubmit.html",
    "href": "problem4_2dynamicsubmit.html",
    "title": "Problem 4.2 - Stress/Strain Diagram",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"656\"\nL=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The stress-strain diagram for a steel specimen is shown. A rectangular prism tension member of cross-sectional area A = 900 mm&lt;sup&gt;2&lt;/sup&gt; and initial length L = {L()} mm is subjected to load P = {P()} kN. Determine the change in length of the member.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(500,2000,10))\n        P.set(random.randrange(180,675,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigma=P()/900*1000\n        e = sigma/200000\n        instr = L()*e\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.2 - Stress/Strain Diagram"
    ]
  },
  {
    "objectID": "problem4_5dynamicsubmit.html",
    "href": "problem4_5dynamicsubmit.html",
    "title": "Problem 4.5 - Hooke’s Law",
    "section": "",
    "text": "Figure 1: A single force pulls on three cylindrical rods that are fixed to a wall.\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"188\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nEsteel = 29000\nEaluminum = 10000\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches/inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A single force F = {F()} kips pulls on three cylindrical rods, each of length L = {L()} in. The aluminum rods have a diameter d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in., and the steel rods have a diameter d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in. What is the strain in the steel cylinder? Assume E&lt;sub&gt;steel&lt;/sub&gt; = 29,000 ksi and E&lt;sub&gt;aluminum&lt;/sub&gt; = 10,000 ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(20, 300, 1)/10)\n        L.set(random.randrange(50, 200, 1)/10)\n        d1.set(random.randrange(10, 50, 1)/10)\n        d2.set(round(d1()/2, 2))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr=(F()/(((d2()/2)**2)*math.pi))/Esteel\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.5 - Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_6dynamicsubmit.html",
    "href": "problem4_6dynamicsubmit.html",
    "title": "Problem 4.6 - Hooke’s Law",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"194\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\ndL=reactive.Value(\"__\")\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A polymer test specimen is subjected to an axial load of F = {F()} kips. The central portion of the specimen has an initial length L = {L()} in., w = {w()} in., and t = {t()} in. If the length increases by dL = {dL()} in., determine the elastic modulus of the material. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(100, 500, 1)/10)\n        L.set(random.randrange(50, 150, 1)/10)\n        w.set(round(L()*0.375, 2))\n        t.set(random.randrange(10, 50, 1)/100)\n        dL.set(random.randrange(3, 9, 1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (F()*L())/(dL()*(w()*t()))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.6 - Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_7dynamicsubmit.html",
    "href": "problem4_7dynamicsubmit.html",
    "title": "Problem 4.7 - Hooke’s Law",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"657\"\nd=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\nelong=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A round bar of diameter d = {d()} in. and length L = {L()} in. is subjected to axial load P = {P()} lb. If the elongation of the bar is {elong()} in., and assuming elastic behavior, determine the elastic modulus of the bar.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(3,15,1)/10)\n        L.set(random.randrange(100,200,1)/10)\n        P.set(random.randrange(750,1500,10))\n        elong.set(random.randrange(50,200,1)/1000)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        A = math.pi*(d()**2)/4\n        sigma = P()/A\n        epsilon = elong()/L()\n        instr= sigma/epsilon/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.7 - Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_10dynamicsubmit.html",
    "href": "problem4_10dynamicsubmit.html",
    "title": "Problem 4.10 - Poisson’s Ratio",
    "section": "",
    "text": "Figure 1: A circular road is placed in tension with an axial load.\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"206\"\nP=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A circular rod of an unknown metallic alloy is placed in tension with a P = {P()} kip axial load. The length of the rod is L = {L()} in. and the diameter is d = {d()} in. After applying the load, the rod length increases by 0.0035 in and the diameter decreases by 0.00014 in. What is the Poisson's ratio of the alloy?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        P.set(random.randrange(20, 200, 1)/10)\n        L.set(random.randrange(10, 20, 1))\n        E.set(random.randrange(20, 40, 1)/100)\n        d.set(round((.00014*L())/(.0035*E()), 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n       \n        instr= -(-.00014/d())/(.0035/L())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.10 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_11dynamicsubmit.html",
    "href": "problem4_11dynamicsubmit.html",
    "title": "Problem 4.11 - Poisson’s Ratio",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"213\"\nr1=reactive.Value(\"__\")\nr2=reactive.Value(\"__\")\nE=15000\nv=0.33\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"An aluminum circular rod of radius r&lt;sub&gt;1&lt;/sub&gt; = {r1()} in is inserted into space that is slightly wider than the rod, where r&lt;sub&gt;2&lt;/sub&gt; = {r2()} in. What load P is needed so that the rod expands and fills the space in the radial direction? Assume E = 15,000 ksi and v = 0.33. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        r1.set(random.randrange(10, 50, 1)/10)\n        r2.set((r1() + random.randrange(1, 10, 1)/1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Ex = (r1() - r2())/r1()\n        sigmay = (Ex*E)/(-v)\n        instr= sigmay*math.pi*r1()**2\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.11 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_12dynamicsubmit.html",
    "href": "problem4_12dynamicsubmit.html",
    "title": "Problem 4.12 - Poisson’s Ratio",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"216\"\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A rectangular bar is pulled in tension by a load P in the x-direction. The bar deflects by δ&lt;sub&gt;1&lt;/sub&gt; = {d1()} in and δ&lt;sub&gt;2&lt;/sub&gt; = - {d2()} in, in the x- and y-direction, respectively. The length in the x-direction is 5 in, and the length in the y direction is 1 in. What is the Poisson's ratio of the material? The z-direction deflection is not known. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d1.set(random.randrange(20, 50, 1)/1000)\n        d2.set(random.randrange(10, 20, 1)/10000)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= -(-d2()/1)/(d1()/5)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.12 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_17dynamicsubmit.html",
    "href": "problem4_17dynamicsubmit.html",
    "title": "Problem 4.17 - Shear Stress/Strain",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"218\"\nF2=reactive.Value(\"__\")\nF1=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Force F&lt;sub&gt;1&lt;/sub&gt; = {F1()} lb and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} lb are aoolied to a rubber block of length L = {L()} in. as shown. The depth of the block is {d()} in. Determine the shear strain in the block, assuming ν = 0.49 and E = 500 psi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F2.set(random.randrange(10,50,1))\n        F1.set(F2()+random.randrange(5,20,1))\n        L.set(random.randrange(30,60,1))\n        d.set(random.randrange(30,60,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        tau = (F1()+F2())/(L()*d())\n        G = 500/(2*(1+0.49))\n        instr = tau/G\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.17 - Shear Stress/Strain"
    ]
  },
  {
    "objectID": "problem4_18dynamicsubmit.html",
    "href": "problem4_18dynamicsubmit.html",
    "title": "Problem 4.18 - Thermal Strain",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"658\"\nL=reactive.Value(\"__\")\nTi=reactive.Value(\"__\")\nTf=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of m/m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A copper pipe (α = 17x10&lt;sup&gt;-6&lt;/sup&gt; /°C) of length L = {L()} m is cooled from {Ti()}°C to to {Tf()}°C. Determine the longitudinal strain in the cooled pipe.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50, 100, 1)/10)\n        Ti.set(random.randrange(30, 50, 1))\n        Tf.set(Ti()-random.randrange(10, 25, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= 17*10**-6*(Tf()-Ti())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.18 - Thermal Strain"
    ]
  },
  {
    "objectID": "problem4_19dynamicsubmit.html",
    "href": "problem4_19dynamicsubmit.html",
    "title": "Problem 4.19 - Thermal Strain",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"659\"\nL=reactive.Value(\"__\")\nTi=reactive.Value(\"__\")\nTf=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in.\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Upon plant startup, a steel steam pipe (α = 6.5 x 10&lt;sup&gt;-6&lt;/sup&gt; /°F) of length L = {L()} ft is raised in temperature from an ambiant temperature of {Ti()}°F to {Tf()}°F. Determine the change in length of the pipe.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50, 200, 5))\n        Ti.set(random.randrange(50, 75, 1))\n        Tf.set(random.randrange(300, 500, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= 6.5*10**-6*(Tf()-Ti())*L()*12\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.19 - Thermal Strain"
    ]
  },
  {
    "objectID": "problem4_20dynamicsubmit.html",
    "href": "problem4_20dynamicsubmit.html",
    "title": "Problem 4.20 - Thermal Strain",
    "section": "",
    "text": "{fig-alt=“Picture with a coin made of a nickel outter core and a copper inner core. The nickel is a ring with a outer diameter of 30 mm and an inner diameter of 15.2 mm. The copper is circular with a diameter of 15.23 mm.} [Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"660\"\nTi=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of \\u00b0C\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A coin is to be made with a nickel outer ring and a copper (α = 17 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C) core. The dimensions are shown at an initial temperature of {Ti()}°C. If the copper is to be cooled to fit inside the nickel, determine the required temperature of the copper.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        Ti.set(random.randrange(10,20,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= Ti()-115.87\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.20 - Thermal Strain"
    ]
  },
  {
    "objectID": "problem4_21dynamicsubmit.html",
    "href": "problem4_21dynamicsubmit.html",
    "title": "Problem 4.21 - Thermal Strain",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"661\"\nL=reactive.Value(\"__\")\nTi=reactive.Value(\"__\")\nTf=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A gymnasium roof of length L = {L()} ft is supported by open-web steel bar joists. They are installed at an ambient temperature of {Ti()}°F. On a hot summer day, the roof temperature reaches {Tf()}°F. Determine the change in length of the joists. Assume α = 6.5 x 10&lt;sup&gt;-6&lt;/sup&gt; /°F.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50,100,1))\n        Ti.set(random.randrange(30,50,1))\n        Tf.set(random.randrange(100,150,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr=6.5*10**-6*(Tf()-Ti())*L()*12\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.21 - Thermal Strain"
    ]
  },
  {
    "objectID": "problem4_23dynamicsubmit.html",
    "href": "problem4_23dynamicsubmit.html",
    "title": "Problem 4.23 - Multiaxial Hooke’s Law",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"204\"\nL=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nFx=reactive.Value(\"__\")\nFy=reactive.Value(\"__\")\nE=29000\nv=0.29\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A square steel plate of side length L = {L()} in. and thickness t = {t()} in. is uniformly pulled by two forces F&lt;sub&gt;x&lt;/sub&gt; = {Fx()} kips and F&lt;sub&gt;y&lt;/sub&gt; = {Fy()} kips as shown. If E = 29,000 ksi and Poisson's ratio v = 0.29, determine the change in thickness of the plate. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50, 150, 1)/10)\n        t.set(random.randrange(2, 10, 1)/10)\n        Fx.set(random.randrange(100, 500, 1)/10)\n        Fy.set(random.randrange(100, 500, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigmax = Fx()/(L()*t())\n        sigmay = Fy()/(L()*t())\n        instr= t()*(-v/E)*(sigmax+sigmay)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.23 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_24dynamicsubmit.html",
    "href": "problem4_24dynamicsubmit.html",
    "title": "Problem 4.24 - Multiaxial Hooke’s Law",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"205\"\nP1=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\nv=reactive.Value(\"__\")\nSG=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in percent\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A strain gauge is placed on a polymer test sample with an elastic modulus E =  {E()} x 10&lt;sup&gt;6&lt;/sup&gt; psi and a Poisson's ratio of v = {v()}. When a P&lt;sub&gt;1&lt;/sub&gt; = {P1()} kip vertical load is applied to the test sample, the strain gauge reads a strain of ε = {SG()} x 10&lt;sup&gt;-6&lt;/sup&gt; in the x-direction. What is the relative error of the strain gauge compared to the theoretical strain of the test sample? Note: relative error is defined to be the difference between the measured value and the theoretical value divided by the theoretical value.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        P1.set(random.randrange(20, 200, 1)/10)\n        E.set(random.randrange(5, 20, 1))\n        v.set(random.randrange(20, 40, 1)/100)\n        SG.set(round((v()*P1()*1000)/(12*E()),1)-(random.randrange(3, 20, 1)/10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigmaz = (-P1()*1000)/(4*3)\n        Ex = ((-v()*(sigmaz))/(E()*10**6))\n        instr=  ((Ex - SG()*10**-6)/Ex)*100\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.24 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_25dynamicsubmit.html",
    "href": "problem4_25dynamicsubmit.html",
    "title": "Problem 4.25 - Multiaxial Hooke’s Law",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"208\"\nPx=reactive.Value(\"__\")\nPy=reactive.Value(\"__\")\nPz=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\nv=reactive.Value(\"__\")\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in percent\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A block is pulled in all three directions (P&lt;sub&gt;x&lt;/sub&gt; = {Px()} kN, P&lt;sub&gt;y&lt;/sub&gt; = {Py()} kN, P&lt;sub&gt;z&lt;/sub&gt; = {Pz()} kN). What is the percent change in volume after all three loads are applied? Assume E = {E()} MPa and v = {v()}. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        Px.set(random.randrange(1, 20, 1))\n        Py.set(random.randrange(1, 20, 1))\n        Pz.set(random.randrange(1, 20, 1))\n        E.set(random.randrange(1000, 2000, 100))\n        v.set(random.randrange(20, 40, 1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigmax = (Px()/(5*2))*10\n        sigmay = (Py()/(6*2))*10\n        sigmaz = (Pz()/(5*6))*10\n        Ex = (sigmax - v()*(sigmay+sigmaz))/(E())\n        Ey = (sigmay - v()*(sigmaz+sigmax))/(E())\n        Ez = (sigmaz - v()*(sigmax+sigmay))/(E())\n        Lx = 6 + 6*Ex\n        Ly = 5 + 5*Ey\n        Lz = 2 + 2*Ez\n        instr= (((Lx*Ly*Lz)-60)/60)*100\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.25 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_26dynamicsubmit.html",
    "href": "problem4_26dynamicsubmit.html",
    "title": "Problem 4.26 - Multiaxial Hooke’s Law",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"209\"\nsigma_x=reactive.Value(\"__\")\nsigma_y=reactive.Value(\"__\")\ne_x=reactive.Value(\"__\")\ne_y=reactive.Value(\"__\")\nplaceholder = reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Pressure loading is applied to a plate in both the x and y directions, and the strains are recorded using strain gages. If stresses σ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} ksi, σ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} ksi, and strains ε&lt;sub&gt;x&lt;/sub&gt; = {e_x()} µ and ε&lt;sub&gt;y&lt;/sub&gt; = {e_y()} µ, calculate Poisson's ratio for the material.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(5, 20, 1))\n        sigma_y.set(random.randrange(5, 20, 1))\n        e_x.set(random.randrange(2100, 2500, 10))\n        placeholder.set(random.randrange(15,40,1)/100)\n        e_y.set(round(e_x()*(sigma_y()-placeholder()*sigma_x())/(sigma_x()+placeholder()*-sigma_y())))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        \n        instr= -(sigma_x()/e_x()+sigma_y()/-e_y())/(-sigma_y()/e_x()-sigma_x()/-e_y())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.26 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_27dynamicsubmit.html",
    "href": "problem4_27dynamicsubmit.html",
    "title": "Problem 4.27 - Multiaxial Hooke’s Law",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"210\"\nx=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\nv=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A rigid block is subjected to uniform hydrostatic pressure, σ, on all surfaces. It is noted that the block contracts in the x-direction by {x()} x 10&lt;sup&gt;-3&lt;/sup&gt; cm when the pressure is applied. If E = {E()} GPa and ν = {v()}, determine the magnitude of the applied pressure.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        x.set(random.randrange(15,100,1)/10)\n        E.set(random.randrange(75,150,1))\n        v.set(random.randrange(20,40,1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        instr= x()/30*E()/(1-2*v())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.27 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_28dynamicsubmit.html",
    "href": "problem4_28dynamicsubmit.html",
    "title": "Problem 4.28 - Multiaxial Hooke’s Law",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"211\"\nFx=reactive.Value(\"__\")\nFy=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\nv=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\\u00B3\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A rectangular block is pulled in two directions. Determine the total change in volume. Assume force F&lt;sub&gt;x&lt;/sub&gt; = {Fx()} kips, force F&lt;sub&gt;y&lt;/sub&gt; = {Fy()} kips, E = {E()} x 10&lt;sup&gt;6&lt;/sup&gt; psi, and ν = {v()}.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        Fx.set(random.randrange(50,200,1)/10)\n        Fy.set(random.randrange(50,200,1)/10)\n        E.set(random.randrange(75,150,1)/10)\n        v.set(random.randrange(20,40,1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigmax = Fx()/4\n        sigmay=Fy()/5\n        strainx = (sigmax-v()*sigmay)/(E()*1000)\n        strainy = (sigmay-v()*sigmax)/(E()*1000)\n        strainz = (-v()*(sigmax+sigmay))/(E()*1000)\n        LxN = 10+10*strainx\n        LyN = 8+8*strainy\n        LzN = 0.5+0.5*strainz\n        VN = LxN*LyN*LzN\n        Vo = 10*8*0.5\n        instr= VN-Vo\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.28 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_29dynamicsubmit.html",
    "href": "problem4_29dynamicsubmit.html",
    "title": "Problem 4.29 - Multiaxial Hooke’s Law",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"211\"\nFx=reactive.Value(\"__\")\nFy=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\nv=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\\u00B3\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A rectangular block is pulled in two directions. Determine the total change in volume. Assume force F&lt;sub&gt;x&lt;/sub&gt; = {Fx()} kips, force F&lt;sub&gt;y&lt;/sub&gt; = {Fy()} kips, E = {E()} x 10&lt;sup&gt;6&lt;/sup&gt; psi, and ν = {v()}.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        Fx.set(random.randrange(50,200,1)/10)\n        Fy.set(random.randrange(50,200,1)/10)\n        E.set(random.randrange(75,150,1)/10)\n        v.set(random.randrange(20,40,1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigmax = Fx()/4\n        sigmay=Fy()/5\n        strainx = (sigmax-v()*sigmay)/(E()*1000)\n        strainy = (sigmay-v()*sigmax)/(E()*1000)\n        strainz = (-v()*(sigmax+sigmay))/(E()*1000)\n        LxN = 10+10*strainx\n        LyN = 8+8*strainy\n        LzN = 0.5+0.5*strainz\n        VN = LxN*LyN*LzN\n        Vo = 10*8*0.5\n        instr= VN-Vo\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.29 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_30dynamicsubmit.html",
    "href": "problem4_30dynamicsubmit.html",
    "title": "Problem 4.30 - Multiaxial Hooke’s Law",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"215\"\nL=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\nv=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A bar of length L = {L()} mm is subjected to a pressure P = {P()} kPa on the two long dimensions (not the ends) as shown. Assuming E = {E()} kPa and ν = {v()}, determine the change in length of the L = {L()} mm side.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(250,750,10))\n        P.set(random.randrange(1,10,1)/10)\n        E.set(random.randrange(400,900))\n        v.set(random.randrange(30,45,1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        strainz = (v()*2*P())/E()\n        instr= L*strainz\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.30 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_31dynamicsubmit.html",
    "href": "problem4_31dynamicsubmit.html",
    "title": "Problem 4.31 - Multiaxial Hooke’s Law",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"217\"\nFx=reactive.Value(\"__\")\nFy=reactive.Value(\"__\")\nFz=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A small brass sample is subjected to loads on each of its three surfaces, where F&lt;sub&gt;x&lt;/sub&gt; = {Fx()} kips, F&lt;sub&gt;y&lt;/sub&gt; = {Fy()} kips, and F&lt;sub&gt;z&lt;/sub&gt; = {Fz()} kips. Assuming E = 15 x 10&lt;sup&gt;6&lt;/sup&gt; psi and ν = 0.34, determine the total change in length in the z-direction. Note a minus sign if the length decreases.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        Fx.set(random.randrange(50,200,1)/10)\n        Fy.set(random.randrange(50,200,1)/10)\n        Fz.set(random.randrange(50,200,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigmax = Fx()/3\n        sigmay = Fy()/2\n        sigmaz = Fz()/6\n        instr = (-sigmaz-0.34*(sigmax+sigmay))/(15*10**3)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.31 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_35dynamicsubmit.html",
    "href": "problem4_35dynamicsubmit.html",
    "title": "Problem 4.35 - Allowable Stress/Safety Factor",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"157\"\nF=reactive.Value(\"__\")\nFS=reactive.Value(\"__\")\nσfail=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of centimeters\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A small truss is constructed with solid square wood members and subjected to a load of F = {F()} kN. Determine the minimum dimension, a, of the member so that the truss will have a factor of safety of {FS()}. All members have the same cross-section. The wood has a failure stress of σ&lt;sub&gt;fail&lt;/sub&gt; = {σfail()} MPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(15, 50, 1))\n        FS.set(random.randrange(15, 40, 1)/10)\n        σfail.set(random.randrange(40, 60, 1))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        dl = FS()*F()\n        A = (dl/(σfail()*10**3))*100*100\n        instr= math.sqrt(A)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.35 - Allowable Stress/Safety Factor"
    ]
  },
  {
    "objectID": "problem5_1dynamicsubmit.html",
    "href": "problem5_1dynamicsubmit.html",
    "title": "Problem 5.1 - Axial Stress",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"662\"\nL=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A W18 x 50 structural steel column of length L = {L()} ft is subjected to a compressive axial load P = {P()} kips. Determine the magnitude of the average normal stress at the base of the column, including self-weight.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10,25,1))\n        P.set(random.randrange(10,100,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Weight=(50*L())/1000\n        LoadTot=P()+Weight\n        instr=LoadTot/14.7\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.1 - Axial Stress"
    ]
  },
  {
    "objectID": "problem5_2dynamicsubmit.html",
    "href": "problem5_2dynamicsubmit.html",
    "title": "Problem 5.2 - Axial Stress",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"663\"\ncap=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nsigmay=reactive.Value(\"__\")\nFS=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A chain hoist with a labeled capacity of {cap()} kN tavels along the middle 2/3 of a beam of length L = {L()} m that is bolted to a ceiling with two bolts at each end. Each bolt has a yield strength, σ&lt;sub&gt;y&lt;/sub&gt; = {sigmay()} MPa. Determine the minimum required bolt diameter using a factor of safety of {FS()}.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        cap.set(random.randrange(50,150,5))\n        L.set(random.randrange(5,20,1))\n        sigmay.set(random.randrange(400,700,10))\n        FS.set(random.randrange(15,30,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Fbolt=cap()*5/6/2\n        Fdes=Fbolt*FS()\n        Amin=Fdes/(sigmay()/1000)\n        instr=math.sqrt(4*Amin/math.pi)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.2 - Axial Stress"
    ]
  },
  {
    "objectID": "problem5_6dynamicsubmit.html",
    "href": "problem5_6dynamicsubmit.html",
    "title": "Problem 5.6 - Stress Concentrations",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"664\"\nt=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A flat bar of thickness t = {t()} mm contains a hole as shown. The bar is subjected to a tensile load P = {P()} kN. Determine the maximum tensile stress in the bar.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        t.set(random.randrange(10, 25, 1))\n        P.set(random.randrange(10, 100, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigma_norm = P()/(t()*(43-22))*1000\n        instr= 2.15*(sigma_norm)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.1):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.6 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_7dynamicsubmit.html",
    "href": "problem5_7dynamicsubmit.html",
    "title": "Problem 5.7 - Stress Concentrations",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"665\"\nt=reactive.Value(\"__\")\nsigmay=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of lb\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A flat bar of thickness t = {t()} in. contains a hole as shown. If the material has a maximum allowable stress of {sigmay()} ksi, determine the maximum load P that can be applied.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        t.set(random.randrange(10,50,1)/100)\n        sigmay.set(random.randrange(20,30,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr=sigmay()*t()*0.35/2.14*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.7 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_8dynamicsubmit.html",
    "href": "problem5_8dynamicsubmit.html",
    "title": "Problem 5.8 - Stress Concentrations",
    "section": "",
    "text": "Figure 1: A bar narrows in width.\n\n\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"666\"\nt=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A flat bar of thickness t = {t()} in. narrows with fillets as shown. If a load P = {P()} lb is applied, determine the maximum stress in the bar.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        t.set(random.randrange(10, 100, 5)/100)\n        P.set(random.randrange(1000, 5000, 100))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigma_norm = P()/(t()*(1.5))\n        instr= 1.95*(sigma_norm)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.1):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.8 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_9dynamicsubmit.html",
    "href": "problem5_9dynamicsubmit.html",
    "title": "Problem 5.9 - Stress Concentrations",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"667\"\nt=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A dogbone specimen of thickness t = {t()} mm is being prepared for a tension test. If load P = {P()} kN, determine the maximum stress in the sample.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        t.set(random.randrange(70,200,1)/10)\n        P.set(random.randrange(20,50,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        A = 0.05*t()\n        sigmaavg=P()/A\n        instr= sigmaavg*1.59\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.9 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_10dynamicsubmit.html",
    "href": "problem5_10dynamicsubmit.html",
    "title": "Problem 5.10 - Stress Concentrations",
    "section": "",
    "text": "Figure 1: A linkage is subjected to a loading as shown.\n\n\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"668\"\nt=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The linkage of thickness t = {t()} in. shown is subjected to load P = {P()} kips. Determine the maximum stress in the linkage.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        t.set(random.randrange(25, 75, 5)/100)\n        P.set(random.randrange(20,45,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigma1 = 1.82*P()/(2*t())\n        sigma2 = 2.28*P()/(2.5*t())\n        instr = max(sigma1,sigma2)\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.1):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n            \n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.10 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_11dynamicsubmit.html",
    "href": "problem5_11dynamicsubmit.html",
    "title": "Problem 5.11 - Axial Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\nproblem_ID=\"183\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\nF4=reactive.Value(\"__\")\nE=210\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A series of solid, steel, circular bars are loaded with forces as shown, where F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN, F&lt;sub&gt;3&lt;/sub&gt; = {F3()} kN, and F&lt;sub&gt;4&lt;/sub&gt; = {F4()} kN. What is the total change in length of the system? Assume E = 210 GPa for steel.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(10, 100, 1)/10)\n        F2.set(random.randrange(10, 100, 1)/10)\n        F3.set(random.randrange(10, 100, 1)/10)\n        F4.set(random.randrange(10, 100, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= ((F1()*3)/(E*math.pi*0.5**2)+((F1()+F2())*3)/(E*math.pi*1**2)+((F1()+F2()+F3())*4)/(E*math.pi*0.25**2)+((F1()+F2()+F3()+F4())*2)/(E*math.pi*0.5**2))/10\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.11 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_12dynamicsubmit.html",
    "href": "problem5_12dynamicsubmit.html",
    "title": "Problem 5.12 - Axial Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"184\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nL3=reactive.Value(\"__\")\nEsteel = 210\nEaluminum = 70\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of micrometers\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two forces, F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN, are applied to the system of cylinders as shown. If L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m, L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m, and L&lt;sub&gt;3&lt;/sub&gt; = {L3()} m, what is the total change in length of the system? Assume E&lt;sub&gt;steel&lt;/sub&gt; = {Esteel} GPa and E&lt;sub&gt;aluminum&lt;/sub&gt; = {Ealuminum} GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(100, 300, 1)/10)\n        F2.set(round(F1()/1.5, 2))\n        L1.set(random.randrange(20, 80, 1)/10)\n        L2.set(round(L1()*0.6, 2))\n        L3.set(round(L1()*0.8, 2))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n       \n        instr= ((F2()*10**3*L2())/(math.pi*0.3**2*Esteel*10**9) + ((F2()-F1())*1000*L1())/(math.pi*0.5**2*Ealuminum*10**9))*1000000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.12 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_13dynamicsubmit.html",
    "href": "problem5_13dynamicsubmit.html",
    "title": "Problem 5.13 - Axial Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"185\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nEbrass = 100\nEaluminum = 70\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two forces, F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN, are applied to the system of cylinders as shown. If L&lt;sub&gt;1&lt;/sub&gt; = {L1()} mm and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} mm, what is the total change in length of the system. Assume E&lt;sub&gt;brass&lt;/sub&gt; = {Ebrass} GPa and E&lt;sub&gt;aluminum&lt;/sub&gt; = {Ealuminum} GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(10, 100, 1)/10)\n        F2.set(round(F1()*2, 2))\n        L1.set(random.randrange(50, 150, 1))\n        L2.set(round(L1()*1.5))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (((F2()-F1())*L1())/(math.pi*.002**2*Ebrass*10**6)) + (F2()*L2())/(math.pi*.003**2*Ealuminum*10**6)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.13 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_14dynamicsubmit.html",
    "href": "problem5_14dynamicsubmit.html",
    "title": "Problem 5.14 - Axial Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"186\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nL3=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A series of solid circular steel bars are loaded as shown, where F&lt;sub&gt;1&lt;/sub&gt; = {F1()} N, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} N, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} N. If lengths L&lt;sub&gt;1&lt;/sub&gt; = L&lt;sub&gt;2&lt;/sub&gt; = {L1()} cm and L&lt;sub&gt;3&lt;/sub&gt; = {L3()} cm, determine the total change in length of the system. Assume E&lt;sub&gt;steel&lt;/sub&gt; = 210 GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(20, 100, 1))\n        F2.set(random.randrange(20, 100, 1))\n        F3.set(random.randrange(20, 100, 1))\n        L1.set(random.randrange(20, 60, 1))\n        L2.set(L1())\n        L3.set(round(L1()*1.25))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        R = F2()+F3()-F1()\n        FBC = F1()+R\n        dAB = R*L1()/100/(210*10**9*0.004**2*math.pi)\n        dBC = FBC*L2()/100/(210*10**9*0.003**2*math.pi)\n        dCD = F3()*L3()/100/(210*10**9*0.005**2*math.pi)\n        instr= abs((dAB+dBC+dCD)*10**3)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.14 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_15dynamicsubmit.html",
    "href": "problem5_15dynamicsubmit.html",
    "title": "Problem 5.15 - Axial Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"187\"\nW=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nA1=reactive.Value(\"__\")\nA2=reactive.Value(\"__\")\nEsteel = 29000\nEaluminum = 10000\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A crate weight W = {W()} lb is attached to a cable constructed from steel of length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. and Area A&lt;sub&gt;1&lt;/sub&gt; = {A1()} in.&lt;sup&gt;2&lt;/sup&gt; and aluminum of length L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in. and area A&lt;sub&gt;2&lt;/sub&gt; = {A2()} in.&lt;sup&gt;2&lt;/sup&gt;. What is the total deflection of the crate after it is attached to the wire? Assume E&lt;sub&gt;steel&lt;/sub&gt; = {Esteel} ksi and E&lt;sub&gt;aluminum&lt;/sub&gt; = {Ealuminum} ksi. Neglect the weight of the wires.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W.set(random.randrange(50, 250, 1))\n        L1.set(random.randrange(10, 30, 1))\n        L2.set(round(L1()*2, 2))\n        A1.set(random.randrange(1, 5, 1)/100)\n        A2.set(random.randrange(1, 5, 1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        \n        instr=(W()*L1()/(A1()*Esteel*1000) + (W()*L2()/(A2()*Ealuminum*1000)))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.15 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_16dynamicsubmit.html",
    "href": "problem5_16dynamicsubmit.html",
    "title": "Problem 5.16 - Axial Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \nproblem_ID=\"190\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A solid square rod and round bar are pulled in series as shown. If load F&lt;sub&gt;1&lt;/sub&gt; =  {F1()} kip, load F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kip, length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in., and length L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in., determine the total displacement of the right tip of the structure. Assume E&lt;sub&gt;copper&lt;/sub&gt; = 16x10&lt;sup&gt;6&lt;/sup&gt; psi and E&lt;sub&gt;aluminum&lt;/sub&gt; = 10x10&lt;sup&gt;6&lt;/sup&gt; psi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(10,30,1))\n        F2.set(random.randrange(10,30,1))\n        L1.set(random.randrange(6,25,1))\n        L2.set(round(L1()*1.4,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Pc = (F1()+F2())*1000\n        Ec = 16*10**6\n        Ac = 1\n        Pa = F2()*1000\n        Ea = 10*10**6\n        Aa = 0.375**2*math.pi\n        instr = Pc*L1()/(Ec*Ac)+Pa*L2()/(Ea*Aa)\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.16 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_17dynamicsubmit.html",
    "href": "problem5_17dynamicsubmit.html",
    "title": "Problem 5.17 - Axial Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"190\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A solid square rod and round bar are pulled in series as shown. If load F =  {F1()} kip, length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in., and length L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in., determine the total displacement of the right tip of the structure. Assume E&lt;sub&gt;steel&lt;/sub&gt; = 29x10&lt;sup&gt;6&lt;/sup&gt; psi and E&lt;sub&gt;aluminum&lt;/sub&gt; = 10x10&lt;sup&gt;6&lt;/sup&gt; psi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(150,400,10))\n        L1.set(random.randrange(6,25,1))\n        L2.set(round(L1()*1.4,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Ps = F1()*1000\n        Es = 29*10**6\n        As = 4\n        Pa = F1()*1000\n        Ea = 10*10**6\n        Aa = 0.75**2*math.pi\n        instr = Ps*L1()/(Es*As)+Pa*L2()/(Ea*Aa)\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.17 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_18dynamicsubmit.html",
    "href": "problem5_18dynamicsubmit.html",
    "title": "Problem 5.18 - Axial Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"197\"\nw2=reactive.Value(\"__\")\nw1=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in terms of 10⁻⁶\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two solid square cross-sections with dimensions w&lt;sub&gt;1&lt;/sub&gt; = {w1()} mm and w&lt;sub&gt;2&lt;/sub&gt; = {w2()} mm are pulled in series by load F = {F()} kN. Determine the normal strain in rod b in the direction of the load. Assume E = 200 GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w2.set(random.randrange(25,80,1))\n        w1.set(round(w2()*1.25))\n        F.set(random.randrange(200,800,10))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        delb = F()*0.6/(200*10**6*(w2()/1000)**2)\n        instr = delb/0.6*10**6\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.18 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_19dynamicsubmit.html",
    "href": "problem5_19dynamicsubmit.html",
    "title": "Problem 5.19 - Axial Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"198\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two circular rods are attached together and loaded with forces F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN as shown. If length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} mm and length L&lt;sub&gt;2&lt;/sub&gt; = {L2()} mm, determine the total deflection of the right end. Assume E = 69 GPa for both rods.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(100,200,1)/10)\n        F2.set(round(F1(),1)+round(random.randrange(50,150,1)/10))\n        L2.set(random.randrange(200,400,10))\n        L1.set(L2()*1.2)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Pa = F2()-F1()\n        Pb = F2()\n        E = 69*10**9\n        delA = Pa*L1()/(E*0.0125**2*math.pi)\n        delB = Pb*L2()/(E*0.015**2*math.pi)\n        instr = (delA+delB)*10**3\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.19 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_20dynamicsubmit.html",
    "href": "problem5_20dynamicsubmit.html",
    "title": "Problem 5.20 - Axial Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"199\"\nF=reactive.Value(\"__\")\nLBC=reactive.Value(\"__\")\nLAB=reactive.Value(\"__\")\nr=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Force F = {F()} kips on lever ABC causes a force at D to compress the cylinder. Determine the vertical deflection of the cylinder. Lengths L&lt;sub&gt;AB&lt;/sub&gt; = {LAB()} in. and L&lt;sub&gt;BC&lt;/sub&gt; = {LBC()} in. The radius of the cylinder r = {r()} in. and E&lt;sub&gt;cylinder&lt;/sub&gt; = 10,000 ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(100,400,10))\n        LBC.set(random.randrange(5,20,1))\n        LAB.set(LBC()*1.7)\n        r.set(random.randrange(5,15,1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Fc = F()*LAB()*math.cos(45*math.pi/180)/(LBC()*math.cos(45*math.pi/180))\n        E = 10000\n        instr = Fc*6/(r()**2*math.pi*E)\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.20 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_27dynamicsubmit.html",
    "href": "problem5_27dynamicsubmit.html",
    "title": "Problem 5.27 - Deformation in Systems of Bars",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"191\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nA=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEsteel = 29000\nEaluminum = 10000\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A bar is attached to two wires, one steel and one aluminum. If the lengths of the wires L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in., find the distance x that load F = {F()} kips must be placed at so that the bar remains horizontal after the load is applied. Both wires have the same cross-section area A = {A()} in.&lt;sup&gt;2&lt;/sup&gt;. Assume E&lt;sub&gt;steel&lt;/sub&gt; = 29,000 ksi, E&lt;sub&gt;aluminum&lt;/sub&gt; = 10,000 ksi and that the bar is of length L = {L()} in.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(50, 150, 1)/10)\n        L2.set(round(L1()*2, 2))\n        F.set(random.randrange(30, 150, 1)/10)\n        A.set(random.randrange(2, 25, 1)/100)\n        L.set(random.randrange(10, 20, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        PsPa = (L1()*Esteel*A())/(L2()*Ealuminum*A())\n        Ps = (F()/(PsPa+1))*PsPa\n        instr=(Ps*L())/F()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.27 - Deformation in Systems of Bars"
    ]
  },
  {
    "objectID": "problem5_28dynamicsubmit.html",
    "href": "problem5_28dynamicsubmit.html",
    "title": "Problem 5.28 - Deformation in Systems of Bars",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"202\"\ndb=reactive.Value(\"__\")\nda=reactive.Value(\"__\")\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of degrees\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A bar is attached to two wires, one brass (diameter d&lt;sub&gt;b&lt;/sub&gt; = {db()} mm) and one aluminum (diameter d&lt;sub&gt;a&lt;/sub&gt; = {da()} mm). Loads F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN are applied as shown. Determine the angle of the bar from horizontal after the loads are applied.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        db.set(random.randrange(32,60,2))\n        da.set(random.randrange(20,30,2))\n        F1.set(random.randrange(10,50,1))\n        F2.set(random.randrange(10,50,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        FA = (2*F1()+10*F2())/7\n        FB = F1()+F2()-FA\n        EB = 100*10**9\n        EA = 70*10**9\n        delB = FB*1000*0.04/((db()/2000)**2*math.pi*EB)\n        delA = FA*1000*0.06/((da()/2000)**2*math.pi*EA)\n        instr = math.atan((delA-delB)/0.07)*180/math.pi\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.28 - Deformation in Systems of Bars"
    ]
  },
  {
    "objectID": "problem5_33dynamicsubmit.html",
    "href": "problem5_33dynamicsubmit.html",
    "title": "Problem 5.33 - Deformation in Systems of Bars",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \nproblem_ID=\"189\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nAA=reactive.Value(\"__\")\nAB=reactive.Value(\"__\")\nEA=reactive.Value(\"__\")\nEB=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of degrees\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two loads, F&lt;sub&gt;1&lt;/sub&gt; = {F1()} lb and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} lb are applied to a rigid horizontal rod that is supported by two wires. Wire A has cross-sectional area A&lt;sub&gt;A&lt;/sub&gt; = {AA()} in.&lt;sup&gt;2&lt;/sup&gt; and elastic modulus E&lt;sub&gt;A&lt;/sub&gt; = {EA()}x10&lt;sup&gt;6&lt;/sup&gt; psi. Wire B has cross-sectional area A&lt;sub&gt;B&lt;/sub&gt; = {AB()} in.&lt;sup&gt;2&lt;/sup&gt; and elastic modulus E&lt;sub&gt;B&lt;/sub&gt; = {EB()}x10&lt;sup&gt;6&lt;/sup&gt; psi. Determine the angle of rotation after the loads are applied\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(200,800,10))\n        F2.set(random.randrange(200,800,10))\n        AA.set(random.randrange(5,10,1)/100)\n        AB.set(random.randrange(2,5,1)/100)\n        EA.set(random.randrange(15,25,1))\n        EB.set(random.randrange(5,14,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        FB = (F1()*8+F2()*24)/16\n        FA = F1()+F2()-FB\n        delB = FB*12/(EB()*10**6*AB())\n        delA = FA*6/(EA()*10**6*AA())\n        delta = delB-delA\n        instr = math.atan(delta/16)*180/math.pi\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.33 - Deformation in Systems of Bars"
    ]
  },
  {
    "objectID": "problem5_34dynamicsubmit.html",
    "href": "problem5_34dynamicsubmit.html",
    "title": "Problem 5.34 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"192\"\nr=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\ndL=reactive.Value(\"__\")\nEcopper = 110\nEaluminum = 70\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A copper circular rod of radius r = {r()} cm is inserted into an aluminum tube with inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} cm and outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} cm as shown. Load P is applied to the rigid top plate. If length L = {L()} cm, what load P will cause the plate to deflect dL = {dL()} mm downward? Assume E&lt;sub&gt;copper&lt;/sub&gt; = 110 GPa and E&lt;sub&gt;aluminum&lt;/sub&gt; = 70 GPa\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        r.set(random.randrange(20, 60, 1)/10)\n        ri.set(round(r()*1.25, 2))\n        ro.set(round(r()*1.5, 2))\n        L.set(random.randrange(150, 300, 1)/10)\n        dL.set(random.randrange(10, 50, 1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr=(((dL()*Ecopper*r()**2*math.pi)/L()) + ((dL()*Ealuminum*(ro()**2-ri()**2)*math.pi)/L()))*10\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.34 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_35dynamicsubmit.html",
    "href": "problem5_35dynamicsubmit.html",
    "title": "Problem 5.35 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"193\"\nF=reactive.Value(\"__\")\nw1=reactive.Value(\"__\")\nw2=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEsteel = 29000\nEaluminum = 10000\n\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two blocks with square cross-sections are stacked as shown, with the top block inserted into the bottom block and subjected to load F = {F()} kips. The top block is aluminum (E = 10,000 ksi) with side length w&lt;sub&gt;1&lt;/sub&gt; = {w1()} in.  and the bottom block is steel (E = 29,000 ksi) with side length w&lt;sub&gt;2&lt;/sub&gt; = {w2()} in. If length L = {L()} in., what is the total deflection of the top surface? Ignore the weight of the blocks. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(20, 100, 1)/10)\n        w1.set(random.randrange(15, 50, 1)/10)\n        w2.set(round(w1()*1.5))\n        L.set(random.randrange(50, 200, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr=F()*L()*((1/((w1()**2)*Ealuminum)) + (1/((w2()**2)*Esteel)))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.35 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_36dynamicsubmit.html",
    "href": "problem5_36dynamicsubmit.html",
    "title": "Problem 5.36 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"246\"\nd=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEplastic=reactive.Value(\"__\")\nEwood=1750\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of lb\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two square members are attached to two fixed walls as shown. Force F is applied at point B and point B is displaced d =  {d()} in. to the right. If L = {L()} in., E&lt;sub&gt;wood&lt;/sub&gt; = 1,750 ksi, and E&lt;sub&gt;plastic&lt;/sub&gt; = {Eplastic()} ksi, determine the applied force F. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(2, 8, 1)/1000)\n        L.set(random.randrange(4, 15, 1))\n        Eplastic.set(random.randrange(350, 900, 10))\n       \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (d()*1*Ewood*1000)/L() - (-d()*4*Eplastic()*1000)/L() \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.36 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_37dynamicsubmit.html",
    "href": "problem5_37dynamicsubmit.html",
    "title": "Problem 5.37 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"247\"\nF=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nEwood=70\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two aluminum circular rods are attached to two fixed walls as shown. Assume E = 70 MPa for both cylinders, F = {F()} kN, d&lt;sub&gt;1&lt;/sub&gt; = {d1()} mm, d&lt;sub&gt;2&lt;/sub&gt;  = {d2()} mm, L&lt;sub&gt;1&lt;/sub&gt;  = {L1()} mm, and L&lt;sub&gt;2&lt;/sub&gt;  = {L2()} mm. Determine the normal stress in member 1.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(20, 100, 1))\n        d1.set(random.randrange(15, 50, 1))\n        d2.set(round(d1()*1.5))\n        L1.set(random.randrange(200, 800, 10))\n        L2.set(round(L1()*(2/3)))\n       \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        LHS = (L1()/1000)/(math.pi*(d1()/2000)**2) + (L2()/1000)/(math.pi*(d2()/2000)**2)\n        RHS = (F()*L2())/(math.pi*(d2()/2)**2)\n        instr= (RHS/LHS)/(math.pi*(d1()/2000)**2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.37 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_38dynamicsubmit.html",
    "href": "problem5_38dynamicsubmit.html",
    "title": "Problem 5.38 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"248\"\nw=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nh1=reactive.Value(\"__\")\nh2=reactive.Value(\"__\")\nEconcrete=25\nEwood=12\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A distributed load w = {w()} N/cm&lt;sup&gt;2&lt;/sup&gt; is applied to a short column made from wood and concrete. Assume E&lt;sub&gt;concrete &lt;/sub&gt;= 25 GPa, E&lt;sub&gt;wood&lt;/sub&gt; = 12 GPa, b = {b()} cm, h&lt;sub&gt;1&lt;/sub&gt; = {h1()} cm, and h&lt;sub&gt;2&lt;/sub&gt; = {h2()} cm. What load is carried by the concrete center?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(50, 750, 10))\n        b.set(random.randrange(20, 100, 1)/10)\n        h1.set(b()*1)\n        h2.set(b()*2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (2.0833*h2()*w()*(2*h1()+h2())*3*b())/(6*h1()+4.0833*h2())/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.38 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_39dynamicsubmit.html",
    "href": "problem5_39dynamicsubmit.html",
    "title": "Problem 5.39 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"250\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\ndc=reactive.Value(\"__\")\nds=reactive.Value(\"__\")\nEconcrete=25\nEsteel=200\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A concrete post of length L = {L()}  m and diameter d&lt;sub&gt;c&lt;/sub&gt; = {dc()} mm supports a load F = {F()} kN. The concrete is reinforced with 6 steel rods of diameter d&lt;sub&gt;s&lt;/sub&gt; = {ds()} mm. Assume E&lt;sub&gt;concrete&lt;/sub&gt; = 25 GPa and E&lt;sub&gt;steel&lt;/sub&gt; = 200 GPa. Determine the stress in the concrete.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10, 50, 1)/10)\n        dc.set(random.randrange(100, 500, 10))\n        ds.set(round(dc()/12))\n        F.set(random.randrange(100, 500, 10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        As = (math.pi*6*(ds()/20)**2)\n        Ac = (math.pi*(dc()/20)**2) - As\n        Cside = Ac*Econcrete\n        Sside = As*Esteel\n        LHS = F()*Cside\n        RHS = Cside+Sside\n        instr= ((LHS/RHS)/(Ac/100**2))/10**3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.39 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_40dynamicsubmit.html",
    "href": "problem5_40dynamicsubmit.html",
    "title": "Problem 5.40 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"252\"\nL2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two circular rods are attached together and fixed between two walls. Length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m, L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m, diameter d&lt;sub&gt;1&lt;/sub&gt; = {d1()} mm, and d&lt;sub&gt;2&lt;/sub&gt; = {d2()} mm. A force F = {F()} kN is applied as shown. Determine the largest stress in either rod. Assume E = 190 GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L2.set(random.randrange(20,80,5)/100)\n        L1.set(round(L2())+(random.randrange(5,20,5)/100))\n        d1.set(random.randrange(20,50,1))\n        d2.set(d1()+random.randrange(5,15,1))\n        F.set(random.randrange(10,100,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Fa = 12*L2()/((d2()/2000)**2*math.pi)/(L1()/((d1()/2000)**2*math.pi)+L2()/((d2()/2000)**2*math.pi))\n        Fb = 12-Fa\n        sigmaA = Fa/((d1()/2000)**2*math.pi)/1000\n        sigmaB = Fb/((d2()/2000)**2*math.pi)/1000\n        instr = max(sigmaA,sigmaB)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.40 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_41dynamicsubmit.html",
    "href": "problem5_41dynamicsubmit.html",
    "title": "Problem 5.41 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"254\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Three cylinders support a load F = {F()} kN. If length L = {L()} m, determine the stress in the aluminum cylinder. Assume E&lt;sub&gt;steel&lt;/sub&gt; = 200 GPA, E&lt;sub&gt;alum&lt;/sub&gt; = 70 GPA, and the diameter of each cylinder d = {d()} mm.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(100,500,10))\n        L.set(random.randrange(5,50,1)/10)\n        d.set(random.randrange(25,100,1))\n                \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        FB = F()/((2*L()*200)/(2*L()*70)+1)\n        instr = FB/(math.pi*(d()/2000)**2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.41 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_42dynamicsubmit.html",
    "href": "problem5_42dynamicsubmit.html",
    "title": "Problem 5.42 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"255\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Three circular steel rods (E = 29,000 ksi) are placed between two fixed walls as shown. Loads F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kips and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kips are applied to the assembly. Determine the average normal stress in member 3. Please submit a positive answer for tension or a negative answer for compression.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(10,50,1))\n        F2.set(random.randrange(10,50,1))\n                \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        A1 = math.pi*0.5**2\n        A2 = math.pi*0.75**2\n        A3 = A1\n        L1 = 1\n        L2 = 2\n        L3 = 3\n        FA = (F1()*L2/A2+F1()*L3/A3+F2()*L3/A3)/(L1/A1+L2/A2+L3/A3)\n        FR3 = FA-F1()-F2()\n        instr = FR3*1000/A3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.42 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_43dynamicsubmit.html",
    "href": "problem5_43dynamicsubmit.html",
    "title": "Problem 5.43 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"261\"\ndelta=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nr1=reactive.Value(\"__\")\nr2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two circular rods are attached together and placed between two fixed surfaces. The right surface is moved to the right by ẟ = {delta()} in., stretching the two rods. Determine the force at the right wall. Assume E&lt;sub&gt;steel&lt;/sub&gt; = 29,000 ksi, E&lt;sub&gt;alum&lt;/sub&gt; = 10,000 ksi, L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in., L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in., r&lt;sub&gt;1&lt;/sub&gt; = {r1()} in., and r&lt;sub&gt;2&lt;/sub&gt; = {r2()} in.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        delta.set(random.randrange(1,5,1)/100)\n        L1.set(random.randrange(5,20,1))\n        L2.set(round(L1()*1.3,1))\n        r1.set(random.randrange(20,200,5)/100)\n        r2.set(round(r1()*1.5,1))\n    \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        \n        instr = delta()/(L1()/(29*10**6*r1()**2*math.pi)+L2()/(10*10**6*math.pi*r2()**2))/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.43 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_44dynamicsubmit.html",
    "href": "problem5_44dynamicsubmit.html",
    "title": "Problem 5.44 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"262\"\nri=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\ndelta=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A steel tube of inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} in., outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} in., and length L = {L()} in. is filled with concrete except for a small gap at the top of ẟ = {delta()} in. A rigid metal plate is loaded with force F = {F()} kips. Determine the stress in the steel tube. Assume E&lt;sub&gt;c&lt;/sub&gt; = 4,000 ksi and E&lt;sub&gt;s&lt;/sub&gt; = 29,000 ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        ri.set(random.randrange(25,50,1)/10)\n        ro.set(round(ri())+random.randrange(1,5,1)/10)\n        L.set(random.randrange(30,60,1))\n        delta.set(random.randrange(1,5,1)/1000)\n        F.set(random.randrange(100,300,10))\n    \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        As = (ro()**2-ri()**2)*math.pi\n        Ac = ri()**2*math.pi\n        Ec = 4000\n        Es = 29000\n        Lc = L()-delta()\n        Fc = (F()*L()/(As*Es)-delta())/(Lc/(Ac*Ec)+L()/(As*Es))\n        Fs = F()-Fc\n        instr = Fs/As\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.44 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_45dynamicsubmit.html",
    "href": "problem5_45dynamicsubmit.html",
    "title": "Problem 5.45 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"264\"\nL=reactive.Value(\"__\")\ndelT=reactive.Value(\"__\")\nAa=reactive.Value(\"__\")\nAs=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two members, each of length L = {L()} m., are placed between two fixed walls and heated by amount ΔT = {delT()}°C. The steel member (E&lt;sub&gt;s&lt;/sub&gt; = 200 GPa, α&lt;sub&gt;s&lt;/sub&gt; = 12 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C) has cross-sectional area A&lt;sub&gt;s&lt;/sub&gt; = {As()} mm.&lt;sup&gt;2&lt;/sup&gt;. The aluminum member (E&lt;sub&gt;a&lt;/sub&gt; = 70 GPa, α&lt;sub&gt;a&lt;/sub&gt; = 23 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C) has cross-sectional area A&lt;sub&gt;a&lt;/sub&gt; = {Aa()} mm.&lt;sup&gt;2&lt;/sup&gt;. Determine the average normal stress in the aluminum member.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(5,50,1)/10)\n        delT.set(random.randrange(50,150,1))\n        Aa.set(random.randrange(100,500,10))\n        As.set(Aa()*2)\n    \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        F = (12*10**-6*L()*delT()+23*10**-6*L()*delT())/(L()/(As()*200*10**3)+L()/(Aa()*70*10**3))\n        instr = F/Aa()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.45 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_50dynamicsubmit.html",
    "href": "problem5_50dynamicsubmit.html",
    "title": "Problem 5.50 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"222\"\nstress=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nE=29000\nalpha=6.5*10**-6\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of °F\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The axial stress in a solid circular bar between two fixed walls is {stress()} ksi. Find the temperature change necessary to relieve the stress. Assume L = {L()} in., E = 29,000 ksi, and α = 6.5 x 10&lt;sup&gt;-6&lt;/sup&gt; / °F. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        stress.set(random.randrange(10, 150, 5))\n        L.set(random.randrange(15, 75, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= stress()/(alpha*E)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.50 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_51dynamicsubmit.html",
    "href": "problem5_51dynamicsubmit.html",
    "title": "Problem 5.51 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"223\"\nW=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nTC=reactive.Value(\"__\")\nE=100*10**9\nalpha=10*10**-6\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The W = {W()} kg weight is placed on a L = {L()} m tall brass bar with a cross section of d = {d()} cm. If the bar undergoes a temperature change of {TC()}°C, what is the total deformation of the bar? Assume the Young's Modulus and thermal coefficient of expansion is 100 GPa and 10 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C, respectively. Also, assume no buckling. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W.set(random.randrange(500, 2000, 100))\n        L.set(random.randrange(10, 50, 1)/10)\n        d.set(random.randrange(15, 40, 1)/10)\n        TC.set(random.randrange(20, 150, 5))\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        deltaT = L()*alpha*TC()\n        deltaM = (W()*9.81*L())/(E*math.pi*(d()/200)**2) #200 converts from diameter in cm to r in meters\n        instr= (deltaT - deltaM)*1000 # *1000 to get answer in mm\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.51 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_52dynamicsubmit.html",
    "href": "problem5_52dynamicsubmit.html",
    "title": "Problem 5.52 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"224\"\nd=reactive.Value(\"__\")\nrA=reactive.Value(\"__\")\nrB=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nalphaA=6*10**-6\nalphaB=10*10**-6\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of °F\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two cylindrical rods are heated until they expand, just closing the gap of d = {d()} in. The coefficient of thermal expansion, α, for material A and B is 6 x 10&lt;sup&gt;-6&lt;/sup&gt;/°F and 10 x 10&lt;sup&gt;-6&lt;/sup&gt;/°F, respectively. The radius of A r&lt;sub&gt;A&lt;/sub&gt; = {rA()} in and the length is L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. The radius of B is r&lt;sub&gt;B&lt;/sub&gt; = {rB()} in and the length is L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in. What is the change in temperature.  \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(1, 20, 1)/100)\n        rA.set(random.randrange(5, 20, 1)/10)\n        rB.set(round(rA()*1.6, 2))\n        L1.set(random.randrange(5, 20, 1))\n        L2.set(round(L1()*0.6, 2))\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= d()/(alphaA*L1()+alphaB*L2())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.52 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_53dynamicsubmit.html",
    "href": "problem5_53dynamicsubmit.html",
    "title": "Problem 5.53 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"225\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nL3=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\ndT=reactive.Value(\"__\")\nalphaA=10*10**-6\nalphaB=5*10**-6\nalphaC=7*10**-6\nEA=40*10**9\nEB=120*10**9\nEC=80*10**9\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Three cylindrical rods of lengths L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m, L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m, and L&lt;sub&gt;3&lt;/sub&gt; = {L3()} m are connected together. A force F = {F()} kN is applied to the free end and all three rods are heated by {dT()} °C. The coefficient of thermal expansion, α, and elastic modulus, E, for each material are α&lt;sub&gt;A&lt;/sub&gt; = 10 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C, α&lt;sub&gt;B&lt;/sub&gt; = 5 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C, α&lt;sub&gt;C&lt;/sub&gt; = 7 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C, E&lt;sub&gt;A&lt;/sub&gt; = 40 GPa, E&lt;sub&gt;B&lt;/sub&gt; = 120 GPa, and E&lt;sub&gt;C&lt;/sub&gt; = 80 GPa. What is the total deflection of the right rod tip?  \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(10, 40, 1)/10)\n        L2.set(round((L1()*0.8),1))\n        L3.set(round((L1()*2/3),1))        \n        F.set(random.randrange(5, 50, 1))\n        dT.set(random.randrange(100, 300, 10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        deltaL = (F()*L1()*1000)/(EA*math.pi*.015**2) + (F()*L2()*1000)/(EB*math.pi*.005**2) + (F()*L3()*1000)/(EC*math.pi*.01**2)\n        deltaT = alphaA*dT()*L1() + alphaB*dT()*L2() + alphaC*dT()*L3() \n        instr= (deltaL + deltaT)*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.53 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_54dynamicsubmit.html",
    "href": "problem5_54dynamicsubmit.html",
    "title": "Problem 5.54 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"226\"\nT1=reactive.Value(\"__\")\nT2=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nalpha=20*10**-6\nE=100*10**9\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A square brass bar is placed between two fixed walls and heated from {T1()}°C to {T2()}°C. If L = {L()} mm, h = {h()} mm, E = 100 GPa, and α = 20 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C, determine the stress in the bar.  \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T1.set(random.randrange(5, 20, 1))\n        T2.set(round(T1() + random.randrange(20, 50, 1), 2))\n        L.set(random.randrange(250, 750, 10))\n        h.set(random.randrange(10, 30, 1))\n       \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (E*alpha*(T2()-T1()))/10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.54 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_55dynamicsubmit.html",
    "href": "problem5_55dynamicsubmit.html",
    "title": "Problem 5.55 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"249\"\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\ndT=reactive.Value(\"__\")\nE=200\nv=0.32\na=11.7*10**-6\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Bars AB and BC are pinned at joint B. Both bars are made from the same material with E = 200 GPa, v = 0.32, and a = 11.7 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C. Dimensions L = {L()}  mm, t = {t()} mm, h = {h()} mm, and d = {d()} mm. If both bars are heated by {dT()} °C, determine the shear stress generated in the pin at B.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(300, 900, 10))\n        t.set(random.randrange(30, 80, 1))\n        h.set(t()/2)\n        d.set(round(t()/3,2))\n        dT.set(random.randrange(10, 40, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        deltaM = a*dT()*(t()/1000)*(h()/1000)*E*10**9\n        instr= (deltaM/(math.pi*(d()/2000)**2))/10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.55 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_56dynamicsubmit.html",
    "href": "problem5_56dynamicsubmit.html",
    "title": "Problem 5.56 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"139\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nFA=reactive.Value(\"__\")\nFB=reactive.Value(\"__\")\nE = 30*10**6\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two cylinders are stacked on top of one another and two forces are applied at the top surface and at the joint between the cylinders as shown. If L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in., L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in., F&lt;sub&gt;A&lt;/sub&gt; = {FA()} lb, and F&lt;sub&gt;B&lt;/sub&gt; = {FB()} lb, find the total deflection in the stack of cylinders. Assume E = 30 x 10&lt;sup&gt;6&lt;/sup&gt; psi for both cylinders. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        FA.set(random.randrange(300, 700, 10))\n        FB.set(random.randrange(100, 300, 10))\n        L1.set(random.randrange(2, 7, 1))\n        L2.set(L1() * 1.3)\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        instr= (FA()*L1())/((math.pi*(5/2)**2)*E) + (FB()*L2())/((math.pi*(3/2)**2)*E)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.56 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_57dynamicsubmit.html",
    "href": "problem5_57dynamicsubmit.html",
    "title": "Problem 5.57 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"228\"\nL2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\ndelL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of \\u00b0C\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two solid circular rods of lengths L&lt;sub&gt;1&lt;/sub&gt; = {L1()} mm and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} mm are heated and the total change in length is measured as ΔL = {delL()} mm. Determine the change in temperature, assuming α&lt;sub&gt;t&lt;/sub&gt; = 9.5 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C and α&lt;sub&gt;s&lt;/sub&gt; = 12 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L2.set(random.randrange(400,600,10))\n        L1.set(L2()+random.randrange(100,200,10))\n        delL.set(random.randrange(10,300,1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr = delL()/(L1()*9.5*10**(-6)+L2()*12*10**(-6))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.57 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_58dynamicsubmit.html",
    "href": "problem5_58dynamicsubmit.html",
    "title": "Problem 5.58 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport math\nimport io\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"229\"\nri=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nT1=reactive.Value(\"__\")\nT2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A long steel pipe, with an internal radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} mm and wall thickness t = {t()} mm, is mounted between two fixed walls. Fluid flowing through the pipe raises the temperature from T&lt;sub&gt;1&lt;/sub&gt; = {T1()}°C to T&lt;sub&gt;2&lt;/sub&gt; = {T2()}°C. Determine the force on the support due to this heating. Assume E = 20 GPa and α = 12 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        ri.set(random.randrange(50,150,1))\n        t.set(random.randrange(10,20,1))\n        T1.set(random.randrange(20,50,1))\n        T2.set(random.randrange(150,250,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        A = math.pi*((ri()+t())**2-0.09**2)\n        instr = 12*10**(-6)*(T2()-T1())*A*20*10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.58 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_59dynamicsubmit.html",
    "href": "problem5_59dynamicsubmit.html",
    "title": "Problem 5.59 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport math\nimport io\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"230\"\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nT1=reactive.Value(\"__\")\nT2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"An aluminum cylinder of length L = {L()} in. and diameter d = {d()} in. is fixed between two walls and heated from T&lt;sub&gt;1&lt;/sub&gt; = {T1()}°F to T&lt;sub&gt;2&lt;/sub&gt; ={T2()}°F. Determine the magnitude of the force that the walls exert on the cylinder. Assume α = 13 x 10&lt;sup&gt;-6&lt;/sup&gt; /°F and E = 10 x 10&lt;sup&gt;6&lt;/sup&gt; psi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(5,20,1))\n        d.set(random.randrange(15,50,1)/10)\n        T1.set(random.randrange(20,50,1))\n        T2.set(T1()+random.randrange(30,100,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        delT = 13*10**(-6)*(T2()-T1())*L()\n        instr = delT*(math.pi*(d()/2)**2)*10*10**6/L()/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.59 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_60dynamicsubmit.html",
    "href": "problem5_60dynamicsubmit.html",
    "title": "Problem 5.60 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport math\nimport io\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"231\"\nL=reactive.Value(\"__\")\nT1=reactive.Value(\"__\")\nT2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A square PVC plastic rod of length L = {L()} mm is placed between two fixed walls and heated from T&lt;sub&gt;1&lt;/sub&gt; = {T1()}°C to T&lt;sub&gt;2&lt;/sub&gt; = {T2()}°C. Determine the stress created in the bar. Assume E = 2.8 GPa and α = 50 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(500,1500,10))\n        T1.set(random.randrange(0,30,1))\n        T2.set(T1()+random.randrange(80,150,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr = 2800*50*10**(-6)*(T2()-T1())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.60 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_61dynamicsubmit.html",
    "href": "problem5_61dynamicsubmit.html",
    "title": "Problem 5.61 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport math\nimport io\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"232\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\ndelT=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two solid bars of length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in. are heated by ΔT = {delT()}°F. The bars have width w = {w()} in. and thickness t = {t()} in. Determine the total combined change in length of the bars. Assume α&lt;sub&gt;alum&lt;/sub&gt; = 13 x 10&lt;sup&gt;-6&lt;/sup&gt; /°F and α&lt;sub&gt;steel&lt;/sub&gt; = 6.5 x 10&lt;sup&gt;-6&lt;/sup&gt; /°F.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(50,100,1)/10)\n        L2.set(L1()+random.randrange(20,50,1)/10)\n        delT.set(random.randrange(100,300,1))\n        t.set(random.randrange(10,20,1)/10)\n        w.set(t()*2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr = (L1()*13*10**-6+L2()*6.5*10**-6)*delT()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.61 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_62dynamicsubmit.html",
    "href": "problem5_62dynamicsubmit.html",
    "title": "Problem 5.62 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport math\nimport io\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"233\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\ndelT=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two solid bars of length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in. are stacked on top of each other, and a box of weight W is placed on top. The bars have width w = {w()} in. and thickness t = {t()} in. The bars are heated by ΔT = {delT()}°F. Determine the weight of the box if the total deflection of the bars is zero. Assume α&lt;sub&gt;alum&lt;/sub&gt; = 13 x 10&lt;sup&gt;-6&lt;/sup&gt; /°F, α&lt;sub&gt;steel&lt;/sub&gt; = 6.5 x 10&lt;sup&gt;-6&lt;/sup&gt; /°F, E&lt;sub&gt;alum&lt;/sub&gt; = 10 x 10&lt;sup&gt;6&lt;/sup&gt; psi, and E&lt;sub&gt;steel&lt;/sub&gt; = 29 x 10&lt;sup&gt;6&lt;/sup&gt; psi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(50,100,1)/10)\n        L2.set(L1()+random.randrange(20,50,1)/10)\n        t.set(random.randrange(10,20,1)/10)\n        w.set(t()*2)\n        delT.set(random.randrange(50,100,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        dTherm = L1()*6.5*10**-6*delT()+L2()*13*10**-6*delT()\n        dM = (L1()/29000+L2()/10000)/(w()*t())\n        instr = dTherm/dM\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.62 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_63dynamicsubmit.html",
    "href": "problem5_63dynamicsubmit.html",
    "title": "Problem 5.63 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport math\nimport io\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"235\"\nL2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\ndelT1=reactive.Value(\"__\")\ndelT2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A square steel 1 inch bar is placed between two fixed walls. The bar is heated such that section 1 of length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. is heated by ΔT&lt;sub&gt;1&lt;/sub&gt; = {delT2()}°F and section 2 of length L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in. is heated by ΔT&lt;sub&gt;2&lt;/sub&gt; = {delT2()}°F. Determine the stress created in the bar. Assume E = 29,000 ksi and α = 6.5 x 10&lt;sup&gt;-6&lt;/sup&gt; /°F.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L2.set(random.randrange(40,100,1)/10)\n        L1.set(L2()+random.randrange(20,60,1)/10)\n        delT1.set(random.randrange(50,100,1))\n        delT2.set(delT1()+random.randrange(50,100,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        dTherm = 6.5*10**-6*(L1()*delT1()+L2()*delT2())\n        instr = dTherm*29000/(L1()+L2())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.63 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_64dynamicsubmit.html",
    "href": "problem5_64dynamicsubmit.html",
    "title": "Problem 5.64 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport math\nimport io\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"236\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\ndelT=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two wires of length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m are connected together and attached to the ceiling and floor of a room. If the room is cooled by {delT()}°C, dettermine the largest stress in either wire. Assume the diameter d = {d()} mm, α&lt;sub&gt;alum&lt;/sub&gt; = 23 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C, E&lt;sub&gt;alum&lt;/sub&gt; = 70 GPa, α&lt;sub&gt;steel&lt;/sub&gt; = 12 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C, and E&lt;sub&gt;steel&lt;/sub&gt; = 190 GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(10,50,1)/10)\n        L2.set(L1()*3)\n        delT.set(random.randrange(20,50,1))\n        d.set(random.randrange(5,10,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        A = (d()/2)**2*math.pi*10**-6\n        dTherm = 12*10**-6*delT()*L2()+23*10**-6*delT()*L1()\n        F = dTherm/(L1()/(70*10**9*A)+L2()/(190*10**9*A))\n        instr = F/A/10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.64 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_65dynamicsubmit.html",
    "href": "problem5_65dynamicsubmit.html",
    "title": "Problem 5.65 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport math\nimport io\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"237\"\nw=reactive.Value(\"__\")\ndelT=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A square steel bar with cross-section side length w = {w()} mm is placed between two fixed walls. The bar is heated so that the change in temperature ΔT = {delT()}°C. A single load F = {F()} kN is applied at the center. If length L = {L()} m, determine the reaction force on the right wall. Assume E = 200 GPa and α = 12 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10,50,1))\n        delT.set(random.randrange(250,500,10))\n        F.set(random.randrange(50,200,1))\n        L.set(random.randrange(10,50,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        dTherm = 12*10**-6*L()*delT()\n        FLR = dTherm/(L()/(200*10**9*w()*w()*10**-6))*10**-3\n        instr = (FLR+F())/2\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.65 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_66dynamicsubmit.html",
    "href": "problem5_66dynamicsubmit.html",
    "title": "Problem 5.66 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport math\nimport io\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"238\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\naPVC=reactive.Value(\"__\")\naPoly=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of \\u00b0C\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two posts support a slender bar as shown, where L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m, causing the bar to be at a slight angle. Determine the increase in temperature that will cause the bar to become horizontal. Assume α&lt;sub&gt;PVC&lt;/sub&gt; = {aPVC()} x 10&lt;sup&gt;-6&lt;/sup&gt; /°C and α&lt;sub&gt;poly&lt;/sub&gt; = {aPoly()} x 10&lt;sup&gt;6&lt;/sup&gt; /°C. Ignore the weight of the bar.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(30,50,1)/1000)\n        L2.set(L1()+random.randrange(1,3,1)/1000)\n        aPVC.set(random.randrange(40,60,1))\n        aPoly.set(random.randrange(60,100,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr = (L2()-L1())/(aPVC()*10**-6*L1()-aPoly()*10**-6*L2())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.66 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_67dynamicsubmit.html",
    "href": "problem5_67dynamicsubmit.html",
    "title": "Problem 5.67 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport math\nimport io\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"239\"\nt=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\ndelT=reactive.Value(\"__\")\nEpin=reactive.Value(\"__\")\napin=reactive.Value(\"__\")\nvpin=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two rigid plates of thickness t = {t()} in. are held together with a plastic pin of diameter d = {d()} in. If the temperature raises by ΔT = {delT()}°F, how far does the pin protrude from the top surface? Assume E&lt;sub&gt;pin&lt;/sub&gt; = {Epin()} ksi, α&lt;sub&gt;pin&lt;/sub&gt; = {apin()} x 10&lt;sup&gt;-6&lt;/sup&gt; /°F, and ν&lt;sub&gt;pin&lt;/sub&gt; = {vpin()}.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        t.set(random.randrange(30,80,1)/100)\n        d.set(random.randrange(30,80,1)/100)\n        delT.set(random.randrange(50,150,1))\n        Epin.set(random.randrange(800,1200,10))\n        apin.set(random.randrange(80,120,1)/10)\n        vpin.set(random.randrange(35,45,1)/100)\n    \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        dzT = apin()*10**-6*delT()*2*t()\n        dxT = apin()*10**-6*delT()*d()\n        exM = dxT/d()\n        ezM = vpin()*2*exM/(1-vpin())\n        dzM = ezM*2*t()\n        instr = dzT+dzM\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.67 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_68dynamicsubmit.html",
    "href": "problem5_68dynamicsubmit.html",
    "title": "Problem 5.68 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"240\"\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\ndelta=reactive.Value(\"__\")\ndelT = reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A circular bar of length L = {L()} m and diameter d = {d()} mm is placed between two walls. The left end is fixed to the wall and the right end is ẟ = {delta()} mm from the wall. The temperature of the bar is raised ΔT = {delT()}°C. Determine the change in the bar's diameter. Assume E = 3 GPa, α = 13.3 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C, and ν = 0.32.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(30,80,1)/10)\n        d.set(random.randrange(50,100,1))\n        delta.set(random.randrange(5,50,1)/10)\n        delT.set(random.randrange(150,350,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        dTherm = 13.3*10**-6*delT()*L()\n        sigmax = (delta()/1000-dTherm)/(L()/3000)\n        ey = -0.32*sigmax/3000+13.3*10**-6*delT()\n        instr = ey*d()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.68 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_69dynamicsubmit.html",
    "href": "problem5_69dynamicsubmit.html",
    "title": "Problem 5.69 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"241\"\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\ndelT = reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A circular bar of length L = {L()} in. and diameter d = {d()} in. is placed between two walls. The left end is fixed to the wall and the right end is ẟ =  0.01 in. from the wall. The temperature of the bar is raised ΔT = {delT()}°F. Determine the average normal stress in the bar. Assume E = 29,000 ksi and α = 7 x 10&lt;sup&gt;-6&lt;/sup&gt; /°F.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10,30,1))\n        d.set(random.randrange(3,20,1)/10)\n        delT.set(random.randrange(150,350,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        dTherm = 7*10**-6*delT()*L()\n        instr = (dTherm-0.01/1000)/(L()/29000)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.69 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_70dynamicsubmit.html",
    "href": "problem5_70dynamicsubmit.html",
    "title": "Problem 5.70 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"242\"\nW=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\ndelta=reactive.Value(\"__\")\nT1=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of \\u00b0C\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A crate weighing W = {W()} kN is hung from a long steel cable of diameter d = {d()} mm and length L = {L()} m. The crate is initially ẟ = {delta()} mm above the ground when the temperature is T&lt;sub&gt;1&lt;/sub&gt; = {T1()}°C. At what temperature will the crate touch the ground. Assume E&lt;sub&gt;s&lt;/sub&gt; = 190 GPa and α&lt;sub&gt;s&lt;/sub&gt; = 6.5 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W.set(random.randrange(50,100,1))\n        d.set(random.randrange(50,100,1))\n        L.set(random.randrange(50,100,1)/10)\n        delta.set(random.randrange(5,10,1))\n        T1.set(random.randrange(15,30,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        dLoad = W()*1000*L()/((d()/1000/2)**2*math.pi*190*10**9)*1000\n        instr = (delta()-dLoad+T1()*6.5*10**-6*L()*1000)/(6.5*10**-6*L()*1000)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.70 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_71dynamicsubmit.html",
    "href": "problem5_71dynamicsubmit.html",
    "title": "Problem 5.71 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"242\"\nW=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\ndelta=reactive.Value(\"__\")\nT1=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of \\u00b0C\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A crate weighing W = {W()} kN is hung from a long steel cable of diameter d = {d()} mm and length L = {L()} m. The crate is initially ẟ = {delta()} mm above the ground when the temperature is T&lt;sub&gt;1&lt;/sub&gt; = {T1()}°C. At what temperature will the crate touch the ground. Assume E&lt;sub&gt;s&lt;/sub&gt; = 190 GPa and α&lt;sub&gt;s&lt;/sub&gt; = 6.5 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W.set(random.randrange(50,100,1))\n        d.set(random.randrange(50,100,1))\n        L.set(random.randrange(50,100,1)/10)\n        delta.set(random.randrange(5,10,1))\n        T1.set(random.randrange(15,30,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        dLoad = W()*1000*L()/((d()/1000/2)**2*math.pi*190*10**9)*1000\n        instr = (delta()-dLoad+T1()*6.5*10**-6*L()*1000)/(6.5*10**-6*L()*1000)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.71 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_72dynamicsubmit.html",
    "href": "problem5_72dynamicsubmit.html",
    "title": "Problem 5.72 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"244\"\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\ndelT=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A brass bar of length L = {L()} in. and diameter d = {d()} in. has its temperature increased by ΔT = {delT()}°F. Determine the force F required to keep the diameter of the bar constant. Assume E = 15,000 ksi, α = 11 x 10&lt;sup&gt;-6&lt;/sup&gt; /°F, and ν = 0.3.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10,30,1))\n        d.set(random.randrange(10,50,1)/10)\n        delT.set(random.randrange(50,100,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        dTherm = d()*11*10**-6*delT()\n        dP = 0.3/((d()/2)**2*math.pi)/15000/d()\n        instr = dTherm/dP\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.72 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_73dynamicsubmit.html",
    "href": "problem5_73dynamicsubmit.html",
    "title": "Problem 5.73 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"253\"\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\ndelT=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\nalpha=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cable of length L = {L()} m and diameter d = {d()} mm is connected between two fixed surfaces with no initial stress. The room is cooled by ΔT = {delT()}°C. Determine the stress in the cable. Assume E = {E()} GPa and α = {alpha()} x 10&lt;sup&gt;-6&lt;/sup&gt; /°C.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(20,100,1)/10)\n        d.set(random.randrange(10,30,1))\n        delT.set(random.randrange(50,150,1))\n        E.set(random.randrange(175,225,1))\n        alpha.set(random.randrange(80,130,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr = alpha()*10**-6*delT()*E()*10**3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.73 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_74dynamicsubmit.html",
    "href": "problem5_74dynamicsubmit.html",
    "title": "Problem 5.74 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"260\"\ndelT=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two circular rods are placed between two fixed walls as shown. The top rod is steel (E = 29,000 ksi, α = 6.5 x 10&lt;sup&gt;-6&lt;/sup&gt; /°F) and the bottom rod is aluminum (E = 10,000 ksi, α = 13 x 10&lt;sub&gt;-6&lt;/sub&gt; /°F). Determine the stress in the aluminum rod of the temperature increases by  ΔT  = {delT()}°F and a load F = {F()} kips is applied as shown. Assume L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        delT.set(random.randrange(100,200,1))\n        F.set(random.randrange(10,50,1))\n        L1.set(random.randrange(5,20,1))\n        L2.set(L1()*1.3)\n    \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        dTs = L1()*6.5*10**-6*delT()\n        dTal = L2()*13*10**-6*delT()\n        Fs = (dTs+dTal-(F()*1000*L2()/(10*10**6*0.75**2*math.pi)))/(L1()/(29*10**6*0.5**2*math.pi)-L2()/(10*10**6*0.75**2*math.pi))\n        Fal = Fs+F()*1000\n        instr = Fal/(0.75**2*math.pi)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.74 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem6_1dynamicsubmit.html",
    "href": "problem6_1dynamicsubmit.html",
    "title": "Problem 6.1 - Torsional Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"265\"\nT=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN-m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"What torque is required to create a maximum shear stress of τ = {T()} MPa in a solid circular bar of diameter d  = {d()} mm? .\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T.set(random.randrange(20, 50, 1))\n        d.set(random.randrange(50, 200, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        J = (math.pi/2)*(d()/2000)**4\n        instr= (T()*1000*J)/(d()/2000)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.1 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_2dynamicsubmit.html",
    "href": "problem6_2dynamicsubmit.html",
    "title": "Problem 6.2 - Torsional Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"267\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\ny=reactive.Value(\"__\")\nd=(reactive.Value(\"__\"))\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A force F = {F()} lb is applied to a hand crank that is stuck and will not turn. If L = {L()} in. and y = {y()} in., determine the maximum shear stress due to torsion in the crank rod between A and B. Assume the crank has diameter d = {d()} in.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(100, 350, 10))\n        L.set(random.randrange(100, 200, 1)/10)\n        y.set(round(L()/2, 2))\n        d.set(random.randrange(3, 15, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        T = F()*y()\n        J = (math.pi/2)*(d()/2)**4\n        instr= ((T*d()/2)/J)/10**3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.2 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_3dynamicsubmit.html",
    "href": "problem6_3dynamicsubmit.html",
    "title": "Problem 6.3 - Torsional Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"273\"\nT1=reactive.Value(\"__\")\nT2=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two torques are applied to a two part circular rod as shown. If T&lt;sub&gt;1&lt;/sub&gt; = {T1()} kip-in., T&lt;sub&gt;2&lt;/sub&gt; = {T2()} kip-in., d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in., and d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in., what is the magnitude of the maximum shear stress?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T1.set(random.randrange(5, 50, 1))\n        T2.set(T1()*random.randrange(3, 5, 1)/10)\n        d1.set(random.randrange(40, 80, 1)/10)\n        d2.set(round(d1()*0.8, 2))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        F1 = -T1()+T2()\n        F2 = T2()\n        J1 = (math.pi/2)*(d1()/2)**4\n        J2 = (math.pi/2)*(d2()/2)**4\n        tau1 = abs(F1*d1()/2/J1)*1000\n        tau2 = abs(F2*d2()/2/J2)*1000\n        if tau1&gt;=tau2:\n            instr = tau1\n        else:\n            instr = tau2\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.3 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_4dynamicsubmit.html",
    "href": "problem6_4dynamicsubmit.html",
    "title": "Problem 6.4 - Torsional Stress",
    "section": "",
    "text": "Figure 1: Three belt pullets are connected to a solid shaft.\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"276\"\nd=reactive.Value(\"__\")\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Three belt pulleys are connected to a solid circular shaft of diameter d = {d()} in. that rotates freely at joints A and E. The pulleys are subjected to forces F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kips, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kips, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} kips. What is the maximum shear stress in the shaft between pulleys B and C?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(20, 40, 1)/10)\n        F1.set(random.randrange(20, 200, 2)/10)\n        F2.set(F1()/2)\n        F3.set(round(F1()*0.9, 2))\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        T = 6*F1()\n        instr= (T*(d()/2))/((math.pi/2)*(d()/2)**4)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.4 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_5dynamicsubmit.html",
    "href": "problem6_5dynamicsubmit.html",
    "title": "Problem 6.5 - Torsional Stress",
    "section": "",
    "text": "This is a dynamic rendering of the problem with dynamic variables based on the username entered.\n [Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"278\"\nro=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\nTB=reactive.Value(\"__\")\nTC=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two torques ,T&lt;sub&gt;B&lt;/sub&gt; = {TB()} kip-ft and T&lt;sub&gt;C&lt;/sub&gt; = {TC()} kip-ft, are applied to the hollow pipe as shown. If L = {L()} ft., r&lt;sub&gt;o&lt;/sub&gt; = {ro()} in., and r&lt;sub&gt;i&lt;/sub&gt; = {ri()} in., determine the maximum shear stress in the pipe.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        TB.set(random.randrange(100, 500, 100))\n        TC.set(TB()/2)\n        L.set(random.randrange(10, 90, 1)/10)\n        ro.set(random.randrange(15, 60, 1)/10)\n        ri.set(round(ro()*0.8))\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Tmax = (TB()-TC())*12\n        J = (math.pi/2)*(ro()**4 - ri()**4)\n        instr= (Tmax*ro())/J\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.5 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_6dynamicsubmit.html",
    "href": "problem6_6dynamicsubmit.html",
    "title": "Problem 6.6 - Torsional Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"281\"\ndo=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nT=reactive.Value(\"__\")\ntmax=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A hollow steel pole has an outer diameter d&lt;sub&gt;o&lt;/sub&gt; = {do()} in. and length L = {L()} ft. If the pole is subjected to torque T = {T()} lb-ft at its free end and the maximum shear stress, τ&lt;sub&gt;max&lt;/sub&gt;, is not to exceed {tmax()} psi, determine the maximum allowable inner diameter of the pole, d&lt;sub&gt;i&lt;/sub&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        do.set(random.randrange(40,100,1)/10)\n        L.set(random.randrange(15,50,1)/10)\n        T.set(random.randrange(350,750,10))\n        tmax.set(random.randrange(250,400,10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        r1 = ((do()/2)**4-2*T()*do()/2/(math.pi*tmax()))**0.25\n        instr = 2*r1\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.6 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_7dynamicsubmit.html",
    "href": "problem6_7dynamicsubmit.html",
    "title": "Problem 6.7 - Torsional Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"282\"\nL=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A bolt is tightened using a wrench of length L = {L()} mm and a force F = {F()} N. If the bolt has diameter d = {d()} mm and doesn't rotate, determine the maximum shear stress in the bolt.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(250,500,10))\n        F.set(random.randrange(75,200,1))\n        d.set(random.randrange(10,30,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        T = F()*L()/1000\n        J = math.pi*(d()/2000)**4/2\n        instr = T*d()/2000/J/1000000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.7 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_8dynamicsubmit.html",
    "href": "problem6_8dynamicsubmit.html",
    "title": "Problem 6.8 - Torsional Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"291\"\nd=reactive.Value(\"__\")\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A free rolling shaft of diameter d = {d()} in. supports three belt pulleys, subjected to forces F&lt;sub&gt;1&lt;/sub&gt; = {F1()} lb, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} lb, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} lb as shown. Determine the maximum shear stress in the shaft. Assume G = 4 x 10&lt;sup&gt;6&lt;/sup&gt; psi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(20,60,1)/10)\n        F1.set(random.randrange(25,100,1))\n        F2.set(random.randrange(20,100,1))\n        F3.set(random.randrange(30,100,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        TB = F1()*12\n        TC = -F2()*6\n        TD = F3()*10\n        TCD = TB+TC\n        TBC = TB\n        Force = max(TCD,TBC)\n        J = math.pi/2*(d()/2)**4\n        instr= Force*d()/2/J\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n            \n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.8 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_11dynamicsubmit.html",
    "href": "problem6_11dynamicsubmit.html",
    "title": "Problem 6.11 - Torsional Deformation",
    "section": "",
    "text": "Figure 1: A hollow copper rod is fixed to a wall at one end and a torque is applied\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"266\"\nL=reactive.Value(\"__\")\ndo=reactive.Value(\"__\")\ndi=reactive.Value(\"__\")\nangle=(reactive.Value(\"__\"))\nE = 110\nv = 0.33\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN-m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A hollow copper rod (E = 110 GPa, v = 0.33) is subjected to torque T as shown. If length L = {L()} m, outer diameter d&lt;sub&gt;o&lt;/sub&gt; = {do()} mm, and inner diameter d&lt;sub&gt;i&lt;/sub&gt; = {di()} mm, determine torque T if the rod twists {angle()}° .\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(5, 30, 1)/10)\n        do.set(random.randrange(50, 200, 1))\n        di.set(round(do()/2, 2))\n        angle.set(random.randrange(1, 10, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        G = E*10**9/(2*(1+v))\n        J = (math.pi/2)*((do()/2000)**4 -(di()/2000)**4 )\n        instr= ((math.radians(angle())*G*J)/L())/10**3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.11 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_12dynamicsubmit.html",
    "href": "problem6_12dynamicsubmit.html",
    "title": "Problem 6.12 - Torsional Deformation",
    "section": "",
    "text": "Figure 1: A bar is attached to a wall.\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"268\"\nT1=reactive.Value(\"__\")\nangle=reactive.Value(\"__\")\nG=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ft-lb\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A bar with a shear modulus G = {G()} x 10&lt;sup&gt;6&lt;/sup&gt; psi is subjected to torques T&lt;sub&gt;1&lt;/sub&gt; = {T1()} lb-ft at its center and T&lt;sub&gt;2&lt;/sub&gt; at its free end. The inner diamter is 1 in and the outer diameter is 2 in and the total length of the bar is 10 in. If the rotation of the rod at its free end is θ =  {angle()}° clockwise, what is the magnitude of torque T&lt;sub&gt;2&lt;/sub&gt;?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        G.set(random.randrange(90, 130, 1)/10)\n        T1.set(random.randrange(1000, 5000, 100))\n        angle.set(random.randrange(10, 50, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        ro = 2/2\n        ri = 1/2\n        J = math.pi/2*(ro**4-ri**4)\n        L1 = 10/2\n        L2 = 10/2\n        instr= abs((angle()*math.pi/180*G()*10**6*J+T1()*12*L1)/(L1+L2)/12)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.12 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_13dynamicsubmit.html",
    "href": "problem6_13dynamicsubmit.html",
    "title": "Problem 6.13 - Torsional Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"269\"\nT1=reactive.Value(\"__\")\nT2=reactive.Value(\"__\")\nT3=reactive.Value(\"__\")\nGs=77\nGa=27\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of degrees\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Three moments are applied to the system of cylinders as shown. Assume T&lt;sub&gt;1&lt;/sub&gt; = {T1()} kN-m, T&lt;sub&gt;2&lt;/sub&gt; = {T2()} kN-m, and T&lt;sub&gt;3&lt;/sub&gt; = {T3()} kN-m. If G&lt;sub&gt;steel&lt;/sub&gt; = 77 GPa and G&lt;sub&gt;aluminum&lt;/sub&gt; = 27 GPa, determine the total angle of twist at the free end.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T1.set(random.randrange(20, 100, 1)/10)\n        T2.set(T1()+random.randrange(20, 100, 1)/10)\n        T3.set(round(T2()*random.randrange(5, 8, 1)/10, 2))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        F1 = T1()+T2()-T3()\n        F2 = T2()-T3()\n        F3 = -T3()\n        J1 = (math.pi/2)*((5/200)**4)\n        J2 = (math.pi/2)*((3/200)**4)\n        J3 = (math.pi/2)*((4/200)**4)\n        instr= ((F1*1000*.1)/(J1*Gs*10**9) + (F2*1000*.15)/(J2*Ga*10**9) + (F3*1000*.08)/(J3*Gs*10**9))*180/math.pi\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.13 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_14dynamicsubmit.html",
    "href": "problem6_14dynamicsubmit.html",
    "title": "Problem 6.14 - Torsional Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"270\"\nL=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\nT=reactive.Value(\"__\")\nG=reactive.Value(\"__\")\nstress=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A circular rod of length L = {L()} mm, outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} mm, and unknown inner radius r&lt;sub&gt;i&lt;/sub&gt; has a shear modulus G = {G()} GPa. The rod is subjected to torque T = {T()} kN-m at the free end. If the angle of twist must not exceed 2° and the shear stress must not exceed {stress()} MPa, what is the minimum required inner radius?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(250, 500, 10))\n        ro.set(random.randrange(55, 75, 1))\n        G.set(random.randrange(60, 100, 1))\n        T.set(random.randrange(10, 100, 1)/10)\n        stress.set(random.randrange(75, 150, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        r1= ((ro()/1000)**4-(2*T()*1000*ro()/1000/(math.pi*stress()*10**6)))**0.25*1000\n        r2 = ((ro()/1000)**4-(2*T()*1000*L()/1000/(math.pi*G()*10**9*2*math.pi/180)))**0.25*1000\n        if r1&gt;r2:\n            instr = r2\n        else:\n            instr = r1\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.14 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_15dynamicsubmit.html",
    "href": "problem6_15dynamicsubmit.html",
    "title": "Problem 6.15 - Torsional Deformation",
    "section": "",
    "text": "Figure 1: A hollow circualr rod is attached to a wall and subjected to a torque at the free end.\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"274\"\nT=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\nG=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of degrees\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A hollow circular rod is attached to a wall and subjected to a torque T = {T()} kN-m at the free end.The rod has inner diameter 8 cm and outer diameter 10 cm.  Determine the angle of twist at x = {x()} mm. Assume G = {G()} GPa and L = {L()} mm.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T.set(random.randrange(20, 200, 1)/10)\n        G.set(random.randrange(30, 60, 1))\n        L.set(random.randrange(300, 800, 10))\n        x.set(L()*random.randrange(2,7,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        J = (math.pi/2)*((10/200)**4 - (8/200)**4)\n        angle = (T()*1000*x()/1000)/(G()*10**9*J)\n        instr= math.degrees(angle)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.15 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_16dynamicsubmit.html",
    "href": "problem6_16dynamicsubmit.html",
    "title": "Problem 6.16 - Torsional Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"275\"\nT1=reactive.Value(\"__\")\nT2=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of rad\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A rod is subjected to two torques, T&lt;sub&gt;1&lt;/sub&gt; = {T1()} kip-in. and T&lt;sub&gt;2&lt;/sub&gt; = {T2()} kip-in. as shown. The rod is hollow, with outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} in. and inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} in. If length L = {L()} in., determine the angle of twist at the free end. Assume E = 300 ksi and ν = 0.4.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T1.set(random.randrange(50,200,1))\n        T2.set(random.randrange(50,200,1))\n        ro.set(random.randrange(20,50,1)/10)\n        ri.set(ro()-random.randrange(5,10,1)/10)\n        L.set(random.randrange(5,20,1))\n    \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        G = 300000/(2*1.4)\n        J = math.pi/2*(ro()**4-ri()**4)\n        theta1 = -T1()*1000*L()/(G*J)\n        theta2 = T2()*1000*2*L()/(G*J)\n        instr = (theta1+theta2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.16 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_17dynamicsubmit.html",
    "href": "problem6_17dynamicsubmit.html",
    "title": "Problem 6.17 - Torsional Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"277\"\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of degrees\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A tire iron of length L = {L()} ft is used to tighten a nut on a tire as shown. The tire iron has diameter d = {d()} in, elastic modulus E = 29,000 ksi, and Poisson's ratio ν = 0.29. If load F = {F()} lb, determine the angle of twist in the tire iron before the nut rotates.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10,25,1)/10)\n        d.set(random.randrange(25,75,5)/100)\n        F.set(random.randrange(75,150,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        T = F()*L()*12\n        G = 29000000/(2*(1.29))\n        J = math.pi/2*(d()/2)**4\n        theta = T*L()*12/(G*J)\n        instr = theta*180/math.pi\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.17 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_18dynamicsubmit.html",
    "href": "problem6_18dynamicsubmit.html",
    "title": "Problem 6.18 - Torsional Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"279\"\nT=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of degrees\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A two part rod made of aluminum (E = 70 GPa, ν = 0.33) and brass (E = 100 GPa, ν = 0.34) is subjected to a torque T = {T()} N-m at its free end. If length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} mm and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} mm, and diameters d&lt;sub&gt;1&lt;/sub&gt; = {d1()} mm and d&lt;sub&gt;2&lt;/sub&gt; = {d2()} mm, determine the angle of twist of the free end.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T.set(random.randrange(250,900,10))\n        L2.set(random.randrange(200,500,10))\n        L1.set(round(L2()*1.4,1))\n        d2.set(random.randrange(30,60,2))\n        d1.set(d2()*1.5)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Ga = 70*10**9/(2*1.33)\n        Gb = 100*10**9/(2*1.34)\n        Ja = math.pi*(d1()/2000)**4/2\n        Jb = math.pi*(d2()/2000)**4/2\n        theta = T()*L1()/1000/(Ja*Ga)+T()*L2()/1000/(Jb*Gb)\n        instr = theta*180/math.pi\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.18 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_19dynamicsubmit.html",
    "href": "problem6_19dynamicsubmit.html",
    "title": "Problem 6.19 - Torsional Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"280\"\nL=reactive.Value(\"__\")\nangle=reactive.Value(\"__\")\ntmax=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"When a torque, T, is applied to a rod of length L = {L()} ft, it undergoes an angle of twist of {angle()}° before it fails due to shear stress. If the maximum shear stress in the bar is τ&lt;sub&gt;max&lt;/sub&gt; = {tmax()} ksi, determine the diameter of the rod. Assume G = 11,800 ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(25,100,1)/10)\n        angle.set(random.randrange(30,50,1))\n        tmax.set(random.randrange(20,40,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        r = tmax()*L()*12/(angle()*math.pi/180*11800)\n        instr = 2*r\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.19 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_20dynamicsubmit.html",
    "href": "problem6_20dynamicsubmit.html",
    "title": "Problem 6.20 - Torsional Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"283\"\na=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nangle=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of N\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A load F is applied to a bracket that is firmly attached a wall as shown. Assume distances a = {a()} mm and b = {b()} mm, and diameter d = {d()} mm. If the bracket rotates through Θ =  {angle()}°, determine the load F. Assume E = 200 GPa and ν = 0.29.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        a.set(random.randrange(50,100,1))\n        b.set(a()+random.randrange(30,60,1))\n        d.set(random.randrange(15,30,1))\n        angle.set(random.randrange(10,30,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        G = 200*10**9/(2*1.29)\n        J = math.pi/2*(d()/2000)**4\n        T = angle()*math.pi/180*J*G/(a()/1000)\n        instr= T/(b()/1000)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n            \n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.20 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_21dynamicsubmit.html",
    "href": "problem6_21dynamicsubmit.html",
    "title": "Problem 6.21 - Torsional Deformation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"285\"\nr=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\nT=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of rad\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A solid cylinder of radius r = {r()} mm is rigidly attached to a hollow cylinder of inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} mm and outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} mm to form a compact torsional spring. A torque T = {T()} N-m is applied at the free end. Determine the total rotation at the free end. Assume E = 200 GPa and ν = 0.29.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        r.set(random.randrange(10,20,1))\n        ri.set(r()+random.randrange(3,5,1))\n        ro.set(ri()+random.randrange(3,5,1))\n        T.set(random.randrange(500,1000,10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        G = 200*10**9/(2*1.29)\n        Jab = ((ro()/1000)**4-(ri()/1000)**4)*math.pi/2\n        Jbc = (r()/1000)**4*math.pi/2\n        instr= T()*0.05/(G*Jab)+T()*0.1/(G*Jbc)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n            \n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.21 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_22dynamicsubmit.html",
    "href": "problem6_22dynamicsubmit.html",
    "title": "Problem 6.22 - Power Transmission & Gear Assemblies",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"669\"\nP=reactive.Value(\"__\")\nrpm=reactive.Value(\"__\")\nT=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of N*m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The steel shaft is being turned by an electric motor providing {P()} kW of power at {rpm()} rpm. Power is extracted at B with a torque of {T()} N⸱m. Determine the remaining torque available for the gear at C.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        P.set(random.randrange(10, 30, 1))\n        rpm.set(random.randrange(60, 180, 5))\n        T.set(random.randrange(200, 400, 10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        TA = P()*1000/(2*math.pi*rpm()/60)\n        instr= TA-T()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.22 - Power Transmission & Gear Assemblies"
    ]
  },
  {
    "objectID": "problem6_23dynamicsubmit.html",
    "href": "problem6_23dynamicsubmit.html",
    "title": "Problem 6.23 - Power Transmission & Gear Assemblies",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"670\"\nhp=reactive.Value(\"__\")\nrpm=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of lb\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A lawnmower engine supplying {hp()} hp running at {rpm()} rpm is being used to power a homemade winch. Given the gearing shown, determine the heaviest load that can be lifted.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        hp.set(random.randrange(10, 50, 1)/10)\n        rpm.set(random.randrange(2000, 4000, 100))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        T = hp()*550/(2*math.pi*rpm()/60)*12\n        instr= T/0.5\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.23 - Power Transmission & Gear Assemblies"
    ]
  },
  {
    "objectID": "problem6_24dynamicsubmit.html",
    "href": "problem6_24dynamicsubmit.html",
    "title": "Problem 6.24 - Power Transmission and Gear Assemblies",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"671\"\nhp=reactive.Value(\"__\")\nr=reactive.Value(\"__\")\nW=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of rpm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A driver is attempting a burnout in a car with a {hp()}-hp engine and positraction (both rear wheels receive equal torque). If the tires have radius r = {r()} in., support a weight W = {W()} lb each, and have a static coefficient of friction of 0.85 with the pavement, determine the rpm of the engine when the tires slip and the burnout starts.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        hp.set(random.randrange(180,250,5))\n        r.set(random.randrange(130,200,5)/10)\n        W.set(random.randrange(600,1000,10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        F=0.85*W()\n        T=F*r()\n        Ttot=T*2/12\n        omega=hp()*550/Ttot\n        instr=60*omega/(2*math.pi)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.24 - Power Transmission and Gear Assemblies"
    ]
  },
  {
    "objectID": "problem6_26dynamicsubmit.html",
    "href": "problem6_26dynamicsubmit.html",
    "title": "Problem 6.26 - Torsional Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"303\"\nT=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN-m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two circular steel rods are firmly welded together and attached between two walls. A torque T = {T()} kN-m is applied as shown. If diameters d&lt;sub&gt;1&lt;/sub&gt; = {d1()} mm, d&lt;sub&gt;2&lt;/sub&gt; = {d2()} mm, and lengths L = {L()} m, determine the reaction at the right wall.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T.set(random.randrange(1,200,1))\n        d2.set(random.randrange(15,75,1))\n        d1.set(d2()+random.randrange(10,20,1))\n        L.set(random.randrange(10,100,1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        JAB = math.pi*(d1()/2000)**4/2\n        JBC=JAB\n        JCD = math.pi*(d2()/2000)**4/2\n        instr = (T()/JBC+T()/JCD)/(1/JAB+1/JBC+1/JCD)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.26 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_27dynamicsubmit.html",
    "href": "problem6_27dynamicsubmit.html",
    "title": "Problem 6.27 - Statically Indeterminate Torsion",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"287\"\nL=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nG = 75\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A steel rod of diameter d = {d()} mm is attached to walls A and C as shown. Two forces F = {F()} kN are applied at distance L = {L()} mm. If the shear modulus of the rod G = 75 GPa, determine the maximum shear stress in the rod.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(20, 60, 1))\n        F.set(random.randrange(2, 20, 1))\n        L.set(random.randrange(80, 120, 1))\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        TB = 2*F()*L()\n        J = (math.pi/2)*(d()/2000)**4\n        TA = 0.3/0.7*TB\n        TC = TB-TA\n        instr= ((TC*(d()/2000))/J)/10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.27 - Statically Indeterminate Torsion"
    ]
  },
  {
    "objectID": "problem6_28dynamicsubmit.html",
    "href": "problem6_28dynamicsubmit.html",
    "title": "Problem 6.28 - Statically Indeterminate Torsion",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"288\"\nT=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nG1=reactive.Value(\"__\")\nG2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A composite circular rod is made from two different plastics. A torque of T = {T()} kN-m is applied at the midpoint. The right end is free. What is the maximum stress in either material? Assume length L = {L()} cm and the shear modulus of the two materials are G&lt;sub&gt;1&lt;/sub&gt; = {G1()} GPa and G&lt;sub&gt;2&lt;/sub&gt; = {G2()} GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T.set(random.randrange(10, 200, 1)/10)\n        L.set(random.randrange(10, 50, 1))\n        G1.set(random.randrange(20, 50, 2)/10)\n        G2.set(G1()/2)\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        J1 = (math.pi/2)*(2/100)**4\n        J2 = (math.pi/2)*((3/100)**4-(2/100)**4)\n        RHS = G1()*10**9*J1+G2()*10**9*J2\n        LHS = T()*G2()*10**9*J2\n        T2 = LHS/RHS\n        T1 = T()-T2\n        instr= ((T1*(2/100))/J1)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.28 - Statically Indeterminate Torsion"
    ]
  },
  {
    "objectID": "problem6_29dynamicsubmit.html",
    "href": "problem6_29dynamicsubmit.html",
    "title": "Problem 6.29 - Statically Indeterminate Torsion",
    "section": "",
    "text": "Figure 1: A composite circular rod is made from aluminum and steel.\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"289\"\nT = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\nro = reactive.Value(\"__\")\nri = reactive.Value(\"__\")\nGA = 3800000\nGS = 11000000\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\n        \"**Please enter your ID number from your instructor and click to generate your problem**\"\n    ),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\n        \"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"\n    ),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\n        \"answer\", \"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"\n    ),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A composite circular rod is made from aluminum (G = 3,800 ksi) and steel (G = 11,000 ksi) as shown. A torque T = {T()} lb-ft is applied to the free end. What is the maximum stress in either material? Assume length L = {L()} in., outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} in., and inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} in.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T.set(random.randrange(300, 2000, 100))\n        L.set(random.randrange(10, 60, 1))\n        ro.set(random.randrange(10, 60, 1) / 10)\n        ri.set(round(ro() / 1.5, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        JS = math.pi * ri() ** 4 / 2\n        JA = math.pi / 2 * (ro() ** 4 - ri() ** 4)\n        TA = T() * 12 * GA * JA / (GS * JS + GA * JA)\n        TS = T() * 12 - TA\n        instr = TS * ri() / JS / 1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(\n            f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\"\n        )\n\n        # Show feedback to the user.\n        feedback = ui.markdown(\n            f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = (\n            session.encoded_attempt()\n            if session.encoded_attempt is not None\n            else \"No attempts\"\n        )\n        yield f\"{final_encoded}\\n\\n\"\n\n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n\n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(\n                0.25\n            )  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.29 - Statically Indeterminate Torsion"
    ]
  },
  {
    "objectID": "problem6_30dynamicsubmit.html",
    "href": "problem6_30dynamicsubmit.html",
    "title": "Problem 6.30 - Statically Indeterminate Torsion",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"292\"\nT=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nGn = 11.4e6\nGa = 4e6\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A shaft is fixed between two walls. One portion is made from nickel (G&lt;sub&gt;nickel&lt;/sub&gt; = 11.4 x 10&lt;sup&gt;6&lt;/sup&gt; psi) with a diameter of d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in. The other portion is aluminum (G&lt;sub&gt;aluminum&lt;/sub&gt; = 4 x 10&lt;sup&gt;6&lt;/sup&gt; psi) with a diameter of d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in. A torque T = {T()} lb-ft is applied at the point where the two materials meet. If lengths L&lt;sub&gt;1&lt;/sub&gt; = {L1()} ft and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} ft, what is the maximum shear stress in the shaft?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d1.set(random.randrange(10, 60, 1)/10)\n        d2.set(round(d1()*2, 2))\n        T.set(random.randrange(500, 2000, 100))\n        L1.set(random.randrange(4, 20, 2))\n        L2.set(L1()/2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Jn = (math.pi/2)*(d1()/2)**4\n        Ja = (math.pi/2)*(d2()/2)**4\n        TN = T()*12*L2()*12*Gn*Jn/(L1()*12*Ga*Ja+L2()*12*Gn*Jn)\n        TA = T()*12-TN\n        tauA = TA*d2()/2/Ja\n        tauN = TN*d1()/2/Jn\n        if tauA&gt;=tauN:\n            instr = tauA\n        else:\n            instr = tauN\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.30 - Statically Indeterminate Torsion"
    ]
  },
  {
    "objectID": "problem6_31dynamicsubmit.html",
    "href": "problem6_31dynamicsubmit.html",
    "title": "Problem 6.31 - Statically Indeterminate Torsion",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"293\"\nT=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nG = 80\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two steel (G = 80 GPa) circular rods are firmly welded together and attached between two walls. Assume d&lt;sub&gt;1&lt;/sub&gt; = {d1()} mm, d&lt;sub&gt;2&lt;/sub&gt; = {d2()} mm, and L  = {L()} mm. A torque T = {T()} N-m is applied at the welded joint as shown. What is the highest stress in either rod?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d1.set(random.randrange(20, 50, 1))\n        d2.set(round(d1()*.8, 2))\n        L.set(random.randrange(100, 800, 10))\n        T.set(random.randrange(10, 300, 5))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        J1 = (math.pi/2)*(d1()/2000)**4\n        J2 = (math.pi/2)*(d2()/2000)**4\n        RHS = J1/J2\n        Tb = (T()/(RHS+1))\n        Ta = T() - Tb\n        tauA = (Ta*d1()/2000/J1)/10**6\n        tauB = (Tb*d2()/2000/J2)/10**6\n        if tauA&gt;=tauB:\n            instr = tauA\n        else:\n            instr = tauB\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.31 - Statically Indeterminate Torsion"
    ]
  },
  {
    "objectID": "problem6_32dynamicsubmit.html",
    "href": "problem6_32dynamicsubmit.html",
    "title": "Problem 6.32 - Statically Indeterminate Torsion",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"294\"\nF=reactive.Value(\"__\")\ndi=reactive.Value(\"__\")\ndo=reactive.Value(\"__\")\na=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A load F = {F()} kN is applied to a bracket that is firmly attached to a wall. The rod is composed of a solid steel (G = 80 GPa) inner rod of diameter d&lt;sub&gt;i&lt;/sub&gt; = {di()} mm rigidly bonded to a copper (G = 48 GPa) outer casing of diameter d&lt;sub&gt;o&lt;/sub&gt; = {do()} mm. Determine the maximum shear stress in either material. Assume dimensions a = {a()} mm and b = {b()} mm.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(10,50,1)/10)\n        di.set(random.randrange(25,40,1))\n        do.set(di()+random.randrange(5,15,1))\n        a.set(random.randrange(100,200,1))\n        b.set(a()+random.randrange(30,60,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Jc = ((do()/2000)**4-(di()/2000)**4)*math.pi/2\n        Js = (di()/2000)**4*math.pi/2\n        T = F()*1000*b()/1000\n        Gc = 48*10**9\n        Gs = 80*10**9\n        TS = T/(Jc*Gc)/(1/(Js*Gs)+1/(Jc*Gc))\n        TC = T-TS\n        tauS = TS*b()/1000/Js\n        tauC = TC*do()/2000/Jc\n        instr= max(tauS,tauC)/1000000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n            \n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.32 - Statically Indeterminate Torsion"
    ]
  },
  {
    "objectID": "problem6_33dynamicsubmit.html",
    "href": "problem6_33dynamicsubmit.html",
    "title": "Problem 6.33 - Statically Indeterminate Torsion",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"296\"\nL=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nT=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of rad\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Three circular rods, each of length L = {L()} in., are mounted between two fixed walls. The two brass (E = 15,000 ksi, ν = 0.34) rods have diameter d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in. The copper (E = 19,000 ksi, ν = 0.33) rod has diameter d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in. A torque T = {T()} kip-in. is applied at the center. determine the angle of twist of point B with respect to point A.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(5,20,1))\n        d2.set(random.randrange(5,25,1)/10)\n        d1.set(d2()*2)\n        T.set(random.randrange(10,100,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Jb = math.pi*(d1()/2)**4/2\n        Jc = math.pi*(d2()/2)**4/2\n        Gb = 15000000/(2*1.34)\n        Gc = 19000000/(2*1.33)\n        TB = T()*1000/2\n        TC = TB        \n        instr= TB*L()/(Gb*Jb)+TC*L()/(Gc*Jc)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n            \n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.33 - Statically Indeterminate Torsion"
    ]
  },
  {
    "objectID": "problem6_34dynamicsubmit.html",
    "href": "problem6_34dynamicsubmit.html",
    "title": "Problem 6.34 - Statically Indeterminate Torsion",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"301\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nangle=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of lb-in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A steel (G = 12,700 ksi) rod and an aluminum (G = 4,300 ksi) rod are attached firmly between two walls as shown. The lengths are L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in., while the diameters are d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in. and d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in. A torque T is applied at the joint between ther rods and it is measureed that the joint rotates {angle()}°. Determine the magnitude of torque T.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(5,25,1))\n        L2.set(L1()+random.randrange(2,5,1))\n        d2.set(random.randrange(50,300,5)/100)\n        d1.set(d2()+random.randrange(25,100,5)/100)\n        angle.set(random.randrange(10,50,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Js = math.pi*(d2()/2)**4/2\n        Jal = math.pi*(d1()/2)**4/2\n        Ts = angle()*math.pi/180*Js*12700000/L2()\n        Tal = angle()*math.pi/180*Jal*4300000/L1()\n        instr= Ts+Tal\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n            \n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.34 - Statically Indeterminate Torsion"
    ]
  },
  {
    "objectID": "problem7_1dynamicsubmit.html",
    "href": "problem7_1dynamicsubmit.html",
    "title": "Problem 7.1 - Internal Shear Force & Bending Moment by Equilibrium",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"305\"\nw = reactive.Value(\"__\")\nF = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your internal shear force answer in units of lb\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your moment answer in units of lb-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A beam is subjected to the loading shown, where w = {w()} lb/ft and F = {F()} lb. Determine the internal shear force and bending moment at section a-a.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(5, 150, 5))\n        F.set(random.randrange(300, 750, 10))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        Ay = (F()*2 - w()*6*3) / -6\n        instr1 = Ay - w()*3\n        instr2 = Ay*3 - w()*3*1.5\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.1 - Internal Shear Force & Bending Moment by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_2dynamicsubmit.html",
    "href": "problem7_2dynamicsubmit.html",
    "title": "Problem 7.2 - Internal Shear Force & Bending Moment by Equilibrium",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"306\"\nw=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN-m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is subjected to the loading shown, where w = {w()} kN/m and L = {L()} m. What is the internal bending moment at section a-a at x = {x()} m?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(20, 200, 1)/20)\n        L.set(random.randrange(20, 50, 2)/10)\n        x.set(L()/2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= w()*L()*x()-w()*L()**2-w()*x()**3/(6*L())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.2 - Internal Shear Force & Bending Moment by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_3dynamicsubmit.html",
    "href": "problem7_3dynamicsubmit.html",
    "title": "Problem 7.3 - Internal Shear Force & Bending Moment by Equilibrium",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"309\"\nF1 = reactive.Value(\"__\")\nF2 = reactive.Value(\"__\")\nF3 = reactive.Value(\"__\")\nΘ = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your internal shear force answer in units of lb\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your moment answer in units of lb-in\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"Three loads are applied to the structure as shown, where F&lt;sub&gt;1&lt;/sub&gt; = {F1()} lb., F&lt;sub&gt;2&lt;/sub&gt; = {F2()} lb., and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} lb applied at an angle Θ = {Θ()} °. Determine the internal shear force and bending moment at section aa.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(10, 30, 1))\n        F2.set(random.randrange(10, 30, 1))\n        F3.set(random.randrange(10, 30, 1))\n        Θ.set(random.randrange(45, 55, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = -F3() + F3()*math.sin(math.radians(Θ()))\n        instr2 = 2*F1() - 2*F2() - 4*F3()*math.sin(math.radians(Θ()))\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.3 - Internal Shear Force & Bending Moment by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_4dynamicsubmit.html",
    "href": "problem7_4dynamicsubmit.html",
    "title": "Problem 7.4 - Internal Shear Force & Bending Moments by Equilibrium",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"311\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\ntheta=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of lb-in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown, where loads F&lt;sub&gt;1&lt;/sub&gt; = {F1()} lb, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} lb, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} lb. Angle  Θ = {theta()}°. Determine the magnitude of the internal bending moment at section aa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(10,100,1))\n        F2.set(random.randrange(10,100,1))\n        F3.set(random.randrange(10,100,1))\n        theta.set(random.randrange(35,55,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        \n        instr = -F1()*4+F2()*10-F3()*math.cos(theta()*math.pi/180)*3-F3()*math.sin(theta()*math.pi/180)*6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.4 - Internal Shear Force & Bending Moments by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_5dynamicsubmit.html",
    "href": "problem7_5dynamicsubmit.html",
    "title": "Problem 7.5 - Internal Shear Force & Bending Moments by Equilibrium",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"312\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of N-m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown, where loads F&lt;sub&gt;1&lt;/sub&gt; = {F1()} N, and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} N. Lengths L&lt;sub&gt;1&lt;/sub&gt; = {L1()} mm and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} mm. Determine the magnitude of the internal bending moment at section aa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(100,900,10))\n        F2.set(random.randrange(100,900,10))\n        L1.set(random.randrange(300,800,10))\n        L2.set(L1()*2)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        \n        instr = -F1()*L1()/1000-F2()*L2()/1000*math.cos(45*math.pi/180)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.5 - Internal Shear Force & Bending Moments by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_6dynamicsubmit.html",
    "href": "problem7_6dynamicsubmit.html",
    "title": "Problem 7.6 - Internal Shear Force & Bending Moments by Equilibrium",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"313\"\nwo=reactive.Value(\"__\")\na=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of lb-in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam with the profile shown is loaded with a linear distributed load as shown, where w&lt;sub&gt;0&lt;/sub&gt; = {wo()} lb/in. If distances a = {a()} in. and b = {b()} in., determine the internal bending moment at section aa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        wo.set(random.randrange(100,1000,10))\n        a.set(random.randrange(5,20,1))\n        b.set(a()-random.randrange(1,2,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        \n        instr = 0.5*wo()*2*b()*b()/3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.6 - Internal Shear Force & Bending Moments by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_7dynamicsubmit.html",
    "href": "problem7_7dynamicsubmit.html",
    "title": "Problem 7.7 - Internal Shear Force & Bending Moments by Equilibrium",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"316\"\nr=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN-m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown, where radius r = {r()} m, length L = {L()} m, and distributed load w = {w()} kN/m. Determine the internal bending moment at section aa (half way between B and C).\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        r.set(random.randrange(5,20,1)/10)\n        L.set(round(r())*random.randrange(10,20,1)/10)\n        w.set(random.randrange(1,30,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Cy = w()*L()/2\n        instr = Cy*L()/2-w()*L()/2*L()/4\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.7 - Internal Shear Force & Bending Moments by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_8dynamicsubmit.html",
    "href": "problem7_8dynamicsubmit.html",
    "title": "Problem 7.8 - Internal Shear Force & Bending Moments by Equilibrium",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"317\"\nF=reactive.Value(\"__\")\nM=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nL3=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN-m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown, where loads F = {F()} kN, and M = {M()} kN-m. If lengths L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m, L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m, and L&lt;sub&gt;3&lt;/sub&gt; = {L3()} m, determine the magnitude of the internal bending moment at section aa (half way between points A and B).\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(1,20,1))\n        M.set(random.randrange(1,20,1))\n        L1.set(random.randrange(10,20,1)/10)\n        L2.set(L1()*2)\n        L3.set(L2()+random.randrange(5,15,1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Cy = -M()/L2()\n        By = Cy+F()\n        instr = -By*L1()/2\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.8 - Internal Shear Force & Bending Moments by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_14dynamicsubmit.html",
    "href": "problem7_14dynamicsubmit.html",
    "title": "Problem 7.14 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"318\"\nw = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your internal shear force answer in units of kip\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your moment answer in units of kip-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"Plot the shear force and bending moment diagrams for the loading shown. Assume w = {w()} kip/ft and L = {L()} ft. What is the maximum absolute shear force and maximum absolute bending moment?\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(30, 200, 1)/10)\n        L.set(random.randrange(40, 100, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = 3/4*w()*L()\n        instr2 = instr1**2/(2*w())\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n            \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.14 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_15dynamicsubmit.html",
    "href": "problem7_15dynamicsubmit.html",
    "title": "Problem 7.15 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"320\"\nM=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\",\"Maximum absolute shear force in units of kip\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\",\"Maximum absolute bending moment in units of kip-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n    \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Plot the shear force and bending moment diagrams for the loading shown. Assume M = {M()} kip-ft, L&lt;sub&gt;1&lt;/sub&gt; = {L1()} ft, and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} ft. What is the maximum absolute shear force and maximum absolute bending moment? \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        M.set(random.randrange(5, 80, 1))\n        L1.set(random.randrange(30, 100, 1)/10)\n        L2.set(round(L1()*4/3,1))\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1= abs(M()/L2())\n        instr2 = M()\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n            \napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.15 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_16dynamicsubmit.html",
    "href": "problem7_16dynamicsubmit.html",
    "title": "Problem 7.16 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"322\"\nw=reactive.Value(\"__\")\nM=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\",\"Maximum absolute shear force in units of lb\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\",\"Maximum absolute bending moment in units of lb-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n    \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Plot the shear force and bending moment diagrams for the loading shown. Assume w = {w()} lb/ft, M = {M()} lb-ft, and L = {L()} ft. What is the maximum absolute shear force and maximum absolute bending moment? \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10, 100, 1))\n        M.set(random.randrange(100, 3300, 10))\n        L.set(random.randrange(5, 15, 1))\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        By = (M()+w()*L()*1.5*L())/L()\n        Ay = w()*L()-By\n        Vm1 = abs(Ay)\n        Vm2 = abs(Ay+By)\n        if Vm1&gt;=Vm2:\n            instr1 = Vm1\n        else:\n            instr1 = Vm2\n        Mm1 = abs(M())\n        Mm2 = abs(M()-((M()+w()*L()*3*L()/2)/L()-w()*L())*L())\n        if Mm1&gt;=Mm2:\n            instr2 = Mm1\n        else:\n            instr2 = Mm2\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.16 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_17dynamicsubmit.html",
    "href": "problem7_17dynamicsubmit.html",
    "title": "Problem 7.17 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"323\"\nw1=reactive.Value(\"__\")\nw2=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN-m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown, where w&lt;sub&gt;1&lt;/sub&gt; = {w1()} kN/m and w&lt;sub&gt;2&lt;/sub&gt; = {w2()} kN/m. If length L = {L()} m, plot the shear force and bending moment diagrams and determine the magnitude of the maximum absolute bending moment.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w1.set(random.randrange(10,100,1)/10)\n        w2.set(w1()+random.randrange(10,50,1)/10)\n        L.set(random.randrange(20,100,1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Ay = (w1()*L()*1.5*L()-w2()*L()*L()/2)/(2*L())\n        Cy = -w1()*L()-Ay+w2()*L()\n        x = (Cy-2*L()*w2())/(-w2())\n        instr = -w2()*x**2/2+2*L()*x*w2()-2*L()**2*w2()+2*Cy*L()-Cy*x\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.17 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_18dynamicsubmit.html",
    "href": "problem7_18dynamicsubmit.html",
    "title": "Problem 7.18 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"324\"\nw=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN-m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown, where w = {w()} kN/m. If lengths L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m, plot the shear force and bending moment diagrams and determine the magnitude of the maximum absolute bending moment.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10,300,1)/10)\n        L1.set(random.randrange(20,80,1)/10)\n        L2.set(L1()*2)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Ay = w()*L2()*L2()/2/(L1()+L2())\n        x = (Ay+w()*L2()/2)/w()\n        instr = -w()*x**2/2+w()/2*x*L2()+Ay*x-w()*L2()**2/8\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.18 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_19dynamicsubmit.html",
    "href": "problem7_19dynamicsubmit.html",
    "title": "Problem 7.19 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"325\"\nw = reactive.Value(\"__\")\nM = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of kN\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of kN-m\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"Plot the shear force and bending moment diagrams for the loading shown. Assume w = {w()} kN/m, M = {M()} kN-m, and L = {L()} m. What is the maximum absolute shear force and maximum absolute bending moment?.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(5,30,1))\n        M.set(random.randrange(5,30,1))\n        L.set(random.randrange(20,50,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        instr1 = w()*L()/2\n        instr2 = M()\n              \n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.19 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_20dynamicsubmit.html",
    "href": "problem7_20dynamicsubmit.html",
    "title": "Problem 7.20 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"327\"\nw = reactive.Value(\"__\")\nF = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of lb\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of lb-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"Plot the shear force and bending moment diagrams for the loading shown. Assume w = {w()} lb/ft, F = {F()} lb, and L = {L()} ft. What is the maximum absolute shear force and maximum absolute bending moment?\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(30,100,1))\n        F.set(random.randrange(100,300,10))\n        L.set(random.randrange(20,50,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        instr1 = F()\n        instr2 = w()*L()*L()/2-F()*2*L()\n              \n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.20 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_21dynamicsubmit.html",
    "href": "problem7_21dynamicsubmit.html",
    "title": "Problem 7.21 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"329\"\nF = reactive.Value(\"__\")\nM = reactive.Value(\"__\")\nb = reactive.Value(\"__\")\na = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of lb\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of lb-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"Plot the shear force and bending moment diagrams for the loading shown. Assume loads F = {F()} lb and M = {M()} lb-ft, and lengths a = {a()} ft and b = {b()} ft. What is the maximum absolute shear force and maximum absolute bending moment?.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(50,200,5))\n        M.set(random.randrange(250,500,10))\n        b.set(random.randrange(50,100,1)/10)\n        a.set(b()+round(random.randrange(10,20,1)/10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        instr1 = F()\n        instr2 = F()*a()+M()\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.21 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_22dynamicsubmit.html",
    "href": "problem7_22dynamicsubmit.html",
    "title": "Problem 7.22 - Determining Equations by Integration",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"672\"\nw1 = reactive.Value(\"__\")\nw2 = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of kN\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of kN-m\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A simply supported beam supports a trapezoidal load function with ω&lt;sub&gt;1&lt;/sub&gt; = {w1()} kN/m and ω&lt;sub&gt;2&lt;/sub&gt; = {w2()} kN/m. For a bem length L = {L()} m, derive the equations for beam shear, V(x), and bending moment, M(x). Determine the maximum magnitude for each.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w1.set(random.randrange(30,60,1))\n        w2.set(w1()-random.randrange(10,20,1))\n        L.set(random.randrange(5,15,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        C1=w1()*L()/3+w2()*L()/6  \n        instr1 = C1\n        x=(w1()-math.sqrt(w1()**2-4*(w1()/(2*L())-w2()/(2*L()))*C1))/(2*(w1()/(2*L())-w2()/(2*L())))            \n        instr2 = -w1()*x**2/2+w1()*x**3/(6*L())-w2()*x**3/(6*L())+C1*x\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.22 - Determining Equations by Integration"
    ]
  },
  {
    "objectID": "problem7_23dynamicsubmit.html",
    "href": "problem7_23dynamicsubmit.html",
    "title": "Problem 7.23 - Determining Equations by Integration",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"673\"\nt = reactive.Value(\"__\")\nw = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of lb\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of lb-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A parabolic arch is formed by the simply-supported precast concrete piece shown. Assuming the concrete has a thickness t = {t()} inches and a unit weight w = {w()} lb per cubic foot, derive the equations for beam shear, V(x) and bending moment, M(x), in the concrete. Determine the maximum magnitude for each. The height of the arch, in feet, is given by the equation h(x) = 1/144*x&lt;sup&gt;2&lt;/sup&gt; - 1/6*x + 2.5.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        t.set(random.randrange(6,18,1))\n        w.set(random.randrange(125,175,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        L=24\n        wxa=-1/144*t()*w()\n        wxb=1/6*t()*w()\n        wxc=-2.5*t()*w()\n        x=L/2\n        instr1=1/L*(-wxa/12*L**4-wxb/6*L**3-wxc/2*L**2)\n        instr2=wxa/12*x**4+wxb/6*x**3+wxc/2*x**2+instr1*x\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check} For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.23 - Determining Equations by Integration"
    ]
  },
  {
    "objectID": "problem7_24dynamicsubmit.html",
    "href": "problem7_24dynamicsubmit.html",
    "title": "Problem 7.24 - Determining Equations by Integration",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"674\"\nw = reactive.Value(\"__\")\nh = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of lb\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of lb-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"The preliminary design of tall buldings often starts by considering the building as a vertical cantilever subject to a code-defined quadratic wind pressure profile. Determine the shear and moment equations for a building of width w = {w()} ft and height h = {h()} ft and then determine the magnitude of the shear force and bending moment at the mid-height of the building.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(100,200,5))\n        h.set(random.randrange(100,300,10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        wxa=-0.000187*-w()\n        wxb=0.145*-w()\n        wxc=19.63*-w()\n        C1=-wxa/3*h()**3-wxb/2*h()**2-wxc*h()\n        C2=-wxa/12*h()**4-wxb/6*h()**3-wxc/2*h()**2-C1*h()\n        x=h()/2\n        instr1=wxa/3*x**3+wxb/2*x**2+wxc*x+C1\n        instr2=wxa/12*x**4+wxb/6*x**3+wxc/2*x**2+C1*x+C2\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check} For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.24 - Determining Equations by Integration"
    ]
  },
  {
    "objectID": "problem7_25dynamicsubmit.html",
    "href": "problem7_25dynamicsubmit.html",
    "title": "Problem 7.25 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"321\"\nW1=reactive.Value(\"__\")\nW2=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of lb\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A shelf is loaded with four boxes as shown. Assume W&lt;sub&gt;1&lt;/sub&gt; = {W1()} lb, W&lt;sub&gt;2&lt;/sub&gt; = {W2()} lb, and L = {L()} ft. Determine the maximum internal shear force.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W1.set(random.randrange(5,75,1))\n        W2.set(W1()*2)\n        L.set(random.randrange(10,50,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        R2 = (-W1()*L()/2+W2()*L()/2+W1()*1.5*L()+W2()*2.5*L())/(2*L())\n        R1 = 2*W1()+2*W2()-R2\n        V1 = -W1()\n        V2 = V1+R1\n        V3 = V2-W2()\n        V4 = V3-W1()\n        V5 = V4+R2\n        instr = max(abs(V1), abs(V2), abs(V3), abs(V4), abs(V5))\n\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.25 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_26dynamicsubmit.html",
    "href": "problem7_26dynamicsubmit.html",
    "title": "Problem 7.26 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"330\"\nw=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\",\"Maximum absolute shear force in units of kN\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\",\"Maximum absolute bending moment in units of kN-m\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n    \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Plot the shear force and bending moment diagrams for the loading shown. Assume w = {w()} kN/m, L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m, and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m. What is the maximum absolute shear force and maximum absolute bending moment? \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10, 75, 1))\n        L2.set(random.randrange(10, 50, 1)/10)\n        L1.set(round(L2()*3,1))\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1= abs((w()*(L1()+L2())-((L1()+L2())/2*w()*(L1()+L2()))/L1())-w()*L1())\n        instr2 = abs((w()*(L1()+L2())-((L1()+L2())/2*w()*(L1()+L2()))/L1())**2/(2*w()))\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.26 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_27dynamicsubmit.html",
    "href": "problem7_27dynamicsubmit.html",
    "title": "Problem 7.27 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"332\"\nw=reactive.Value(\"__\")\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown. Determine the distance from point A to where the internal shear force is zero. Assume w = {w()} kN/m, F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN, and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(2,10,1))\n        F1.set(w()*random.randrange(15,25,1)/10)\n        F2.set(random.randrange(5,25,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr = F1()*3/(w()*3)\n\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.27 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_28dynamicsubmit.html",
    "href": "problem7_28dynamicsubmit.html",
    "title": "Problem 7.28 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"333\"\nw1=reactive.Value(\"__\")\nw2=reactive.Value(\"__\")\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\",\"Maximum absolute shear force in units of kN\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\",\"Maximum absolute bending moment in units of kN-m\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n    \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Plot the shear force and bending moment diagrams for the loading shown. Assume w&lt;sub&gt;1&lt;/sub&gt; = {w1()} kN/m, and w&lt;sub&gt;2&lt;/sub&gt; = {w2()} kN/m. What is the maximum absolute shear force and maximum absolute bending moment? \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w2.set(random.randrange(10, 50, 1))\n        w1.set(w2()*5)\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1= abs(0.4*w2())\n        instr2 = abs(0.4*w2()*0.4*0.5 + 0.4*w2()*0.1*0.5)\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n            \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.28 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_29dynamicsubmit.html",
    "href": "problem7_29dynamicsubmit.html",
    "title": "Problem 7.29 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"334\"\nw1=reactive.Value(\"__\")\nw2=reactive.Value(\"__\")\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\",\"Maximum absolute shear force in units of kip\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\",\"Maximum absolute bending moment in units of kip-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n    \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Plot the shear force and bending moment diagrams for the loading shown. Assume w&lt;sub&gt;1&lt;/sub&gt; = {w1()} kip/ft and w&lt;sub&gt;2&lt;/sub&gt; = {w2()} kip/ft. What is the maximum absolute shear force and maximum absolute bending moment?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w1.set(random.randrange(10, 300, 1)/10)\n        w2.set(w1()*2)\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        By = 13*(w2()-w1())/30+6.5*w1()\n        Cy = 13*w1()+13*(w2()-w1())/2-By\n     #   instr1= abs(By+Cy-9*w1()-162/(13*(w2()-w1())))\n     #   instr2 = abs(5*By-81*w1()/2-486/(13*(w2()-w1())))\n        instr1 = max(5.1854*w1(), Cy-5.1854*w1())\n        instr2 = 15.17*w1()\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.29 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_30dynamicsubmit.html",
    "href": "problem7_30dynamicsubmit.html",
    "title": "Problem 7.30 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"336\"\nw = reactive.Value(\"__\")\nF1 = reactive.Value(\"__\")\nF2 = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of kip\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of kip-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"Plot the shear force and bending moment diagrams for the loading shown. Assume w = {w()} kip/ft, F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kip, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kip, and L = {L()} ft. What is the maximum absolute shear force and maximum absolute bending moment?.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10,100,1)/10)\n        F1.set(random.randrange(100,200,1)/10)\n        F2.set(random.randrange(100,200,1)/10)\n        L.set(random.randrange(20,50,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        instr1 = w()*2*L()-F1()-F2()\n        instr2 = F1()*F1()/w()-w()/2*(F1()/w())**2\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.30 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_31dynamicsubmit.html",
    "href": "problem7_31dynamicsubmit.html",
    "title": "Problem 7.31 - Graphical methods for shear force & bending moment diagrams",
    "section": "",
    "text": "{fig-alt=” A beam of length a+2b is subjected to a distributed load, w, over a distance a. The beam has pin supports a distance of a, and a+b from the left end of the beam. “} [Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"337\"\nw = reactive.Value(\"__\")\nb = reactive.Value(\"__\")\na = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of kN\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of kN-m\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"Plot the shear force and bending moment diagrams for the loading shown. Assume w = {w()} kN/m, a = {a()} m, and b = {b()} m. What is the maximum absolute shear force and maximum absolute bending moment?\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10,100,1)/10)\n        b.set(random.randrange(50,100,1)/10)\n        a.set(b()+round(random.randrange(10,20,1)/10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        FB = w()*(a()+b())*(a()+b())/2/a()\n        FA = FB-w()*(a()+b())\n        instr1 = max(abs(FA-w()*a()),FA-w()*a()+FB)\n        instr2 = abs(FA*a()-w()*a()**2/2)\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.31 - Graphical methods for shear force & bending moment diagrams"
    ]
  },
  {
    "objectID": "problem7_32dynamicsubmit.html",
    "href": "problem7_32dynamicsubmit.html",
    "title": "Problem 7.32 - Graphical methods for shear force & bending moment diagrams",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"338\"\nw = reactive.Value(\"__\")\nF1 = reactive.Value(\"__\")\nF2 = reactive.Value(\"__\")\nb = reactive.Value(\"__\")\na = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of lb\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of lb-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"Plot the shear force and bending moment diagrams for the loading shown. Assume w = {w()} lb/ft, F&lt;sub&gt;1&lt;/sub&gt; = {F1()} lb, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} lb, a = {a()} ft, and b = {b()} ft. What is the maximum absolute shear force and maximum absolute bending moment?\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(100,300,5))\n        F1.set(random.randrange(500,1000,10))\n        F2.set(random.randrange(500,1000,10))\n        b.set(random.randrange(20,50,1)/10)\n        a.set(b()+round(random.randrange(10,20,1)/10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        RD = (w()*a()*a()/2+F1()*a()+F2()*(a()+b()))/(a()+2*b())\n        RA = (w()*a()*(2*b()+a()/2)+F1()*2*b()+F2()*b())/(a()+2*b())\n        instr1 = max(RD,RA)\n        instr2 = RA*a()-w()*a()*a()/2\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.32 - Graphical methods for shear force & bending moment diagrams"
    ]
  },
  {
    "objectID": "problem7_33dynamicsubmit.html",
    "href": "problem7_33dynamicsubmit.html",
    "title": "Problem 7.33 - Graphical methods for shear force & bending moment diagrams",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"340\"\nw0 = reactive.Value(\"__\")\na = reactive.Value(\"__\")\nb = reactive.Value(\"__\")\nc = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of kip\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of kip-in\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"The lift of an aircraft can be modeled as a beam with distributed loads as shown, where w&lt;sub&gt;0&lt;/sub&gt; = {w0()} lb/in. The aircraft weight is modeled as a uniform distributed load about the center of magnitude w. Assuming the lift distribution is symmetric around the center and that the plane is in static equilibrium, plot the shear force and bending moment diagrams for the loading shown. What is the maximum absolute shear force and maximum absolute bending moment? Assume lengths a = {a()} in., b = {b()} in., and c = {c()} in.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w0.set(random.randrange(50,100,1))\n        a.set(random.randrange(80,120,1))\n        b.set(a()+random.randrange(50,100,1))\n        c.set(b()+random.randrange(10,20,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        instr1 = (w0()*0.5*a()+w0()*(b()-a()))/1000\n        instr2 = (w0()*b()**2/4+w0()*a()*b()/2)/1000\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.33 - Graphical methods for shear force & bending moment diagrams"
    ]
  },
  {
    "objectID": "problem7_34dynamicsubmit.html",
    "href": "problem7_34dynamicsubmit.html",
    "title": "Problem 7.34 - Graphical methods for shear force & bending moment diagrams",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"341\"\nw = reactive.Value(\"__\")\na = reactive.Value(\"__\")\nb = reactive.Value(\"__\")\nc = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of kN\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of kN-m\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A beam is pinned to a wall and supported by an angled connector as shown. All joints are pins. Assume w = {w()} kN/m, and lengths a = {a()} m, b = {b()} m, and c = {c()} m. Plot the shear force and bending moment diagrams for the beam. What is the maximum absolute shear force and maximum absolute bending moment?.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10,100,1)/10)\n        c.set(random.randrange(10,30,1)/10)\n        a.set(round(c()*1.5,1))\n        b.set(c()*2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        By = (w()*(b()+c())*((b()+c())/2))/b()\n        Ay = w()*(b()+c())-By\n        instr1 = abs(-w()*b()+Ay)\n        instr2 = abs(-w()*b()**2/2+Ay*b())\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.34 - Graphical methods for shear force & bending moment diagrams"
    ]
  },
  {
    "objectID": "problem8_1dynamicsubmit.html",
    "href": "problem8_1dynamicsubmit.html",
    "title": "Problem 8.1 - Centroid",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"675\"\nb1=reactive.Value(\"__\")\nb2=reactive.Value(\"__\")\nh1=reactive.Value(\"__\")\nh2=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"For the composite cross-section shown, determine the centroid location, measured from the base. Assume dimensions b&lt;sub&gt;1&lt;/sub&gt; = {b1()} mm, b&lt;sub&gt;2&lt;/sub&gt; = {b2()} mm, h&lt;sub&gt;1&lt;/sub&gt; = {h1()} mm, h&lt;sub&gt;2&lt;/sub&gt; = {h2()} mm, and t = {t()} mm.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b1.set(random.randrange(20,50,1))\n        b2.set(round(b1(),1)*round(random.randrange(50,70,1)/10))\n        h1.set(random.randrange(5,10,1))\n        h2.set(b2())\n        t.set(random.randrange(3,10,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        y1 = h1()+h2()/2\n        y2 = y1\n        y3 = h1()/2\n        A1 = h2()*b2()\n        A2 = -(b2()-2*t())*(h2()-2*t())\n        A3 = h1()*(2*b1()+b2())\n        instr = (y1*A1+y2*A2+y3*A3)/(A1+A2+A3)\n\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 8 Problems",
      "Problem 8.1 - Centroid"
    ]
  },
  {
    "objectID": "problem8_2dynamicsubmit.html",
    "href": "problem8_2dynamicsubmit.html",
    "title": "Problem 8.2 - Centroid",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"676\"\na=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"For the beam cross-section shown, determine the centroid location, measured from the top surface. Assume dimensions a = 3 in. and b = {b()} in.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b.set(random.randrange(30, 50, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        y1 = 0.4317\n        y2 = y1\n        y3 = 0.375\n        y4 = 1.25\n        y5 = 1.75+b()/3\n        y6 = y5\n        y7 = 1.75+b()/2\n        A1 = 0.4418\n        A2 = A1\n        A3 = 3*0.75\n        A4 = 4.5\n        A5 = 0.625*b()\n        A6 = A5\n        A7 = 2*b()\n        instr= (y1*A1+y2*A2+y3*A3+y4*A4+y5*A5+y6*A6+y7*A7)/(A1+A2+A3+A4+A5+A6+A7)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 8 Problems",
      "Problem 8.2 - Centroid"
    ]
  },
  {
    "objectID": "problem8_3dynamicsubmit.html",
    "href": "problem8_3dynamicsubmit.html",
    "title": "Problem 8.3 - Centroid",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"677\"\na = reactive.Value(\"__\")\nb = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of mm\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of mm\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"An experimental model aircraft wing incorporates a half-circular leading edge and a parabolic top surface. Determine the x- and y-coordinates of the centroid of the cross-section. Assume dimensions a = {a()} mm and b = {b()} mm.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        a.set(random.randrange(150,300,5))\n        b.set(random.randrange(10,30,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        xbar=-0.000089*a()**4+b()/2*a()**2/(-0.0001187*a()**3+b()*a())\n        ybar=2.535*10**-8*a()**5-0.000356*b()*2/3*a()**3+b()**2*a()/(-0.0001187*a()**3+b()*a())\n        A1=-0.0001187*a()**3+b()*a()\n        A2=math.pi*b()**2/4\n        x2=-4*b()/2/(3*math.pi)\n        x1A1=xbar*A1\n        x2A2=x2*A2\n        instr1=(x1A1+x2A2)/(A1+A2)\n        y2=b()/2\n        y1A1=ybar*A1\n        y2A2=y2*A2\n        instr2=(y1A1+y2A2)/(A1+A2)\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check} For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 8 Problems",
      "Problem 8.3 - Centroid"
    ]
  },
  {
    "objectID": "problem8_4dynamicsubmit.html",
    "href": "problem8_4dynamicsubmit.html",
    "title": "Problem 8.4 - Centroid",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"678\"\nw = reactive.Value(\"__\")\nF1 = reactive.Value(\"__\")\nF2 = reactive.Value(\"__\")\nF3 = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of ft\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A parking garage slab is subject to an area load ω = {w()} lb/ft&lt;sup&gt;2&lt;/sup&gt; and point loads F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kips, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kips, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} kips. Determine the x- and y-coordinates of the denter of the loading.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(20,50,1))\n        F1.set(random.randrange(10,30,1))\n        F2.set(random.randrange(10,30,1))\n        F3.set(random.randrange(10,30,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        Fog=w()*28*24/1000\n        F1xF=F1()*25\n        F2xF=F2()*4\n        F3xF=F3()*15\n        FogxF=Fog*14\n        instr1 = (F1xF+F2xF+F2xF+FogxF)/(F1()+F2()+F3()+Fog)\n        F1yF=F1()*5\n        F2yF=F2()*5\n        F3yF=F3()*21\n        FogyF=Fog*12\n        instr2 = (F1yF+F2yF+F3yF+FogyF)/(F1()+F2()+F3()+Fog)\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 8 Problems",
      "Problem 8.4 - Centroid"
    ]
  },
  {
    "objectID": "problem8_5dynamicsubmit.html",
    "href": "problem8_5dynamicsubmit.html",
    "title": "Problem 8.5 - Centroid",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"679\"\na=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The cross-section shown is to be used as a retaining structure. Determine the tallest height, h, such that the shape's centroid is to the right of point A. Assume dimensions a = {a()} m and b = {b()} m.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        a.set(random.randrange(10,30,1)/10)\n        b.set(random.randrange(10,30,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        VertxA=0.02\n        HorxA=(a()/2-0.5)*a()*0.2\n        TrixA=(a()-0.5)/3*0.5*(a()-0.5)*b()\n        instr= (HorxA+TrixA)/VertxA\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 8 Problems",
      "Problem 8.5 - Centroid"
    ]
  },
  {
    "objectID": "problem8_7dynamicsubmit.html",
    "href": "problem8_7dynamicsubmit.html",
    "title": "Problem 8.7 - Area Moment of Inertia",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"347\"\nb=reactive.Value(\"__\")\nc=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\na=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\\u2074\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The cross-section shows a concrete beam with two hollow round holes. Determine the area moment of inertia about the beam's centroid. Assume lengths a = {a()} in., b = {b()} in., c = {c()} in., d = {d()} in., d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in., and d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b.set(random.randrange(20, 60, 1)/10)\n        c.set(round(b()*3,1))\n        d.set(b()*2)\n        a.set(b()*2.5)\n        d1.set(round(b()*1.5,1))\n        d2.set(d1()*2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        A1 = (b()+c()+d())*2*a()\n        h1 = (b()+c()+d())/2\n        A2 = (d2()/2)**2*math.pi\n        h2 = d()\n        A3 = (d1()/2)**2*math.pi\n        h3 = d()+c()\n        h = (A1*h1-A2*h2-A3*h3)/(A1-A2-A3)\n        y1 = h-h1\n        y2 = h-h2\n        y3 = h-h3\n        I1 = 2*a()*(b()+c()+d())**3/12\n        I2 = (d2()/2)**4*math.pi/4\n        I3 = (d1()/2)**4*math.pi/4\n        instr = I1+A1*y1**2-(I2+A2*y2**2)-(I3+A3*y3**2)\n\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 8 Problems",
      "Problem 8.7 - Area Moment of Inertia"
    ]
  },
  {
    "objectID": "problem9_1dynamicsubmit.html",
    "href": "problem9_1dynamicsubmit.html",
    "title": "Problem 9.1 - Bending Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"342\"\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Maximum bending stress in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam with a rectangular cross-section of base b = {b()} mm and h = {h()} mm is subjected to the leading shown. If w = {w()} kN/m and L = {L()} m, determine the magnitude of the largest bending stress in the beam.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b.set(random.randrange(50, 150, 5))\n        h.set(random.randrange(b()*5)/2)\n        w.set(random.randrange(10, 200, 1)/10)\n        L.set(random.randrange(20, 100, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Ay = 3*w()*L()/4\n        I = h()**3*b()/1200000000\n        y = h()/200\n        x = Ay/w()\n        M = Ay*x/2\n        instr= M*y/I\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.1 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_2dynamicsubmit.html",
    "href": "problem9_2dynamicsubmit.html",
    "title": "Problem 9.2 - Bending Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"343\"\nb1=reactive.Value(\"__\")\nb2=reactive.Value(\"__\")\nh1=reactive.Value(\"__\")\nh2=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam has the cross-section shown, where b&lt;sub&gt;1&lt;/sub&gt; = {b1()} mm, b&lt;sub&gt;2&lt;/sub&gt; = {b2()} mm, h&lt;sub&gt;1&lt;/sub&gt; = {h1()} mm, and h&lt;sub&gt;2&lt;/sub&gt; = {h2()} mm. The beam is subjected to a concentrated load F = {F()} kN at its midpoint. If length L = {L()} m, determine the magnitude of the maximum bending stress in the beam.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b1.set(random.randrange(10, 20, 1))\n        b2.set((b1()*3))\n        h1.set((b1()*2))\n        h2.set(b1())\n        F.set(random.randrange(20, 300, 1)/10)\n        L.set(random.randrange(20, 100, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Ay = F()/2\n        M = Ay*L()\n        A1 = (2*h1()+h2())*(2*b1()+b2())\n        y1 = (2*h1()+h2())/2\n        A2 = h1()*b2()\n        y2 = 3*h1()/2\n        yc = (A1*y1-A2*y2)/(A1-A2)\n        I1 = ((2*b1()+b2())*(2*h1()+h2())**3)/12\n        I2 = (b2()*h1()**3)/12\n        Ic = ((I1+A1*(y1-yc)**2)-(I2+A2*(y2-yc)**2))/(10**12)\n        instr= (M*(2*h1()+h2()-yc)/Ic)/10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.2 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_3dynamicsubmit.html",
    "href": "problem9_3dynamicsubmit.html",
    "title": "Problem 9.3 - Bending Stress",
    "section": "",
    "text": "Figure 1: A diving board with a person standing on it.\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"344\"\nma=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\ng = 9.81\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A person of mass m = {ma()} kg stands on the end of a diving board with cross-section b = {b()} mm and h = {h()} mm. If lengths L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m, determine the maximum bending stress in the board. Assume g = 9.81 m/s&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        ma.set(random.randrange(55, 100, 1))\n        h.set(random.randrange(30, 60, 1))\n        b.set((h()*6))\n        L1.set(random.randrange(10, 30, 1)/10)\n        L2.set(L1()*2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Mo = float(ma())*L2()*g\n        ytop = h()/2000\n        I = ((b()/1000)*((h()/1000)**3))/12\n        instr= float(Mo)*ytop/I/10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.3 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_4dynamicsubmit.html",
    "href": "problem9_4dynamicsubmit.html",
    "title": "Problem 9.4 - Bending Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"345\"\nro=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam with a hollow circular cross-section of outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} in. and inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} in. is subjected to a distributed load as shown. If w = {w()} lb/ft, L&lt;sub&gt;1&lt;/sub&gt; = {L1()} ft, and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} ft, determine the magnitude of the maximum bending stress in the beam.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        ro.set(random.randrange(40, 100, 1)/10)\n        ri.set(ro()-random.randrange(5, 10, 1)/10)\n        ri.set(round(ri(),1))\n        w.set(random.randrange(100, 800, 10))\n        L1.set(random.randrange(30, 100, 1)/10)\n        L2.set(L1()*2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        R = w()*float(L2())/2\n        M = -R*(L1()+L2()/2)+w()*L2()**2/8\n        I = math.pi*(ro()**4-ri()**4)/4\n        instr= abs(M*ro()*12/I)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.4 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_5dynamicsubmit.html",
    "href": "problem9_5dynamicsubmit.html",
    "title": "Problem 9.5 - Bending Stress",
    "section": "",
    "text": "Figure 1: The cross section of a beam.\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"346\"\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nM=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam has the cross-section shown where b = {b()} in. and h = {h()} in. If the cross-section is subjected to an internal bending moment of {M()} kip-in, determine the magnitude of the bending stress at the bottom of the cross-section.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b.set(random.randrange(20, 50, 1)/10)\n        h.set(b())\n        M.set(random.randrange(5, 100, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        y = 11*h()/9\n        I = (2*b()*h()**3/12)+(2*b()*h()*(3*h()/2-y)**2)+(b()*h()**3/18)+(b()*h()*(2*h()/3-y)**2)\n        instr= M()*y/I\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.5 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_6dynamicsubmit.html",
    "href": "problem9_6dynamicsubmit.html",
    "title": "Problem 9.6 - Bending Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"348\"\na=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nc=reactive.Value(\"__\")\nM=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam has the cross-section shown, where lengths a = {a()} in., b = {b()} in., and c = {c()} in. If the cross-section is subjected to an internal bending moment M = {M()} kip-in., determine the maximum bending stress.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        a.set(random.randrange(10,50,1)/10)\n        b.set(a()*2)\n        c.set(a()*4)\n        M.set(random.randrange(10,100,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        A = c()*a()\n        h1 = c()/2\n        h2 = a()/2+b()\n        h = (A*h1*2+A*h2)/(3*A)\n        I1 = a()*c()**3/12\n        I2 = c()*a()**3/12\n        y1 = h-h1\n        y2 = h2-h\n        I = 2*(I1+A*y1**2)+I2+A*y2**2\n        instr= M()*h/I\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.6 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_7dynamicsubmit.html",
    "href": "problem9_7dynamicsubmit.html",
    "title": "Problem 9.7 - Bending Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"349\"\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nw0=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam with a rectangular cross-section of base b = {b()} in. and height h = {h()} in. is subjected to the loading shown. If w&lt;sub&gt;o&lt;/sub&gt; = {w0()} lb/ft and L = {L()} ft, determine the maximum bending stress in the beam.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b.set(random.randrange(10,50,1)/10)\n        h.set(b()*2)\n        w0.set(random.randrange(500,1500,10))\n        L.set(random.randrange(20,60,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        M = w0()*L()/2*L()*12*2/3+(L()*12+L()*12*2/3)*w0()*L()/2\n        I = b()*h()**3/12\n        instr= M*h()/2/I/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.7 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_8dynamicsubmit.html",
    "href": "problem9_8dynamicsubmit.html",
    "title": "Problem 9.8 - Bending Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"350\"\nt=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nM=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam has the cross-section shown, where t = {t()} mm, w = {w()} mm, and h = {h()} mm. If the cross-section is subjected to internal bending moment M = {M()} kN-m, determine the ratio of the maximum bending stress at the top of the beam to the maximum bending stress at the bottom.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        t.set(random.randrange(20,40,1))\n        w.set(t()+random.randrange(20,30,1))\n        h.set(w()+random.randrange(10,20,1))\n        M.set(random.randrange(10,50,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        A1 = (2*w()+t())*t()\n        A2 = h()*t()\n        y1 = h()+t()/2\n        y2 = h()/2\n        ybar = A1*y1+A2*y2/(A1+A2)\n        top = h()+t()-ybar\n        instr= top/ybar\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.8 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_9dynamicsubmit.html",
    "href": "problem9_9dynamicsubmit.html",
    "title": "Problem 9.9 - Bending Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"351\"\nL=reactive.Value(\"__\")\nr=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of length L = {L()} m has a circular cross-section of radius r = {r()} mm. The beam is subjected to distributed load w = {w()} kN/m as shown. Determine the maximum bending stress in the beam.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(40,100,1)/10)\n        r.set(random.randrange(30,100,1))\n        w.set(random.randrange(10,50,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Ay = w()*L()*L()/2/L()\n        M = Ay*L()/2-w()*L()/2*L()/2/2\n        I = math.pi*(r()/1000)**4/4\n        instr= M*r()/1000/I/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.9 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_10dynamicsubmit.html",
    "href": "problem9_10dynamicsubmit.html",
    "title": "Problem 9.10 - Bending Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"352\"\na=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nc=reactive.Value(\"__\")\nM=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam has the cross-section shown, where dimensions a = {a()} mm, b = {b()} mm, and c = {c()} mm. The internal bending moment on this cross-section is M = {M()} kN-m. Determine the bending stress at point A.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        a.set(random.randrange(30,80,1))\n        b.set(a()*2)\n        c.set(a()*3)\n        M.set(random.randrange(10,200,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        A1 = c()/1000*a()/1000\n        A2 = (a()/1000)**2\n        A3 = b()/1000*a()/1000\n        y1 = 2*a()/1000+a()/2000\n        y2 = a()/1000+a()/2000\n        y3 = a()/2000\n        ybar = A1*y1+A2*y2+A3*y3/(A1+A2+A3)\n        I1 = (a()/1000)**3*c()/12000+A1*(y1-ybar)**2\n        I2 = (a()/1000)**3*a()/12000+A2*(y2-ybar)**2\n        I3 = (a()/1000)**3*b()/12000+A3*(y3-ybar)**2\n        I = I1+I2+I3\n        instr= M()*ybar/I\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.10 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_11dynamicsubmit.html",
    "href": "problem9_11dynamicsubmit.html",
    "title": "Problem 9.11 - Bending Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"353\"\nw=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam has the cross-section shown. If loads w = {w()} lb/in. and F = {F()} lb, determine the maximum bending stress in the beam.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10,30,1))\n        F.set(random.randrange(200,500,10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        M = w()*30*27+F()*54\n        ybar = 1.1\n        I = 7.233\n        instr= M*ybar/I/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.11 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_12dynamicsubmit.html",
    "href": "problem9_12dynamicsubmit.html",
    "title": "Problem 9.12 - Bending Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"354\"\nh=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nw0=reactive.Value(\"__\")\nM=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam has the rectangular cross-section shown, where b = {b()} mm and h = {h()} mm. The beam is subjected to loads where w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kN/m and M = {M()} kN-m. Determine the maximum bending stress in the beam.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        h.set(random.randrange(100,250,5))\n        b.set(h()*2.5)\n        w0.set(random.randrange(10,50,1)/10)\n        M.set(random.randrange(20,50,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Mmax = w0()*6/2*4+M()\n        I = b()/1000*(h()/1000)**3/12\n        ybar = h()/2000\n        instr= Mmax*ybar/I/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.12 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_13dynamicsubmit.html",
    "href": "problem9_13dynamicsubmit.html",
    "title": "Problem 9.13 - Bending Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"355\"\nri=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\noffset=reactive.Value(\"__\")\nM=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam has the cross-section shown, where r&lt;sub&gt;o&lt;/sub&gt; = {ro()} in. and r&lt;sub&gt;i&lt;/sub&gt; = {ri()} in. The inner radius hollow center is offsest by ẟ = {offset()} in. Determine the bending stress at the bottom of the beam when it is subjected to an internal bending moment M = {M()} kip-ft.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        ri.set(random.randrange(20,60,1)/10)\n        ro.set(ri()+random.randrange(20,30,1)/10)\n        offset.set(round((ro()-ri())/2,1))\n        M.set(random.randrange(25,100,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        A1 = math.pi*ri()**2\n        A2 = math.pi*ro()**2\n        y1 = -ro()-offset()\n        y2 = ro()\n        ybar = (A1*y1+A2*y2)/(A1+A2)\n        I1 = ri()**4*math.pi/4\n        I2 = ro()**4*math.pi/4\n        I = -I1-(-y1-ybar)**2*A1+I2+(y2-ybar)**2*A2\n        instr= M()*12*ybar/I\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.13 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_14dynamicsubmit.html",
    "href": "problem9_14dynamicsubmit.html",
    "title": "Problem 9.14 - Bending Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"356\"\nF=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL3=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A wide flange section W14 x 30 is used to support the loads shown, where F = {F()} kips and w = {w()} kips/ft. If lengths L&lt;sub&gt;1&lt;/sub&gt; = {L1()} ft, L&lt;sub&gt;2&lt;/sub&gt; = {L2()} ft, and L&lt;sub&gt;3&lt;/sub&gt; = {L3()} ft, determine the maximum bending stress in the beam. Ignore the beam weight.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(10,100,1))\n        w.set(random.randrange(100,300,1)/10)\n        L2.set(random.randrange(10,25,1)/10)\n        L1.set(L2()*2)\n        L3.set(round(L2()*3,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        M = F()*L1()\n        instr= M*12/42\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.14 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_15dynamicsubmit.html",
    "href": "problem9_15dynamicsubmit.html",
    "title": "Problem 9.15 - Bending Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"358\"\nri=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\nw0=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A pipe has the hollow cross-section shown, where r&lt;sub&gt;o&lt;/sub&gt; = {ro()} mm and r&lt;sub&gt;i&lt;/sub&gt; = {ri()} mm. It is subjected to loads w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kN/m and F = {F()} kN. Determine the maximum bending stress in the beam.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        ri.set(random.randrange(50,100,1))\n        ro.set(ri()+random.randrange(30,50,1))\n        w0.set(random.randrange(20,200,1)/10)\n        F.set(random.randrange(10,30,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        M = w0()*4/2*4*2/3+F()*6\n        I = math.pi*((ro()/1000)**4-(ri()/1000)**4)/4\n        instr= M*ro()/1000/I/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.15 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_16dynamicsubmit.html",
    "href": "problem9_16dynamicsubmit.html",
    "title": "Problem 9.16 - Bending Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"359\"\nL=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam has the trapezoidal cross-section shown. If length L = {L()} ft and loads w = {w()} lb/ft and F = {F()} kips, determine the magnitude of the maximum bending stress in the beam.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50,100,1)/10)\n        w.set(random.randrange(100,250,5))\n        F.set(random.randrange(10,100,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        R = (w()*2*L()+F()*1000)/2\n        M = R*L()*12-w()*2*L()*L()/2*12\n        h = 4.8\n        I = 599.4\n        instr= M*h/I\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.16 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_21dynamicsubmit.html",
    "href": "problem9_21dynamicsubmit.html",
    "title": "Problem 9.21 - Beam Design",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"360\"\nw=reactive.Value(\"__\")\nsigma=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nA=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam with a rectangular cross-section is subjected to a distributed load w = {w()} kN/m as shown. The maximum allowable bending stress in the beam is {sigma()} MPa. If length L = {L()} m and the cross-sectional area of the beam is A = {A()} m&lt;sup&gt;2&lt;/sup&gt;, determine the required width (b) of the cross-section.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(20, 100, 1)/10)\n        sigma.set(random.randrange(5, 30, 1))\n        L.set(random.randrange(30, 100, 1)/10)\n        A.set(random.randrange(15, 50, 5)/1000)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        R = w()*L()/2\n        M = R*L()/2-w()*L()**2/8\n        h = 6*M/(sigma()/1000*A())/10**6\n        instr= A()/h*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.21 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_22dynamicsubmit.html",
    "href": "problem9_22dynamicsubmit.html",
    "title": "Problem 9.22 - Beam Design",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"364\"\nF = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\nsigma = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\nui.row(\n        ui.column(12, ui.div(\n            ui.row(\n                ui.column(1, ui.tags.label(\"W\", class_=\"form-label\", style=\"line-height: 38px;\")),\n                ui.column(3, ui.input_text(\"answer1\", \"\", placeholder=\"Enter your answer 1\")),\n                ui.column(1, ui.tags.label(\"x\", class_=\"form-label\", style=\"line-height: 38px; margin-left: 10px;\")),\n                ui.column(3, ui.input_text(\"answer2\", \"\", placeholder=\"Enter your answer 2\")),\n            ),\n            class_=\"d-flex justify-content-center align-items-center\"\n        ))\n    ),  \n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A wide-flange beam supports two loads F = {F()} kN as shown. If L = {L()} m and the allowable stress is σ = {sigma()} MPa, what is the lightest W-beam in Appendix A that could be used for the beam?\\n\\n Enter two numbers below such that the answer is in the form W 24 x 16.\")]\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(10, 30, 1))\n        L.set(random.randrange(20, 50, 1)/10)\n        sigma.set(random.randrange(100, 250, 10))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        M = F()*L()\n        S = M/sigma()*10**3\n\n        # Create a dataframe\n        df = pd.DataFrame()\n\n        # Define Beam Name Columns\n        df[\"I-Beam First Num\"] = [1000,1000,1000,920,920,920,760,760,760,610,610,610,530,530,530,460,460,460,410,410,410,360,360,360,310,310,310]\n\n        #Define Weight Column\n        df[\"Weight\"] = [642,443,393,725,368,313,484,257,147,415,195,125,300,182,101,193,113,60,100,60,46.1,134,79,51,158,79,38.7]\n        \n        # Define S Column\n        df[\"Sx (x10^3 mm^3)\"] = [27700,19200,15900,30000,15000,11800,17000,8870,4410,11800,5390,3210,7550,4470,2290,4200,2390,1120,1920,1060,773,2340,1270,796,2380,1160,547]\n\n        # Create Solution Dataframe\n        instr=pd.DataFrame()\n        instr[\"First Num\"] =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        instr[\"Second Num\"] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        \n        # Search for Possible Solutions\n        i = 0\n        while i &lt; 27:\n            if df.iloc[i, 2] &gt;= S:\n                instr.iloc[i, 0] = df.iloc[i, 0]\n                instr.iloc[i, 1] = df.iloc[i, 1]\n            i += 1\n        instr = instr.loc[(instr != 0).any(axis=1)]\n\n        #Find Minimum Weight\n        wmin = min(instr.iloc[:,1])\n        mask = instr['Second Num'] == wmin\n        instr = pd.DataFrame(instr[mask])\n\n        correct1 = float(input.answer1()) == instr.iloc[0,0]\n        correct2 = float(input.answer2()) == instr.iloc[0,1]\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct' if correct2 else 'incorrect'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.22 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_23dynamicsubmit.html",
    "href": "problem9_23dynamicsubmit.html",
    "title": "Problem 9.23 - Beam Design",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"365\"\nw0 = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\nsigma = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\nui.row(\n        ui.column(12, ui.div(\n            ui.row(\n                ui.column(1, ui.tags.label(\"W\", class_=\"form-label\", style=\"line-height: 38px;\")),\n                ui.column(3, ui.input_text(\"answer1\", \"\", placeholder=\"Enter your answer 1\")),\n                ui.column(1, ui.tags.label(\"x\", class_=\"form-label\", style=\"line-height: 38px; margin-left: 10px;\")),\n                ui.column(3, ui.input_text(\"answer2\", \"\", placeholder=\"Enter your answer 2\")),\n            ),\n            class_=\"d-flex justify-content-center align-items-center\"\n        ))\n    ),  \n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A wide flange beam supports the distributed load shown, where w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kN/m. If length L = {L()} m and the allowable stress is σ = {sigma()} MPa, what is the lightest W-beam in Appendix A that could be used for the beam?\\n\\n Enter two numbers below such that the answer is in the form W 24 x 16.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w0.set(random.randrange(200, 300, 1)/10)\n        L.set(random.randrange(20, 50, 1)/10)\n        sigma.set(random.randrange(100, 250, 10))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        R = w0()*L()/2\n        M = R*L()-R*L()/3\n        S = M/sigma()*10**3\n\n        # Create a dataframe\n        df = pd.DataFrame()\n\n        # Define Beam Name Columns\n        df[\"I-Beam First Num\"] = [1000,1000,1000,920,920,920,760,760,760,610,610,610,530,530,530,460,460,460,410,410,410,360,360,360,310,310,310]\n\n        #Define Weight Column\n        df[\"Weight\"] = [642,443,393,725,368,313,484,257,147,415,195,125,300,182,101,193,113,60,100,60,46.1,134,79,51,158,79,38.7]\n        \n        # Define S Column\n        df[\"Sx (x10^3 mm^3)\"] = [27700,19200,15900,30000,15000,11800,17000,8870,410,11800,5390,3210,7550,4470,2290,4200,2390,1120,1920,1060,773,2340,1270,796,2380,1160,547]\n\n        # Create Solution Dataframe\n        instr=pd.DataFrame()\n        instr[\"First Num\"] =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        instr[\"Second Num\"] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        \n        # Search for Possible Solutions\n        i = 0\n        while i &lt; 27:\n            if df.iloc[i, 2] &gt;= S:\n                instr.iloc[i, 0] = df.iloc[i, 0]\n                instr.iloc[i, 1] = df.iloc[i, 1]\n            i += 1\n        instr = instr.loc[(instr != 0).any(axis=1)]\n\n        #Find Minimum Weight\n        wmin = min(instr.iloc[:,1])\n        mask = instr['Second Num'] == wmin\n        instr = pd.DataFrame(instr[mask])\n\n        correct1 = float(input.answer1()) == instr.iloc[0,0]\n        correct2 = float(input.answer2()) == instr.iloc[0,1]\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct' if correct2 else 'incorrect'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.23 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_24dynamicsubmit.html",
    "href": "problem9_24dynamicsubmit.html",
    "title": "Problem 9.24 - Beam Design",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"366\"\nw = reactive.Value(\"__\")\nF = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\nFS = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\nui.row(\n        ui.column(12, ui.div(\n            ui.row(\n                ui.column(1, ui.tags.label(\"W\", class_=\"form-label\", style=\"line-height: 38px;\")),\n                ui.column(3, ui.input_text(\"answer1\", \"\", placeholder=\"Enter your answer 1\")),\n                ui.column(1, ui.tags.label(\"x\", class_=\"form-label\", style=\"line-height: 38px; margin-left: 10px;\")),\n                ui.column(3, ui.input_text(\"answer2\", \"\", placeholder=\"Enter your answer 2\")),\n            ),\n            class_=\"d-flex justify-content-center align-items-center\"\n        ))\n    ),  \n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A wide flange I-beam is fixed at one end into a wall, and loaded with both a distributed load w = {w()} kN/m and a point load F = {F()} kN. If length L = {L()} m and the failure stress is 250 MPa, what is the lightest W-beam from Appendix A that could be used for the beam? Use a factor of safety of {FS()}.\\n\\n Enter teo numbers below such that the answer is in the form W 24 x 16.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(5, 50, 1)/10)\n        F.set(random.randrange(10, 100, 1)/10)\n        L.set(random.randrange(50, 150, 1)/10)\n        FS.set(random.randrange(15, 30, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        M = w()*L()*L()/2+F()*L()\n        sigma_allow = 250/FS()\n        S = M/sigma_allow*10**3\n\n        # Create a dataframe\n        df = pd.DataFrame()\n\n        # Define Beam Name Columns\n        df[\"I-Beam First Num\"] = [1000,1000,1000,920,920,920,760,760,760,610,610,610,530,530,530,460,460,460,410,410,410,360,360,360,310,310,310]\n\n        #Define Weight Column\n        df[\"Weight\"] = [642,443,393,725,368,313,484,257,147,415,195,125,300,182,101,193,113,60,100,60,46.1,134,79,51,158,79,38.7]\n        \n        # Define S Column\n        df[\"Sx (x10^3 mm^3)\"] = [27700,19200,15900,30000,15000,11800,17000,8870,4410,11800,5390,3210,7550,4470,2290,4200,2390,1120,1920,1060,773,2340,1270,796,2380,1160,547]\n\n        # Create Solution Dataframe\n        instr=pd.DataFrame()\n        instr[\"First Num\"] =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        instr[\"Second Num\"] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        \n        # Search for Possible Solutions\n        i = 0\n        while i &lt; 27:\n            if df.iloc[i, 2] &gt;= S:\n                instr.iloc[i, 0] = df.iloc[i, 0]\n                instr.iloc[i, 1] = df.iloc[i, 1]\n            i += 1\n        instr = instr.loc[(instr != 0).any(axis=1)]\n\n        #Find Minimum Weight\n        wmin = min(instr.iloc[:,1])\n        mask = instr['Second Num'] == wmin\n        instr = pd.DataFrame(instr[mask])\n\n        correct1 = float(input.answer1()) == instr.iloc[0,0]\n        correct2 = float(input.answer2()) == instr.iloc[0,1]\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct' if correct2 else 'incorrect'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.24 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_25dynamicsubmit.html",
    "href": "problem9_25dynamicsubmit.html",
    "title": "Problem 9.25 - Beam Design",
    "section": "",
    "text": "Figure 1: A I beam is subjected to a distributed load and a tip load.\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"367\"\nw = reactive.Value(\"__\")\nF = reactive.Value(\"__\")\nL2 = reactive.Value(\"__\")\nL1 = reactive.Value(\"__\")\nsigma = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\nui.row(\n        ui.column(12, ui.div(\n            ui.row(\n                ui.column(1, ui.tags.label(\"W\", class_=\"form-label\", style=\"line-height: 38px;\")),\n                ui.column(3, ui.input_text(\"answer1\", \"\", placeholder=\"Enter your answer 1\")),\n                ui.column(1, ui.tags.label(\"x\", class_=\"form-label\", style=\"line-height: 38px; margin-left: 10px;\")),\n                ui.column(3, ui.input_text(\"answer2\", \"\", placeholder=\"Enter your answer 2\")),\n            ),\n            class_=\"d-flex justify-content-center align-items-center\"\n        ))\n    ),  \n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A wide flange I-beam is subjected to both a distributed load w = {w()} kN/m and a point load F = {F()} kN. If length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m, L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m, and the failure stress is {sigma()} MPa, what is the lightest W-beam from Appendix A that could be used for the beam?\\n\\n Enter two numbers below such that the answer is in the form W 24 x 16.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(20, 200, 1)/10)\n        F.set(random.randrange(10, 400, 1)/10)\n        L2.set(random.randrange(20, 60, 1)/10)\n        L1.set(L2()*2)\n        sigma.set(random.randrange(100, 250, 10))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        FA = (w()*L1()*L1()/2-F()*L2())/L1()\n        x = FA/w()\n        M1 = abs(FA*x*0.5)\n        M2 = abs(FA*L1()-w()*L1()*L1()/2)\n        M = max(M1,M2)\n        S = M/sigma()*10**3\n\n        # Create a dataframe\n        df = pd.DataFrame()\n\n        # Define Beam Name Columns\n        df[\"I-Beam First Num\"] = [1000,1000,1000,920,920,920,760,760,760,610,610,610,530,530,530,460,460,460,410,410,410,360,360,360,310,310,310]\n\n        #Define Weight Column\n        df[\"Weight\"] = [642,443,393,725,368,313,484,257,147,415,195,125,300,182,101,193,113,60,100,60,46.1,134,79,51,158,79,38.7]\n        \n        # Define S Column\n        df[\"Sx (x10^3 mm^3)\"] = [27700,19200,15900,30000,15000,11800,17000,8870,4410,11800,5390,3210,7550,4470,2290,4200,2390,1120,1920,1060,773,2340,1270,796,2380,1160,547]\n\n        # Create Solution Dataframe\n        instr=pd.DataFrame()\n        instr[\"First Num\"] =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        instr[\"Second Num\"] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        \n        # Search for Possible Solutions\n        i = 0\n        while i &lt; 27:\n            if df.iloc[i, 2] &gt;= S:\n                instr.iloc[i, 0] = df.iloc[i, 0]\n                instr.iloc[i, 1] = df.iloc[i, 1]\n            i += 1\n        instr = instr.loc[(instr != 0).any(axis=1)]\n\n        #Find Minimum Weight\n        wmin = min(instr.iloc[:,1])\n        mask = instr['Second Num'] == wmin\n        instr = pd.DataFrame(instr[mask])\n\n        correct1 = float(input.answer1()) == instr.iloc[0,0]\n        correct2 = float(input.answer2()) == instr.iloc[0,1]\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct' if correct2 else 'incorrect'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.25 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_26dynamicsubmit.html",
    "href": "problem9_26dynamicsubmit.html",
    "title": "Problem 9.26 - Beam Design",
    "section": "",
    "text": "Figure 1: A I beam is subjected to a point load.\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"367\"\nL = reactive.Value(\"__\")\nF = reactive.Value(\"__\")\nsigma_fail = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer for the first beam number\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer for the second beam number\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A wide flange I-beam of length L = {L()} ft. supports a single load F = {F()} kips at its center. The failure stress is {sigma_fail()} ksi. Determine the lightest W-beam from Appendix A that could be used. Ignore the weight of the beam. \")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10,30,1))\n        F.set(random.randrange(10,50,1))\n        sigma_fail.set(random.randrange(15,25,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        Ay = F()*L()*12/2/(L()*12)\n        M = Ay*L()/2*12\n        S = M/sigma_fail()\n\n        # Create a dataframe\n        df = pd.DataFrame()\n\n        # Define Beam Name Columns\n        df[\"I-Beam First Num\"] = [40,40,40,36,36,36,30,30,30,24,24,24,21,21,21,18,18,18,16,16,16,14,14,14,12,12,12]\n\n        #Define Weight Column\n        df[\"Weight\"] = [431,297,264,487,247,210,326,173,99,279,131,84,201,122,68,130,76,40,67,40,31,90,53,34,106,53,26]\n        \n        # Define S Column\n        df[\"Sx (in^3)\"] = [1690,1170,971,1830,913,719,1040,541,269,718,329,196,461,273,140,256,146,68.4,117,64.7,47.2,143,77.8,48.6,145,70.6,33.4]\n\n        # Create Solution Dataframe\n        instr=pd.DataFrame()\n        instr[\"First Num\"] =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        instr[\"Second Num\"] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        \n        # Search for Possible Solutions\n        i = 0\n        while i &lt; 27:\n            if df.iloc[i, 2] &gt;= S:\n                instr.iloc[i, 0] = df.iloc[i, 0]\n                instr.iloc[i, 1] = df.iloc[i, 1]\n            i += 1\n        instr = instr.loc[(instr != 0).any(axis=1)]\n\n        #Find Minimum Weight\n        wmin = min(instr.iloc[:,1])\n        mask = instr['Second Num'] == wmin\n        instr = pd.DataFrame(instr[mask])\n\n        correct1 = float(input.answer1()) == instr.iloc[0,0]\n        correct2 = float(input.answer2()) == instr.iloc[0,1]\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct' if correct2 else 'incorrect'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr.iloc[0,0]} and {instr.iloc[0,1]}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.26 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_31dynamicsubmit.html",
    "href": "problem9_31dynamicsubmit.html",
    "title": "Problem 9.31 - Unsymmetric Bending",
    "section": "",
    "text": "Figure 1: Two loads are applied at the free end of a cantilever beam.\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"480\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two loads, F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kips and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kips, are applied at the end of a cantilever beam as shown. Both loads act through the center of the rectangular cross-section of base b = {b()} in. and height h = {h()} in. If length L = {L()} ft, determine the stress at point P in the beam at the wall.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(5, 20, 1))\n        F2.set(random.randrange(5, 20, 1))\n        b.set(random.randrange(3, 10, 1))\n        h.set(b()*2)\n        L.set(random.randrange(4, 10, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Mx = F2()*L()*12\n        My = F1()*L()*12\n        instr = Mx*h()/2/(b()*h()**3/12) + My*b()/2/(h()*b()**3/12)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.31 - Unsymmetric Bending"
    ]
  },
  {
    "objectID": "problem9_32dynamicsubmit.html",
    "href": "problem9_32dynamicsubmit.html",
    "title": "Problem 9.32 - Unsymmetric Bending",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"483\"\nMz=reactive.Value(\"__\")\nMy=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two moments, M&lt;sub&gt;z&lt;/sub&gt; = {Mz()} kN-m and M&lt;sub&gt;y&lt;/sub&gt; = {My()} kN-m, act on a beam with the rectangular cross-section shown. If base b = {b()} mm and height h = {h()} mm, determine the bending stress at point A. Recall the convention that tensile stresses are positive and compressive stresses are negative.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        Mz.set(random.randrange(10, 200, 1)/10)\n        My.set(random.randrange(10, 200, 1)/10)\n        b.set(random.randrange(100, 300, 20))\n        h.set(b() * 0.75)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Iy = h()*b()**3/12\n        Iz = b()*h()**3/12\n        instr= -(My()*b()/2/Iy+Mz()*h()/2/Iz)*10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.32 - Unsymmetric Bending"
    ]
  },
  {
    "objectID": "problem9_33dynamicsubmit.html",
    "href": "problem9_33dynamicsubmit.html",
    "title": "Problem 9.33 - Unsymmetric Bending",
    "section": "",
    "text": "{width=“300”.} [Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"484\"\nF=reactive.Value(\"__\")\ntheta=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A W14 x 34 steel beam supports a load F = {F()} kips at its center. The beam is on a sloped roof so the load acts at an angle Θ = {theta()}° as shown. If length L = {L()} ft, determine the stress at point A. Recall the convention that tensile stresses are positive and compressive stresses are negative.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(50, 200, 1)/10)\n        theta.set(random.randrange(10, 30, 1))\n        L.set(random.randrange(3, 10, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Iy = 23.3\n        Iz = 340\n        M = F()/2*L()*12\n        Mz = M*math.cos(theta()*math.pi/180)\n        My = M*math.sin(theta()*math.pi/180)\n        z = 3.375\n        y = 7\n        instr= -My*z/Iy-Mz*y/Iz\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.33 - Unsymmetric Bending"
    ]
  },
  {
    "objectID": "problem9_34dynamicsubmit.html",
    "href": "problem9_34dynamicsubmit.html",
    "title": "Problem 9.34 - Unsymmetric Bending",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"490\"\nF=reactive.Value(\"__\")\ntheta=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cantilevered beam is subjected to a load F = {F()} kN at its end, oriented Θ = {theta()}° from the vertical. If length L = {L()} m, determine the maximum bending stress in the beam. The beam has outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} mm and inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} mm.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(5, 30, 1))\n        theta.set(random.randrange(20, 30, 1))\n        L.set(random.randrange(2, 10, 1))\n        ro.set(random.randrange(40, 120, 4))\n        ri.set(ro()*0.75)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        M = F()*L()\n        My = M*math.sin(theta()*math.pi/180)\n        Mz = M*math.cos(theta()*math.pi/180)\n        I = math.pi/4*(ro()**4-ri()**4)\n        z = ro()*math.sin(theta()*math.pi/180)\n        y = ro()*math.cos(theta()*math.pi/180)\n        instr= (My*z/I+Mz*y/I)*10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.34 - Unsymmetric Bending"
    ]
  },
  {
    "objectID": "problem9_35dynamicsubmit.html",
    "href": "problem9_35dynamicsubmit.html",
    "title": "Problem 9.35 - Unsymmetric Bending",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"492\"\nMz=reactive.Value(\"__\")\nMy=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two moments, M&lt;sub&gt;z&lt;/sub&gt; = {Mz()} kN-m and M&lt;sub&gt;y&lt;/sub&gt; = {My()} kN-m, act on a steel T-beam as shown. Determine the maximum bending stress (tension or compression).\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        Mz.set(random.randrange(10,100,1)/10)\n        My.set(random.randrange(10,100,1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (My()*-0.05/(1.72*10**(-6))-Mz()*.03222/(3.142*10**(-6)))/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.35 - Unsymmetric Bending"
    ]
  },
  {
    "objectID": "problem10_1dynamicsubmit.html",
    "href": "problem10_1dynamicsubmit.html",
    "title": "Problem 10.1 - 1st Moment of Area",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"680\"\nb1=reactive.Value(\"__\")\nb2=reactive.Value(\"__\")\nh2=reactive.Value(\"__\")\nh1=reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Q at point A in units of in\\u00b3\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Q at the centroid in units of in\\u00b3\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"For the built-up T-beam shown, determine the first moment of area, Q, at point A and at the centroid of the cross-section. Assume dimensions b&lt;sub&gt;1&lt;/sub&gt; = {b1()} in., b&lt;sub&gt;2&lt;/sub&gt; = {b2()} in., h&lt;sub&gt;1&lt;/sub&gt; = {h1()} in., and h&lt;sub&gt;2&lt;/sub&gt; = {h2()} in.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b1.set(random.randrange(10, 50, 1)/10)\n        b2.set(round(b1(),1)*(round(random.randrange(40, 60, 1)/10)))\n        h2.set(b1())\n        h1.set(round(b2(),1)+round(random.randrange(20, 60, 1)/10))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        y1 = h1()+h2()/2\n        y2 = h1()/2\n        A1 = b2()*h2()\n        A2 = h1()*b1()\n        ybar = (y1*A1+y2*A2)/(A1+A2)\n        instr1 = (y1-ybar)*A1\n        instr2 = ybar/2*ybar*b1()\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.1 - 1st Moment of Area"
    ]
  },
  {
    "objectID": "problem10_4dynamicsubmit.html",
    "href": "problem10_4dynamicsubmit.html",
    "title": "Problem 10.4 - Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"369\"\nw=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A simply supported beam is constructed from two wooden boards as shown. The beam supports a distributed load w = {w()} kN/m. If lengths L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m, what is the maximum shear stress in the glue that holds the boards together?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10, 200, 1)/10)\n        L1.set(random.randrange(10, 50, 1)/10)\n        L2.set(L1()*2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        V = (L2()*w()*(L2()/2+L1()))/(L2()+2*L1())\n        I = 37.66*10**-6\n        Q = 0.22*10**-3\n        t = 0.02\n        instr= (V*Q)/(I*t)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.4 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_5dynamicsubmit.html",
    "href": "problem10_5dynamicsubmit.html",
    "title": "Problem 10.5 - Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"370\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A simply supported beam is constructed from two wooden boards as shown. The beam supports a concetrated load F = {F()} kN. If length L = {L()} m  and cross-section dimensions b = {b()} mm and h = {h()} mm, determine the shear stress in the glue that holds the boards together.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(50, 300, 1)/10)\n        L.set(random.randrange(40, 100, 1)/10)\n        h.set(random.randrange(20, 50, 1))\n        b.set(h()*2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        V = F()/2\n        y = (h()**2*(h()+h()/2)+b()*h()**2/2)/(h()**2+b()*h())\n        I = h()**4/12+h()**2*(h()+h()/2-y)**2+b()*h()**3/12+b()*h()*(h()/2-y)**2\n        Q = h()**2*(h()+h()/2-y)\n        instr= V*Q/(I*h()/1000)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.5 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_6dynamicsubmit.html",
    "href": "problem10_6dynamicsubmit.html",
    "title": "Problem 10.6 - Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"371\"\nb1=reactive.Value(\"__\")\nb2=reactive.Value(\"__\")\nh1=reactive.Value(\"__\")\nh2=reactive.Value(\"__\")\nV=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A T-beam has dimensions b&lt;sub&gt;1&lt;/sub&gt; = {b1()} in., b&lt;sub&gt;2&lt;/sub&gt; = {b2()} in., h&lt;sub&gt;1&lt;/sub&gt; = {h1()} in., and h&lt;sub&gt;2&lt;/sub&gt; = {h2()} in. If the shear force at this section is V = {V()} kips, determine the shear stress at section a-a.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b1.set(random.randrange(10, 30, 1)/10)\n        b2.set(round(b1()*9,1))\n        h1.set(round(b1()*6,1))\n        h2.set(b1())\n        V.set(random.randrange(20, 100, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        y = (b2()*h2()*(h1()+h2()/2)+h1()**2*b1()/2)/(b2()*h2()+h1()*b1())\n        I = b2()*h2()**3/12+b2()*h2()*(h1()+h2()/2-y)**2+b1()*h1()**3/12+b1()*h1()*(h1()/2-y)**2\n        Q = b2()*h2()*(h1()+h2()/2-y)\n        instr= V()*Q/(I*b1())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.6 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_7dynamicsubmit.html",
    "href": "problem10_7dynamicsubmit.html",
    "title": "Problem 10.7 - Shear Stress",
    "section": "",
    "text": "Figure 1: A beam constructed of two sections glued together is subjected to a force.\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"372\"\nL=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of length L = {L()} ft is constructed by gluing together two boards and is subjected to a concentrated load F = {F()} lb. The cross-section has dimensions b = {b()} in. and h = {h()} in. Determine the shear stress at the seam between the two boards at section a-a.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50, 150, 1)/10)\n        F.set(random.randrange(200, 2000, 10))\n        h.set(random.randrange(10, 50, 1)/10)\n        b.set(round(h()*3,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        y = (b()*h()*(h()+h()/2)+h()**3/2)/(b()*h()+h()**2)\n        I = b()*h()**3/12+b()*h()*(h()+h()/2-y)**2+h()**4/12+h()**2*(h()/2-y)**2\n        Q = h()**2*(h()/2-y)\n        instr= F()*-Q/(I*h())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.7 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_8dynamicsubmit.html",
    "href": "problem10_8dynamicsubmit.html",
    "title": "Problem 10.8 - Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"373\"\nw=reactive.Value(\"__\")\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cantilever beam is loaded as shown, where w = {w()} lb/in., F&lt;sub&gt;1&lt;/sub&gt; = {F1()} lb, and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} lb. What is the maximum shear stress in the beam?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(1, 20, 1))\n        F1.set(random.randrange(20, 200, 1))\n        F2.set(random.randrange(20, 200, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Ay = (30*w()+F1()-F2())\n        V1 = Ay\n        V2 = V1 - 30*w()\n        V3 = V2 - F1()\n        V = max(abs(V1),abs(V2),abs(V3))\n        instr= 1.5*V/30\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.8 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_9dynamicsubmit.html",
    "href": "problem10_9dynamicsubmit.html",
    "title": "Problem 10.9 - Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"374\"\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nw0=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam has the rectangular cross-section shown, where b = {b()} in. and h = {h()} in. If length L = {L()} ft and w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kip/ft, determine the maximum shear stress in the beam..\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b.set(random.randrange(10,50,1)/10)\n        h.set(b()*2)\n        L.set(random.randrange(20,60,1)/10)\n        w0.set(random.randrange(10,100,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        V = w0()*L()\n        instr= 1.5*V*1000/(b()*h())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.9 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_10dynamicsubmit.html",
    "href": "problem10_10dynamicsubmit.html",
    "title": "Problem 10.10 - Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"375\"\nr=reactive.Value(\"__\")\nV=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam has a circular cross-section of radius r = {r()} mm. The internal shear force on the cross-section is V = {V()} kN. Determine the maximum shear stress on the cross-section.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        r.set(random.randrange(30,150,1))\n        V.set(random.randrange(10,200,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = math.pi*(r()/1000)**4/4\n        A = math.pi*(r()/1000)**2\n        y = 4*r()/1000/(3*math.pi)\n        Qt = y*A\n        instr= V()*Qt/(I*2*(r()/1000))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.10 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_11dynamicsubmit.html",
    "href": "problem10_11dynamicsubmit.html",
    "title": "Problem 10.11 - Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"377\"\nri=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\na=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam has the hollow circular cross-section shown, where inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} in. and wall thickness t = {t()} in. The beam has dimensions a = {a()} ft and b = {b()} ft. If the magnitude of the distributed load w = {w()} kip/ft, determine the maximum shear stress in the beam.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        ri.set(random.randrange(50,100,1)/10)\n        t.set(random.randrange(10,20,1)/10)\n        a.set(random.randrange(10,40,1)/10)\n        b.set(a()*2)\n        w.set(random.randrange(10,100,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        V = w()*b()\n        I = math.pi/4*((ri()+t())**4-ri()**4)\n        Q = 2*math.pi*ri()**2*t()*(ri()+t())\n        instr= V*Q/(I*2*t())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.11 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_12dynamicsubmit.html",
    "href": "problem10_12dynamicsubmit.html",
    "title": "Problem 10.12 - Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"379\"\nL=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A simply supported beam of length L = {L()} ft is loaded with a distributed load w = {w()} lb/ft as shown. The beam is a steel (E = 29,000 ksi) W10 x 60. Determine the maximum shear stress in the beam.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(20,50,1))\n        w.set(random.randrange(200,1000,10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        V = 0.5*(w()+60)*L()\n        Q = 36.82\n        I = 341\n        t = 0.42\n        instr= V*Q/(I*t)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.12 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_17dynamicsubmit.html",
    "href": "problem10_17dynamicsubmit.html",
    "title": "Problem 10.17 - Shear Flow",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"380\"\nL=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of length L = {L()} ft is constructed by nailing together two boards with dimensions b = {b()} in. and h = {h()} in. The beam is subjected to a concentrated load F = {F()} lb as shown. Each nail can withstand a shear load of 300 lb. What is the maximum permissable spacing between nails?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50, 200, 1)/10)\n        h.set(random.randrange(10, 40, 1)/10)\n        b.set(h()*2)\n        F.set(random.randrange(100, 900, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = b()*(2*h())**3/12\n        t = b()\n        Q = h()**2*b()/2\n        q = F()*Q/I\n        instr= 300/q\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.17 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_18dynamicsubmit.html",
    "href": "problem10_18dynamicsubmit.html",
    "title": "Problem 10.18 - Shear Flow",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"381\"\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is constructed by nailing together two wooden boards as shown. The nails each have a diameter d = {d()} mm and can withstand an average shear stress of 100 MPa. If loads F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} kN, determine the maximum permissible spacing between the nails.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(5, 15, 1))\n        F1.set(random.randrange(2, 20, 1))\n        F2.set(random.randrange(2, 20, 1))\n        F3.set(random.randrange(2, 20, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        V1 = F1()+F3()-F2()\n        V2 = V1-F1()\n        V3 = V2+F2()\n        Vmax = max(abs(V1), abs(V2), abs(V3))\n        I = 11.52*10**-6\n        Q = 1.28*10**-4\n        Taub = Vmax*Q/(I*0.08)\n        instr= (100000*(d()/1000/2)**2*math.pi)/(Taub*0.08)*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.18 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_19dynamicsubmit.html",
    "href": "problem10_19dynamicsubmit.html",
    "title": "Problem 10.19 - Shear Flow",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"382\"\nL=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nVnail=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of length L = {L()} ft is constructed by nailing together three wooden boards. The beam is subjected to a concentrated load F = {F()} lb. If each nail can resist a shear load of {Vnail()} lb, determine the maximum permissible spacing between the nails.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(20, 100, 1)/10)\n        F.set(random.randrange(300, 900, 1))\n        Vnail.set(random.randrange(100, 200, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        V = F()/2\n        I = 43.08\n        Q = 10\n        Tau = V*Q/I\n        instr= Vnail()/Tau\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.19 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_20dynamicsubmit.html",
    "href": "problem10_20dynamicsubmit.html",
    "title": "Problem 10.20 - Shear Flow",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"384\"\nVN=reactive.Value(\"__\")\nV=reactive.Value(\"__\")\nb1=reactive.Value(\"__\")\nb2=reactive.Value(\"__\")\nh1=reactive.Value(\"__\")\nh2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A T-beam is constructed from two wooden boards nailed together as shown. The nails can withstand a shear load of {VN()} kN and the beam is subjected to a maximum shear force V = {V()} kN. If dimensions b&lt;sub&gt;1&lt;/sub&gt; = {b1()} mm, b&lt;sub&gt;2&lt;/sub&gt; = {b2()} mm, h&lt;sub&gt;1&lt;/sub&gt; = {h1()} mm, and h&lt;sub&gt;2&lt;/sub&gt; = {h2()} mm, determine the minimum permissible spacing between the nails.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        VN.set(random.randrange(5, 20, 1))\n        V.set(random.randrange(30, 60, 1))\n        b1.set(random.randrange(20, 50, 1))\n        b2.set(b1()*10)\n        h1.set(b1()*8)\n        h2.set(b1())\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        h = (h1()*b1()*h1()/2+b2()*h2()*(h1()+h2()/2))/(h1()*b1()+b2()*h2())\n        I = b1()*h1()**3/12+h1()*b1()*(h-h1()/2)**2+b2()*h2()**3/12+b2()*h2()*((h1()+h2()/2)-h)**2\n        Q = h2()*b2()*((h1()+h2()/2)-h)\n        Tau = V()*Q/1000/(I/10000*b1())\n        instr= VN()/(b1()*Tau)*10\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.20 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_21dynamicsubmit.html",
    "href": "problem10_21dynamicsubmit.html",
    "title": "Problem 10.21 - Shear Flow",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"385\"\nh1=reactive.Value(\"__\")\nh2=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nVN=reactive.Value(\"__\")\nV=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is constructed from two boards nailed together as shown, with dimensions b = {b()} in., h&lt;sub&gt;1&lt;/sub&gt; = {h1()} in., and h&lt;sub&gt;2&lt;/sub&gt; = {h2()} in.  The nails can withstand a shear load of {VN()} lb and the beam is subjected to a maximum shear force V = {V()} kips. Determine the maximum permissable spacing between the nails.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        h1.set(random.randrange(10, 50, 1)/10)\n        h2.set(h1()*2)\n        b.set(h1()*3)\n        VN.set(random.randrange(500, 1000, 10))\n        V.set(random.randrange(10, 50, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        y = (h1()+h2())/2\n        Q = (y-h1()/2)*b()*h1()\n        I = b()*(h1()+h2())**3/12\n        Tau = V()*1000*Q/(I*b())\n        instr= VN()/(b()*Tau)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.21 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_22dynamicsubmit.html",
    "href": "problem10_22dynamicsubmit.html",
    "title": "Problem 10.22 - Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"386\"\nr=reactive.Value(\"__\")\nV=reactive.Value(\"__\")\nbolt_shear=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of cm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A circular beam is constructed from two semi-circular members, each of radius r = {r()} mm, that are joined together by bolts equally spaced along the length of the beam. The beam experiences a shear load V = {V()} kN. If each bolt can withstand a maximum shear force of {bolt_shear()} kN, determine the maximum allowable spacing between bolts. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        r.set(random.randrange(25,75,1))\n        V.set(random.randrange(50,250,1)/10)\n        bolt_shear.set(random.randrange(20,50,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Q = 2/3*(r()/1000)**3\n        I = math.pi*(r()/1000)**4/4\n        tau = V()*Q/(I*2*(r()/1000))\n        instr= bolt_shear()/(tau*2*(r()/1000))*100\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.22 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_23dynamicsubmit.html",
    "href": "problem10_23dynamicsubmit.html",
    "title": "Problem 10.23 - Shear Stress",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"389\"\nV=reactive.Value(\"__\")\ns=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of lb\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A vertical shear force V = {V()} kips is acting on the built up box beam shown. The nails are spaced s = {s()} in. apart along the length of the beam. Determine the minimum required load that each nail must be able to resist.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        V.set(random.randrange(10,100,1)/10)\n        s.set(random.randrange(20,100,10)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Q = 60\n        I = 458.7\n        t = 4\n        tau = V()*1000*Q/(I*t)\n        instr= 4*s()*tau/2\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.23 - Shear Stress"
    ]
  },
  {
    "objectID": "problem11_1dynamicsubmit.html",
    "href": "problem11_1dynamicsubmit.html",
    "title": "Problem 11.1 - By Integration of Moment Equation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"391\"\nL=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cantilever beam of length L = {L()} m is subjected to a distributed load w = {w()} kN/m and concentrated load P = {P()} kN. Determine the maximum deflection of the beam. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50, 100, 1)/10)\n        w.set(random.randrange(30, 100, 1)/10)\n        P.set(random.randrange(100, 200, 1)/10)\n        EI.set(random.randrange(20000, 30000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= abs((-3*w()*L()**4-8*P()*L()**3)/(24*EI()))*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.1 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_2dynamicsubmit.html",
    "href": "problem11_2dynamicsubmit.html",
    "title": "Problem 11.2 - By Integration of Moment Equation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"392\"\nL=reactive.Value(\"__\")\nw0=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of degrees\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cantilever beam of length L = {L()} m is subjected to a linear distributed load where w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kN/m. Determine the magnitude of the slope of the beam at the free end. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10, 100, 1)/10)\n        w0.set(random.randrange(10, 100, 1)/10)\n        EI.set(random.randrange(10000, 20000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        M = w0()*L()**2/3\n        F = L()*w0()/2\n        instr= abs((w0()*L()**3/(8*EI()))*180/math.pi)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.2 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_3dynamicsubmit.html",
    "href": "problem11_3dynamicsubmit.html",
    "title": "Problem 11.3 - By Integration of Moment Equation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"393\"\nL=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nM=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cantilever beam of length L = {L()} m is subjected to a distributed load w = {w()} kN/m and couple M = {M()} kN-m. Determine the deflection of the beam at the free end. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10, 100, 1)/10)\n        w.set(random.randrange(10, 100, 1)/10)\n        M.set(random.randrange(10, 100, 1)/10)\n        EI.set(random.randrange(20000, 30000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Mwall = w()*L()**2/2-M()\n        instr= abs((w()*L()**4-4*Mwall*L()**2)/(8*EI())*100)*10\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.3 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_4dynamicsubmit.html",
    "href": "problem11_4dynamicsubmit.html",
    "title": "Problem 11.4 - By Integration of Moment Equation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"394\"\nL=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cantilever beam of length L = {L()} m is subjected to a distributed load w = {w()} kN/m. Determine the magnitude of the deflection of the beam at point B. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10, 100, 1)/10)\n        w.set(random.randrange(10, 100, 1)/10)\n        EI.set(random.randrange(10000, 20000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= 2*w()*L()**4/(81*EI())*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.4 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_5dynamicsubmit.html",
    "href": "problem11_5dynamicsubmit.html",
    "title": "Problem 11.5 - By Integration of Moment Equation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"396\"\nw=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cantilever beam of length L = {L()} ft is subjected to a distributed load w = {w()} lb/in. and a concentrated load P = {F()} kips as shown. Determine the magnitude of the deflection of the beam at point B. Assume EI = {EI()} kip-in.&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(100, 500, 10))\n        F.set(random.randrange(10, 50, 1)/10)\n        EI.set(random.randrange(30000, 60000, 1000))\n        L.set(random.randrange(30, 100, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (F()*(L()*12)**3)/(48*EI())+(5*w()/1000*(L()*12)**4)/(384*EI())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.5 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_6dynamicsubmit.html",
    "href": "problem11_6dynamicsubmit.html",
    "title": "Problem 11.6 - By integration of Moment equation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"399\"\nb=reactive.Value(\"__\")\na=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ft\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of lengths a = {a()} ft and b = {b()} ft is loaded with concentrated load F = {F()} kips at the free end. Determine the magnitude of the deflection at the free end if E = 29,000 ksi and I = {I()} in.&lt;sup&gt;4&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b.set(random.randrange(10,50,1)/10)\n        a.set(round(b())*1.5)\n        F.set(random.randrange(10,100,1)/10)\n        I.set(random.randrange(20,100,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        IE = I()*4.82253086*10**-5*29000/0.00694444\n        x = a()+b()\n        Ay = -F()*b()/a()\n        By = F()+Ay\n        C3 = -Ay*a()**2/6+By*a()**2/2\n        C4 = -By*a()**3/6\n        instr= abs(By*x**3/6-By*a()*x**2/2+Ay*x**3/6+C3*x+C4)/IE\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.6 - By integration of Moment equation"
    ]
  },
  {
    "objectID": "problem11_7dynamicsubmit.html",
    "href": "problem11_7dynamicsubmit.html",
    "title": "Problem 11.7 - By Integration of Moment Equation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"401\"\nw=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ft\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded with distributed load w = {w()} kip/ft as shown. If length L = {L()} ft, E = 29,000 ksi, and I = {I()} in.&lt;sup&gt;4&lt;/sup&gt;, determine the deflection at the midpoint of the beam.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10,100,1)/10)\n        L.set(random.randrange(20,50,1)/10)\n        I.set(random.randrange(50,150,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        IE = I()*29000000\n        x = L()*12\n        instr = (-w()/12*x**4/(24*IE)+w()*L()+w()/12*(L()*12)**4/(24*IE))/12\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.7 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_16dynamicsubmit.html",
    "href": "problem11_16dynamicsubmit.html",
    "title": "Problem 11.16 - By Integration of Load Equation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"398\"\nL=reactive.Value(\"__\")\nwx=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of cm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of length L = {L()} m is loaded with a distributed load w(x) = {wx()}e&lt;sup&gt;x&lt;/sup&gt; kN/m. Determine the deflection at the midpoint of the beam if EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10,100,1)/10)\n        wx.set(random.randrange(11,40,1)/10)\n        EI.set(L()+round(random.randrange(10,50,1)/10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        C2 = wx()\n        C1 = wx()*math.e-wx()\n        C4 = wx()\n        C3 = wx()*math.e-C1/6-wx()/2-C4\n        x = L()/2\n        instr= (-wx()*math.e**x+C1/6*x**3+C2/2*x**2+C3*x+C4)/EI()*100\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.16 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_17dynamicsubmit.html",
    "href": "problem11_17dynamicsubmit.html",
    "title": "Problem 11.17 - By Integration of Load Equation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"404\"\nL=reactive.Value(\"__\")\nw0=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of length L = {L()} m is subjected to a distributed load as shown where w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kN/m. Determine the magnitude of the deflection at x = {x()}L. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(5, 15, 1))\n        w0.set(random.randrange(20, 50, 1))\n        EI.set(random.randrange(10000, 20000, 1000))\n        x.set(random.randrange(1, 9, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (w0()*L()**4*math.sin(math.pi*x()))/(EI()*math.pi**4)*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.17 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_18dynamicsubmit.html",
    "href": "problem11_18dynamicsubmit.html",
    "title": "Problem 11.18 - By Integration of Load Equation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"405\"\nL=reactive.Value(\"__\")\nw0=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of length L = {L()} ft is subjected to a distributed load as shown where w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kip/ft. Determine the magnitude of the deflection at x = {x()}L. Assume EI = {EI()} kip-ft&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(5, 15, 1))\n        w0.set(random.randrange(20, 50, 1))\n        EI.set(random.randrange(30000, 60000, 1000))\n        x.set(random.randrange(1, 9, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (w0()*L()**4/math.pi**4*math.sin(math.pi*x()))/EI()*12\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.18 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_19dynamicsubmit.html",
    "href": "problem11_19dynamicsubmit.html",
    "title": "Problem 11.19 - By Integration of Load Equation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"406\"\nL=reactive.Value(\"__\")\nw0=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of length L = {L()} ft is subjected to a distributed load as shown where w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kip/ft. Determine the magnitude of the deflection at x = {x()}L. Assume EI = {EI()} kip-ft&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(6, 15, 3))\n        w0.set(L()**2/9)\n        EI.set(random.randrange(30000, 60000, 1000))\n        x.set(random.randrange(1, 9, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= abs((-w0()*(x()*L())**4/24+(x()*L())**6/3240+w0()*L()*(x()*L())**3/6-L()**3*(x()*L())**3/162-w0()*L()**2*(x()*L())**2/4+3*L()**4*(x()*L())**2/216)/EI()*12)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.19 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_20dynamicsubmit.html",
    "href": "problem11_20dynamicsubmit.html",
    "title": "Problem 11.20 - By Integration of the Moment Equation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"410\"\nL=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cantilever beam is loaded as shown, where L = {L()} m and w = {w()} kN/m. Determine the slope at point A. Assume EI = {EI()} x 10&lt;sup&gt;6&lt;/sup&gt; kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(30,60,1)/10)\n        w.set(random.randrange(10,150,1)/10)\n        EI.set(random.randrange(30000,60000,1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr = w()*7*L()**3/(6*EI())\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.20 - By Integration of the Moment Equation"
    ]
  },
  {
    "objectID": "problem11_21dynamicsubmit.html",
    "href": "problem11_21dynamicsubmit.html",
    "title": "Problem 11.21 - By Integration of the Moment Equation",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"416\"\nL=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of length L = {L()} m is loaded as shown, where w = {w()}+x&lt;sup&gt;0.5&lt;/sup&gt; kN/m. Determine the deflection at x = {x()} m.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(30,100,1)/10)\n        w.set(random.randrange(1,5,1)/10)\n        x.set(round(L())*random.randrange(2,7,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        EI = 1072\n        C1 = -L()/2-4*L()**(3/2)/15\n        C3 = -L()**3/24-16*L()**(7/2)/945-C1*L()**2/6\n        instr = (-(x()**4/24+16*x()**(9/2)/945+C1*x()**3/6+C3*x())/EI)*1000\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.21 - By Integration of the Moment Equation"
    ]
  },
  {
    "objectID": "problem11_22dynamicsubmit.html",
    "href": "problem11_22dynamicsubmit.html",
    "title": "Problem 11.22 - By Superposition",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"417\"\nL=reactive.Value(\"__\")\nM=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of meters\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cantilever beam is loaded as shown where L = {L()} m, M = {M()} kN-m, and P = {F()} kN. Determine the magnitude of the deflection at the free end of the beam. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(5, 15, 1))\n        M.set(random.randrange(25, 75, 1))\n        F.set(random.randrange(25, 75, 1))\n        EI.set(random.randrange(30000, 60000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= abs((9*M()*L()**2-16*F()*L()**3)/(6*EI()))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.22 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_23dynamicsubmit.html",
    "href": "problem11_23dynamicsubmit.html",
    "title": "Problem 11.23 - By Superposition",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"419\"\nL=reactive.Value(\"__\")\nM=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A simply supported beam is loaded as shown where L = {L()} m, M = {M()} kN-m, w = {w()} kN/m, and F = {F()} kN. Determine the magnitude of the deflection at the center of the beam. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(3, 8, 1))\n        M.set(random.randrange(5, 20, 1))\n        F.set(random.randrange(5, 20, 1))\n        w.set(random.randrange(10, 50, 1)/10)\n        EI.set(random.randrange(20000, 40000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (5*w()*(2*L())**4/(768*EI())+F()*(2*L())**3/(48*EI())+M()*(2*L())**2/(16*EI()))*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.23 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_24dynamicsubmit.html",
    "href": "problem11_24dynamicsubmit.html",
    "title": "Problem 11.24 - By Superposition",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"420\"\nL=reactive.Value(\"__\")\nw1=reactive.Value(\"__\")\nw2=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A simply supported beam is loaded as shown where L = {L()} m, w&lt;sub&gt;1&lt;/sub&gt; = {w1()} kN/m, and w&lt;sub&gt;2&lt;/sub&gt; = {w2()} kN/m. Determine the magnitude of the deflection at the center of the beam. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(3, 8, 1))\n        w1.set(random.randrange(10, 50, 1)/10)\n        w2.set(w1()+random.randrange(10, 30, 1)/10)\n        EI.set(random.randrange(20000, 40000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= abs((5*w1()*(2*L())**4-5*w2()*(2*L())**4)/(768*EI()))*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.24 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_25dynamicsubmit.html",
    "href": "problem11_25dynamicsubmit.html",
    "title": "Problem 11.25 - By Superposition",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"421\"\nL=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of millimeters\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"An overhanging beam is loaded as shown where L = {L()} m and w = {w()} kN/m. Determine the magnitude of the deflection at point A. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(3, 8, 1))\n        w.set(random.randrange(10, 50, 1)/10)\n        EI.set(random.randrange(20000, 40000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (w()*L()**4)/(3*EI())*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.25 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_26dynamicsubmit.html",
    "href": "problem11_26dynamicsubmit.html",
    "title": "Problem 11.26 - By Superposition",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"422\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"An overhanging beam is loaded as shown where L&lt;sub&gt;1&lt;/sub&gt; = {L1()} ft, L&lt;sub&gt;2&lt;/sub&gt; = {L2()} ft, and w = {w()} kip/ft. Determine the deflection at the point C. Assume EI = {EI()} kip-ft&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(5, 15, 1))\n        L2.set(round(L1()*5/7,1))\n        w.set(random.randrange(10, 100, 1)/10)\n        EI.set(random.randrange(20000, 40000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        M = w()*L2()**2/2\n        thetaM = M*L1()/(3*EI())\n        vw = w()*L2()**4/(8*EI())\n        instr= (thetaM*L2()+vw)*12\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.26 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_27dynamicsubmit.html",
    "href": "problem11_27dynamicsubmit.html",
    "title": "Problem 11.27 - By Superposition",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"423\"\nw=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown, where w = {w()} kN/m and F = {F()} kN. If length L = {L()} m, determine the deflection at point B. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10,200,1)/10)\n        F.set(random.randrange(50,150,1))\n        L.set(random.randrange(20,50,1)/10)\n        EI.set(random.randrange(30000,60000,1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= -L()**3*(33*L()*w()+16*F())/(36*EI())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.27 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_28dynamicsubmit.html",
    "href": "problem11_28dynamicsubmit.html",
    "title": "Problem 11.28 - By Superposition",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"424\"\nw=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ft\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown, where w = {w()} kip/ft and F = {F()} kips. If length L = {L()} ft, determine the deflection at the center of the beam. Assume EI = {EI()} kip-ft&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10,100,1)/10)\n        F.set(random.randrange(10,30,1))\n        L.set(random.randrange(30,60,2)/10)\n        EI.set(random.randrange(10000,30000,1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= 5*w()*L()**4/(768*EI())+F()*L()/2*(3*L()**2-4*(L()/2)**2)/(24*EI())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.28 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_29dynamicsubmit.html",
    "href": "problem11_29dynamicsubmit.html",
    "title": "Problem 11.29 - By Superposition",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"426\"\nw=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ft\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown, where w = {w()} kip/ft and F = {F()} kips. If length L = {L()} ft, determine the deflection at the center of the beam. Assume EI = {EI()} kip-ft&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10,100,1)/10)\n        F.set(random.randrange(10,30,1))\n        L.set(random.randrange(30,60,2)/10)\n        EI.set(random.randrange(10000,30000,1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        x = 1.5*L()\n        instr= w()*L()**2*(-L()**3+5*L()**2*x-6*L()*x**2+2*x**3)/(24*EI())+F()*L()*-L()**2/(48*EI())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.29 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_30dynamicsubmit.html",
    "href": "problem11_30dynamicsubmit.html",
    "title": "Problem 11.30 - By Superposition",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"427\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown, where F = {F()} kN and L = {L()} m. Determine the deflection at the free end. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(10,100,1)/10)\n        L.set(random.randrange(20,100,1)/10)\n        EI.set(random.randrange(30000,60000,1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr = 0.4375*F()*L()**3/EI()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.30 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_31dynamicsubmit.html",
    "href": "problem11_31dynamicsubmit.html",
    "title": "Problem 11.31 - By Superposition",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"428\"\nw=reactive.Value(\"__\")\nM=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown, where w = {w()} kN/m, M = {M()} kN-m and L = {L()} m. Determine the deflection at the free end. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10,100,1)/10)\n        M.set(random.randrange(10,50,10))\n        L.set(random.randrange(20,100,1)/10)\n        EI.set(random.randrange(30000,60000,1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        dw = -w()*(2*L()/5)**4/(8*EI())\n        dM = M()*L()**2/(2*EI())\n        instr = (dw+dM)*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.31 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_32dynamicsubmit.html",
    "href": "problem11_32dynamicsubmit.html",
    "title": "Problem 11.32 - By Superposition",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"430\"\nw0=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of cm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown, where w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kN/m, F = {F()} kN and L = {L()} m. Determine the deflection at the free end. Assume E = 200 GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w0.set(random.randrange(10,100,1)/10)\n        F.set(random.randrange(10,100,1)/10)\n        L.set(random.randrange(10,50,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = 2.887*10**-6\n        E = 200*10**6\n        vp = -F()*L()**3/(3*E*I)\n        vw = -w0()-L()**4/(30*E*I)\n        thetaw = -w0()*L()**3/(24*E*I)*100\n        instr = vw+thetaw*2+vp\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.32 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_33dynamicsubmit.html",
    "href": "problem11_33dynamicsubmit.html",
    "title": "Problem 11.33 - By Superposition",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"431\"\nw=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\na=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown, where w = {w()} kN/m, F = {F()} kN, and lengths a = {a()} m and b = {b()} m. Determine the deflection at point C. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(1,20,1)/10)\n        F.set(random.randrange(25,100,1))\n        b.set(random.randrange(20,60,1)/10)\n        a.set(b()*2.5)\n        EI.set(random.randrange(30000,60000,1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Mp = b()*F()*1000\n        thetab = w()*1000*a()**3/(24*EI()*1000)-Mp*a()/(3*EI()*1000)\n        del1 = b()*thetab\n        del2 = -F()*1000*b()**3/(3*EI()*1000)\n        instr = del1+del2\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.33 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_34dynamicsubmit.html",
    "href": "problem11_34dynamicsubmit.html",
    "title": "Problem 11.34 - By Superposition",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"433\"\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam has the rectangular cross-section shown, where b = {b()} in. and h = {h()} in. It is subjected to loads w = {w()} kip/ft and F = {F()} kips. If length L = {L()} ft, determine the deflection at point B. Assume E = 29,000 ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b.set(random.randrange(10,40,1)/10)\n        h.set(round(b()*3,1))\n        w.set(random.randrange(10,100,1)/10)\n        F.set(random.randrange(25,75,1))\n        L.set(random.randrange(20,60,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = b()*h()**3/12\n        E = 29000000\n        del1 = -F()*1000*(L()*12)**2*(3*L()*12*2-L()*12)/(6*E*I)\n        del2 = -w()*1000*L()*(L()*12)**2*(3*2*L()*12+3*L()*12-2*L()*12)/(12*E*I)\n        del3 = -w()*1000/12*(L()*12)**2*(6*(L()*12)**2-4*L()*12*L()*12+(L()*12)**2)/(24*E*I)\n        instr = del1+del2+del3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.34 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_35dynamicsubmit.html",
    "href": "problem11_35dynamicsubmit.html",
    "title": "Problem 11.35 - By Superposition",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"434\"\nL=reactive.Value(\"__\")\ndelta=reactive.Value(\"__\")\nW=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in numbers of boards\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A volcano has erupted and you need to cross a span of L = {L()} ft with lava only δ = {delta()} in. below. You have a stack of 2x4's (actual dimensions 3.5 in. by 1.5 in.). If the boards are placed flat, determine the minimum number of boards you need to to stack to prevent contact with the lava as you cross. Assume you weigh W = {W()} lb, E = {E()} ksi, and you may neglect the weight of the boards. [Hint: The maximum deflection will occur when you are standing at the center of the span].\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(20,40,1))\n        delta.set(random.randrange(30,80,1)/10)\n        W.set(random.randrange(140,225,1))\n        E.set(random.randrange(7500,12500,100))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = W()*L()**3/(48*E()*delta())\n        a = (12*I/3.5)**(1/3)\n        instr = math.ceil(a/1.5)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.35 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_36dynamicsubmit.html",
    "href": "problem11_36dynamicsubmit.html",
    "title": "Problem 11.36 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"436\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kips\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} ft and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} ft is subjected to a distributed load w = {w()} kip/ft as shown. Determine the reaction force at support B. Assume EI = {EI()} kip-ft&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(20, 70, 1)/10)\n        L2.set(L1()*2)\n        w.set(random.randrange(10, 100, 1)/10)\n        EI.set(random.randrange(10000, 30000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        L = L1()+L2()\n        vB = (-3*w()*L2()**5+7*w()*L*L2()**4-4*w()*L**2*L2()**3)/(24*L*EI())\n        instr= (-6*L*EI()*vB)/(L2()*L1()*(L**2-L2()**2-L1()**2))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.36 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_37dynamicsubmit.html",
    "href": "problem11_37dynamicsubmit.html",
    "title": "Problem 11.37 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"437\"\nw1=reactive.Value(\"__\")\nw2=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is subjected to two distributed loads, w&lt;sub&gt;1&lt;/sub&gt; = {w1()} kN/m and w&lt;sub&gt;2&lt;/sub&gt; = {w2()} kN/m as shown. It is supported by a pin at A and rollers at B and C. If length L = {L()} m, determine the reaction force at support B. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w1.set(random.randrange(10, 50, 1)/10)\n        w2.set(w1()+random.randrange(10, 30, 1)/10)\n        L.set(random.randrange(2, 10, 1))\n        EI.set(random.randrange(20000, 40000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        v1 = 5*w1()*(2*L())**4/(768*EI())\n        v2 = -5*w2()*(2*L())**4/(768*EI())\n        instr= -((v1+v2)*48*EI())/(2*L())**3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.37 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_38dynamicsubmit.html",
    "href": "problem11_38dynamicsubmit.html",
    "title": "Problem 11.38 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"438\"\nw=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nL3=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip-ft\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A propped cantilever beam is subjected to a distributed load w = {w()} kip/ft as shown. If length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} ft, L&lt;sub&gt;2&lt;/sub&gt; = {L2()} ft, and L&lt;sub&gt;3&lt;/sub&gt; = {L3()} ft, determine the magnitude of the moment reaction at the wall. Assume EI = {EI()} kip-ft&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10, 50, 1)/10)\n        L1.set(random.randrange(2, 5, 1))\n        L2.set(L1()*3/2)\n        L3.set(L1()*3/2)\n        EI.set(random.randrange(10000, 30000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        R = (3*w()*L3()**3*4*L2()/(24*(L2()+L3())**3))\n        instr= -R*(L2()+L3())+L3()**2*w()/2\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.38 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_39dynamicsubmit.html",
    "href": "problem11_39dynamicsubmit.html",
    "title": "Problem 11.39 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"439\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is subjected to force F = {F()} kN as shown. If length L = {L()} m, determine the reaction force at support B. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(10, 300, 1))\n        L.set(random.randrange(2, 6, 1))\n        EI.set(random.randrange(20000, 40000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= 0.6875*F()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.39 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_40dynamicsubmit.html",
    "href": "problem11_40dynamicsubmit.html",
    "title": "Problem 11.40 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"440\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is subjected to force F = {F()} kN as shown. If length L = {L()} m, determine the reaction force at support B. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(20, 80, 1))\n        L.set(random.randrange(3, 8, 1))\n        EI.set(random.randrange(5000, 20000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr = 5*F()/16\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.40 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_41dynamicsubmit.html",
    "href": "problem11_41dynamicsubmit.html",
    "title": "Problem 11.41 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"441\"\nw0=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A propped cantilver beam is loaded as shown, where w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kN/m. If length L = {L()} m, determine the reaction force at support B. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w0.set(random.randrange(10,300,1)/10)\n        L.set(random.randrange(20,70,1)/10)\n        EI.set(random.randrange(5000,20000,1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr = 37*L()*w0()/135\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.41 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_42dynamicsubmit.html",
    "href": "problem11_42dynamicsubmit.html",
    "title": "Problem 11.42 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"442\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown, where F = {F()} kips. If length L = {L()} ft, determine the reaction force at support B. Assume EI = {EI()} kip-ft&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(25,250,1))\n        L.set(random.randrange(20,50,1)/10)\n        EI.set(random.randrange(10000,30000,1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        dB1 = F()*L()*(3*(4*L())**2-4*L()**2)/48\n        dB2 = (4*L())**3/48\n        instr = dB1/dB2\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.42 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_43dynamicsubmit.html",
    "href": "problem11_43dynamicsubmit.html",
    "title": "Problem 11.43 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"443\"\nM=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown, where M = {M()} kip-ft. If length L = {L()} ft, determine the reaction force at support B. Assume EI = {EI()} kip-ft&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        M.set(random.randrange(10,200,1))\n        L.set(random.randrange(30,200,1)/10)\n        EI.set(random.randrange(10000,30000,1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        dM = M()*L()**2/2\n        dP = L()**3/3\n        instr = dM/dP\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.43 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_44dynamicsubmit.html",
    "href": "problem11_44dynamicsubmit.html",
    "title": "Problem 11.44 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"444\"\nw=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A propped cantilever beam is loaded as shown, where w = {w()} kip/ft and F = {F()} kips. If length L = {L()} ft, determine the reaction force at support B. Assume EI = {EI()} kip-ft&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(100,300,1)/10)\n        F.set(random.randrange(50,150,1))\n        L.set(random.randrange(20,60,1)/10)\n        EI.set(random.randrange(10000,30000,1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        v1 = -F()*L()**2*(3*3*L()-L())/6\n        v2 = -w()*(3*(3*L())**4-4*(2*L())**3*L()+(2*L())**4)/24\n        v3 = (3*L())**3/3\n        instr = (-v1-v2)/v3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.44 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_45dynamicsubmit.html",
    "href": "problem11_45dynamicsubmit.html",
    "title": "Problem 11.45 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"447\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown, where F = {F()} kips. If length L = {L()} ft, determine the reaction force at support B. Assume EI = {EI()} kip-ft&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(25,250,1))\n        L.set(random.randrange(20,60,1)/10)\n        EI.set(random.randrange(10000,30000,1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        v1 = -F()*(2*L())**2*(3*3*L()-2*L())/6\n        v2 = -(2*L())**2*(3*2*L()-2*L())/6\n        instr = v1/v2\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.45 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_46dynamicsubmit.html",
    "href": "problem11_46dynamicsubmit.html",
    "title": "Problem 11.46 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"448\"\nw0=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is attached to two fixed supports and loaded as shown, where w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kN/m. If length L = {L()} m, determine the vertical reaction force at the right support. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w0.set(random.randrange(10,75,1))\n        L.set(random.randrange(40,100,1)/10)\n        EI.set(random.randrange(20000,40000,1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n       \n        instr = 7*w0()*L()/20\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.46 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_47dynamicsubmit.html",
    "href": "problem11_47dynamicsubmit.html",
    "title": "Problem 11.47 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"449\"\nw=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ft\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A propped cantilever beam is loaded as shown, where w = {w()} kip/ft. If length L = {L()} ft, determine the distance, x, from point A at which the maximum deflection occurs. Assume EI = {EI()} kip-ft&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10,200,1)/10)\n        L.set(random.randrange(30,120,1)/10)\n        EI.set(random.randrange(10000,30000,1000))        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        RB = 3*w()*L()/8\n        a = -4*w()\n        b = 12*L()*w()-12*RB\n        c = -12*L()**2*w()+24*RB*L()\n        x1 = (-b+math.sqrt(b**2-4*a*c))/(2*a)\n        x2 = (-b-math.sqrt(b**2-4*a*c))/(2*a)\n        instr= min(x1,x2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.47 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_48dynamicsubmit.html",
    "href": "problem11_48dynamicsubmit.html",
    "title": "Problem 11.48 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"450\"\nw=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A steel (E = 29,000 ksi) W14 x 82 beam is loaded as shown, where w = {w()} kip/ft. If length L = {L()} ft, determine the maximum bending stress in the beam at point B.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10,200,1)/10)\n        L.set(random.randrange(30,100,1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Vc = -w()*2*L()*((2*L())**4-4*(2*L())**3*3*L()+4*(2*L())**2*(3*L())**2+(2*L())**2*(2*L())**2-4*(2*L())*3*L()*(2*L())**2+3*L()*(2*L())**3)/24\n        Vb = -w()*L()*((2*L())**4-4*(2*L())**3*3*L()+4*(2*L())**2*(3*L())**2+(2*L())**2*L()**2-4*(2*L())*3*L()*L()**2+3*L()*L()**3)/24\n        Vc2 = L()*2*L()*((3*L())**2-L()**2-(2*L())**2)/6\n        Vb2 = L()*L()*((3*L())**2-L()**2-L()**2)/6\n        Vb1 = Vc2\n        Vc1 = Vb2\n        F1 = (Vb*Vc2*Vc*Vb2)/(Vb1*Vc2-Vc1*Vb2)\n        F2 = (Vc-Vc1*F1)/Vc2\n        RA = (4*L()*w()-2*F1-F2)/3\n        MB = (RA*L()-w()*L()*L()/2)*12\n        instr= MB*7.155/882\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.48 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_49dynamicsubmit.html",
    "href": "problem11_49dynamicsubmit.html",
    "title": "Problem 11.49 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \nproblem_ID=\"451\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown, where F = {F()} kN. If length L = {L()} m, determine the reaction force at support B. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(10,100,1)/10)\n        L.set(random.randrange(20,50,1)/10)\n        EI.set(random.randrange(20000,40000,1000))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= 2.063*F()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.49 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_50dynamicsubmit.html",
    "href": "problem11_50dynamicsubmit.html",
    "title": "Problem 11.50 - Intermediate Beam Design",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"681\"\nsigma=reactive.Value(\"__\")\ntau=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip/ft\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A W18 x 76 shape (E = 29,000 ksi) is to be simply-supported and carry a uniform distributed load, w. If the beam has an allowable bending stress σ = {sigma()} ksi, allowable shear stress τ = {tau()} ksi, and allowable deflection of span/240, determine the maximum load, w, for a span L = {L()} ft. Ignore self-weight.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma.set(random.randrange(20, 30, 1))\n        tau.set(sigma()-random.randrange(6, 12, 1))\n        L.set(random.randrange(20, 40, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        ansM= 8*146*sigma()/(L()*12)**2*12\n        ansDef = 384*29000*1330/(240*5*(L()*12)**3)*12\n        instr = min(ansM,ansDef)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.50 - Intermediate Beam Design"
    ]
  },
  {
    "objectID": "problem11_51dynamicsubmit.html",
    "href": "problem11_51dynamicsubmit.html",
    "title": "Problem 11.51 - Intermediate Beam Design",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"682\"\nw=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A window manufacturer is considering maximum sizes possible for a hollow aluminum tube section (E = 67 GPa). The tube will be simply-supported with a uniform distributed load, w = {w()} kN/m. If the aluminum tube has an allowable bending stress σ = 250 MPa, allowable shear stress τ = 150 MPa, and deflection limit of span/480, determine the longest span allowed. Assume dimensions b = {b()} mm and h = {h()} mm.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(50, 100, 1)/10)\n        b.set(random.randrange(80, 120, 1))\n        h.set(random.randrange(150, 200, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = b()*h()**3/12-((b()-7.4)*(h()-7.4)**3/12)\n        M = w()*1000/8\n        ansM = (80.6*250/M)**0.5\n        ansDef = (384*67*I/(2400*w()/1000))**(1/3)/1000\n        instr = min(ansM,ansDef)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.51 - Intermediate Beam Design"
    ]
  },
  {
    "objectID": "problem11_52dynamicsubmit.html",
    "href": "problem11_52dynamicsubmit.html",
    "title": "Problem 11.52 - Intermediate Beam Design",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"683\"\nL = reactive.Value(\"__\")\nw = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"First Beam Number\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Second Beam Number\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A beam is to be made using off-the-shelf lumber sizes. It will be used to span an opening of length L = {L()} ft and subject to a distributed load ω = {w()} lb/ft. Determine the lightest beam that may be used, assuming E = 1200 ksi, σ&lt;sub&gt;allow&lt;/sub&gt; = 2000 psi, τ&lt;sub&gt;allow&lt;/sub&gt; = 1000 psi, and maximum deflection = span/360.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50,100,1)/10)\n        w.set(random.randrange(100,160,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        smin=w()/12*(L()*12)**2/(8*2000)\n        Amin=3*w()/12*L()*12/(4*1000)\n        Imin=5*w()/12*(L()*12)**4/(384*1200000*L()*12/360)\n        df=pd.DataFrame()\n        df[\"Atab\"]=[5.25,8.25,11.25,13.88,16.88,10.5,16.5,22.5,27.75,33.75,15.75,24.75,33.75,41.63,50.63]\n        df[\"Itab\"]=[5.36,20.8,52.73,98.93,177.98,10.72,41.59,105.47,177.86,355.96,16.08,62.39,158.2,296.79,533.94]\n        df[\"stab\"]=[3.06,7.56,14.06,21.39,31.64,6.13,15.13,28.13,42.78,63.28,9.18,22.69,42.19,64.17,94.92]\n        df[\"secondnum\"]=[4,6,8,10,12,4,6,8,10,12,4,6,8,10,12]\n\n        # Filter rows meeting all conditions\n        filtered = df[(df[\"Atab\"] &gt;= Amin) & (df[\"Itab\"] &gt;= Imin) & (df[\"stab\"] &gt;= smin)]\n\n        # Find rows with the minimum area\n        if not filtered.empty:\n            Areamin = filtered[\"Atab\"].min()\n            result = filtered[filtered[\"Atab\"] == Areamin]\n\n        correct1 = float(input.answer1()) == 2  # 'First Num' is fixed to 2 in this example\n        correct2 = float(input.answer2()) == result.iloc[0][\"secondnum\"]\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check} For reference in debugging this, the calculated instructor answers are 2 and {result.iloc[0][\"secondnum\"]}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.52 - Intermediate Beam Design"
    ]
  },
  {
    "objectID": "problem11_53dynamicsubmit.html",
    "href": "problem11_53dynamicsubmit.html",
    "title": "Problem 11.53 - Intermediate Beam Design",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"684\"\nd=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A pipe with an outer diameter of {d()} mm is to be used as a cantilever beam of length L = {L()} m carrying a load P = {P()} kN at the free end. Determine the minimum required pipe wall thickness if the allowable bending stress, σ&lt;sub&gt;allow&lt;/sub&gt; = 400 MPa, the allowable shear stress, τ&lt;sub&gt;allow&lt;/sub&gt; = 240 MPa, and the allowable deflection = 50 mm. Assume E = 200 GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(75, 125, 1))\n        L.set(random.randrange(20, 30, 1)/10)\n        P.set(random.randrange(10, 100, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I1 = P()*(L()*1000)**3/(3*200*50)\n        I2 = P()*L()*1000*d()/2/0.400\n        I = max(I1,I2)\n        ri = ((math.pi*(d()/2)**4/4-I)*4/math.pi)**(1/4)\n        instr= d()/2-ri\n\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.53 - Intermediate Beam Design"
    ]
  },
  {
    "objectID": "problem11_54dynamicsubmit.html",
    "href": "problem11_54dynamicsubmit.html",
    "title": "Problem 11.54 - Intermedate Beam Design",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"685\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A DIY enthusiast is widening a window opening in a load-bearing wall. The existing beam above the window measures 3.5 in. thick by 5.5 in. tall, and has length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. A new beam made form the same wood is 5.25 in. thick. Determine the required height, h, if this beam will span a length L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in. and the bending stress, shear stress, and deflection do not exceed the values of the original beam.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(20,40,1))\n        L2.set(L1()+random.randrange(15,25,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Io=3.5*5.5**3/12\n        sigma_o=L1()**2*55/2/(8*Io)\n        sigma_p=L2()**2/2/(8/12*5.25)\n        bendmin=math.sqrt(sigma_p/sigma_o)\n        tau_o=3*L1()/2/(2*3.5*5.5)\n        tau_p=3*L2()/2/(2*5.25)\n        shearmin=tau_p/tau_o\n        delta_o=5*L1()**4/(384*Io)\n        delta_p=5*L2()**4/(384*5.25/12)\n        deflectionmin=(delta_p/delta_o)**(1/3)\n        instr= max(bendmin,shearmin,deflectionmin)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.54 - Intermedate Beam Design"
    ]
  },
  {
    "objectID": "problem12_1dynamicsubmit.html",
    "href": "problem12_1dynamicsubmit.html",
    "title": "Problem 12.1 - Equations",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"498\"\nsigmax=reactive.Value(\"__\")\nsigmay=reactive.Value(\"__\")\ntxy=reactive.Value(\"__\")\ntheta=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A point in a beam is subjected to the state of stress shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigmax()} ksi, σ&lt;sub&gt;y&lt;/sub&gt; = {sigmay()} ksi, and τ&lt;sub&gt;xy&lt;/sub&gt; = {txy()} ksi. Determine the normal stress acting on plane a-a if angle Θ = {theta()}°. Enter a negative sign if the answer is compressive.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigmax.set(random.randrange(10, 50, 1))\n        sigmay.set(random.randrange(10, 50, 1))\n        txy.set(random.randrange(10, 50, 1))\n        theta.set(random.randrange(20, 30, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (-sigmax()-sigmay())/2+(-sigmax()+sigmay())/2*math.cos(2*theta()*math.pi/180)+txy()*math.sin(2*theta()*math.pi/180)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.1 - Equations"
    ]
  },
  {
    "objectID": "problem12_2dynamicsubmit.html",
    "href": "problem12_2dynamicsubmit.html",
    "title": "Problem 12.2 - Equations",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"499\"\nsigmax=reactive.Value(\"__\")\nsigmay=reactive.Value(\"__\")\ntxy=reactive.Value(\"__\")\ntheta=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A point in a beam is subjected to the state of stress shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigmax()} MPa, σ&lt;sub&gt;y&lt;/sub&gt; = {sigmay()} MPa, and τ&lt;sub&gt;xy&lt;/sub&gt; = {txy()} MPa. Determine the normal stress acting on plane a-a if angle Θ = {theta()}°. Enter a negative sign if the answer is compressive.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigmax.set(random.randrange(11, 51, 1))\n        sigmay.set(random.randrange(11, 51, 1))\n        txy.set(random.randrange(11, 51, 1))\n        theta.set(random.randrange(21, 31, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        alpha = 90-10-theta()\n        instr= (sigmax()+sigmay())/2+(sigmax()-sigmay())/2*math.cos(2*alpha*math.pi/180)-txy()*math.sin(2*alpha*math.pi/180)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.2 - Equations"
    ]
  },
  {
    "objectID": "problem12_3dynamicsubmit.html",
    "href": "problem12_3dynamicsubmit.html",
    "title": "Problem 12.3 - Equations",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"500\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\ntheta = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your normal stress in units of MPa\", placeholder=\"Please enter the normal stress\"),\n    ui.input_text(\"answer2\", \"Your shear stress in units of MPa\", placeholder=\"Please enter the shear stress\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A point in a beam is subjected to the state of stress shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} MPa, σ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} MPa, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} MPa. Determine the magnitude of the normal stress and the magnitude of the shear stress acting on plane a-a if angle Θ = {theta()}°.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(15, 60, 1))\n        sigma_y.set(random.randrange(15, 60, 1))\n        tau_xy.set(random.randrange(15, 60, 1))\n        theta.set(random.randrange(55, 75, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        thetan = 90-theta()\n        instr1 = abs((-sigma_x()-sigma_y())/2+(-sigma_x()+sigma_y())/2*math.cos(2*thetan*math.pi/180)+tau_xy()*math.sin(2*thetan*math.pi/180))\n        instr2 = abs((sigma_x()-sigma_y())/2*math.sin(2*thetan*math.pi/180)+tau_xy()*math.cos(2*thetan*math.pi/180))\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n    \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.3 - Equations"
    ]
  },
  {
    "objectID": "problem12_4dynamicsubmit.html",
    "href": "problem12_4dynamicsubmit.html",
    "title": "Problem 12.4 - Equations",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"501\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\ntheta = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your normal stress in units of ksi\", placeholder=\"Please enter your normal stress\"),\n    ui.input_text(\"answer2\", \"Your shear stress in units of ksi\", placeholder=\"Please enter your shear stress\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A material made from fibers is stressed as shown in the diagram. Stresses σ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} ksi, σ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} ksi, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} ksi. Determine the magnitude of the normal stress acting perpendicuar to the fibers and the magnitude of the shear stress acting parallel to the fibers if angle Θ = {theta()}°.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(10, 50, 1))\n        sigma_y.set(random.randrange(10, 50, 1))\n        tau_xy.set(random.randrange(10, 50, 1))\n        theta.set(random.randrange(20, 30, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        thetap = theta()+90\n        instr1 = abs((sigma_x()+sigma_y())/2+(sigma_x()-sigma_y())/2*math.cos(2*thetap*math.pi/180)+tau_xy()*math.sin(2*thetap*math.pi/180))\n        instr2 = abs((-sigma_x()+sigma_y())/2*math.sin(2*theta()*math.pi/180)+tau_xy()*math.cos(2*theta()*math.pi/180))\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n    \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.4 - Equations"
    ]
  },
  {
    "objectID": "problem12_5dynamicsubmit.html",
    "href": "problem12_5dynamicsubmit.html",
    "title": "Problem 12.5 - Equations",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"502\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\ntheta = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your normal stress in units of ksi\", placeholder=\"Please enter your normal stress\"),\n    ui.input_text(\"answer2\", \"Your shear stress in units of ksi\", placeholder=\"Please enter your shear stress\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A material made from fibers is stressed as shown in the diagram. Stresses σ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} ksi, σ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} ksi, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} ksi. Determine the magnitude of the normal stress acting perpendicuar to the fibers and the magnitude of the shear stress acting parallel to the fibers if angle Θ = {theta()}°.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(20, 75, 1))\n        sigma_y.set(random.randrange(20, 75, 1))\n        tau_xy.set(random.randrange(20, 75, 1))\n        theta.set(random.randrange(10, 25, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        thetap = 90-theta()\n        instr1 = abs((sigma_x()+sigma_y())/2+(sigma_x()-sigma_y())/2*math.cos(2*thetap*math.pi/180)+tau_xy()*math.sin(2*thetap*math.pi/180))\n        instr2 = abs((-sigma_x()+sigma_y())/2*math.sin(2*thetap*math.pi/180)+tau_xy()*math.cos(2*thetap*math.pi/180))\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n    \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.5 - Equations"
    ]
  },
  {
    "objectID": "problem12_6dynamicsubmit.html",
    "href": "problem12_6dynamicsubmit.html",
    "title": "Problem 12.6 - Equations",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \nproblem_ID=\"503\"\nsigmax=reactive.Value(\"__\")\nsigmay=reactive.Value(\"__\")\ntauxy=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The state of stress at a point in a member is shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigmax()} ksi, σ&lt;sub&gt;y&lt;/sub&gt; = {sigmay()} ksi, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tauxy()} ksi. Determine the ratio of absolute shear stress to absolute normal stress on plane a-a.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigmax.set(random.randrange(10,50,1))\n        sigmay.set(random.randrange(10,50,1))\n        tauxy.set(random.randrange(10,50,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigmay1=(sigmax()+sigmay())/2-tauxy()\n        tauxy1=-(sigmax()-sigmay())/2\n        instr= abs(tauxy1/sigmay1)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.6 - Equations"
    ]
  },
  {
    "objectID": "problem12_7dynamicsubmit.html",
    "href": "problem12_7dynamicsubmit.html",
    "title": "Problem 12.7 - Equations",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"506\"\nsigmax=reactive.Value(\"__\")\nsigmay=reactive.Value(\"__\")\ntauxy=reactive.Value(\"__\")\nsigmay1=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"An element in plane stress is subjected to stresses σ&lt;sub&gt;x&lt;/sub&gt; = {sigmax()} ksi, σ&lt;sub&gt;y&lt;/sub&gt; = {sigmay()} ksi, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tauxy()} ksi. After being inclined an angle, Θ, the stress in the new y-axis is σ&lt;sub&gt;y1&lt;/sub&gt; = {sigmay1()} ksi. Determine the stress in the new x-axis, σ&lt;sub&gt;x1&lt;/sub&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigmax.set(random.randrange(10,50,1))\n        sigmay.set(random.randrange(10,50,1))\n        tauxy.set(random.randrange(10,50,1))\n        sigmay1.set(random.randrange(1000,2000,1)/100)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        a = sigmax()-sigmay1()\n        b = -2*tauxy()\n        c = sigmay()-sigmay1()\n        tantheta1 = (-b+math.sqrt(b**2-4*a*c))/(2*a)\n        tantheta2 = (-b-math.sqrt(b**2-4*a*c))/(2*a)\n        print(tantheta1)\n        print(tantheta2)\n        theta = min(tantheta1, tantheta2)\n        instr= (sigmax()+sigmay())/2+(sigmax()-sigmay())/2*math.cos(2*theta*math.pi/180)+tauxy()*math.sin(2*theta*math.pi/180)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.7 - Equations"
    ]
  },
  {
    "objectID": "problem12_8dynamicsubmit.html",
    "href": "problem12_8dynamicsubmit.html",
    "title": "Problem 12.8 - Equations",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"507\"\nsigmax=reactive.Value(\"__\")\nsigmay=reactive.Value(\"__\")\ntheta=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A point in a beam is subjected to the state of stress shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigmax()} ksi, σ&lt;sub&gt;y&lt;/sub&gt; = {sigmay()} ksi, and τ&lt;sub&gt;xy&lt;/sub&gt; is unknown. The element is rotated through Θ = {theta()}° and the new shear stress τ&lt;sub&gt;x'y'&lt;/sub&gt; is found to be 0 ksi. Determine the original shear stress, τ&lt;sub&gt;xy&lt;/sub&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigmax.set(random.randrange(10,50,1))\n        sigmay.set(random.randrange(10,50,1))\n        theta.set(random.randrange(10,25,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (-(sigmax()-sigmay())/2*math.sin(2*theta()*math.pi/180))/math.cos(2*theta()*math.pi/180)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.8 - Equations"
    ]
  },
  {
    "objectID": "problem12_9dynamicsubmit.html",
    "href": "problem12_9dynamicsubmit.html",
    "title": "Problem 12.9 - Principal Stresses",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"508\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your 1st principal stress in units of MPa\", placeholder=\"Please enter your σ1\"),\n    ui.input_text(\"answer2\", \"Your 1st pricipal direction in units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} MPa, σ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} MPa, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} MPa. Determine the maximum principal stress σ&lt;sub&gt;1&lt;/sub&gt; for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(10, 50, 1))\n        sigma_y.set(sigma_x()+random.randrange(10, 30, 1))\n        tau_xy.set(random.randrange(10, 50, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = (sigma_x()+sigma_y())/2+math.sqrt(((sigma_x()-sigma_y())/2)**2+tau_xy()**2)\n        instr2 = 90+(math.atan(2*tau_xy()/(sigma_x()-sigma_y())))/2*180/math.pi\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n    \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.9 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_10dynamicsubmit.html",
    "href": "problem12_10dynamicsubmit.html",
    "title": "Problem 12.10 - Principal Stresses",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"509\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your maximum shear stress in units of ksi\", placeholder=\"Please enter your max shear stress\"),\n    ui.input_text(\"answer2\", \"Your angle in units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} ksi, σ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} ksi, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} ksi. Determine the maximum shear stress for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(20, 70, 1))\n        sigma_y.set(sigma_x()+random.randrange(10, 30, 1))\n        tau_xy.set(random.randrange(10, 50, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = math.sqrt(((-sigma_x()-sigma_y())/2)**2+tau_xy()**2)\n        instr2 = (math.atan((sigma_x()+sigma_y())/(2*tau_xy())))/2*180/math.pi\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n    \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.10 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_11dynamicsubmit.html",
    "href": "problem12_11dynamicsubmit.html",
    "title": "Problem 12.11 - Principal Stresses",
    "section": "",
    "text": "Figure 1: A member is subjected to a state of stress.\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"510\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your maximum shear stress in units of ksi\", placeholder=\"Please enter your max shear stress\"),\n    ui.input_text(\"answer2\", \"Your angle in units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} ksi, σ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} ksi, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} ksi. Determine the maximum shear stress for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_y.set(random.randrange(15, 60, 1))\n        sigma_x.set(sigma_y()+random.randrange(10, 30, 1))\n        tau_xy.set(random.randrange(20, 60, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = math.sqrt(((sigma_x()+sigma_y())/2)**2+tau_xy()**2)\n        instr2 = (math.atan((sigma_x()+sigma_y())/(2*tau_xy())))/2*180/math.pi\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n    \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.11 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_12dynamicsubmit.html",
    "href": "problem12_12dynamicsubmit.html",
    "title": "Problem 12.12 - Principal Stresses",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"511\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your maximum principal stress in units of MPa\", placeholder=\"Please enter your max principal stress\"),\n    ui.input_text(\"answer2\", \"Your angle in units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} MPa, σ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} MPa, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} MPa. Determine the maximum principal stress σ&lt;sub&gt;1&lt;/sub&gt; for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_y.set(random.randrange(10, 80, 1))\n        sigma_x.set(sigma_y()+random.randrange(15, 40, 1))\n        tau_xy.set(random.randrange(10, 70, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = (sigma_x()+sigma_y())/2+math.sqrt(((sigma_x()-sigma_y())/2)**2+tau_xy()**2)\n        instr2 = (math.atan((2*tau_xy())/(sigma_x()-sigma_y())))/2*180/math.pi\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n    \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.12 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_13dynamicsubmit.html",
    "href": "problem12_13dynamicsubmit.html",
    "title": "Problem 12.13 - Principal Stresses",
    "section": "",
    "text": "{fig-alt=A member is subjected to a state of stress caused by sigma_x, and sigma_y.”} [Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"512\"\nsigma_x=reactive.Value(\"__\")\nsigma_y=reactive.Value(\"__\")\ntau_max=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of degrees\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The state of stress at a point in a beam is shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} ksi, σ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} ksi, and τ&lt;sub&gt;xy&lt;/sub&gt; is unknown. The maximum shear stress for this state of stress is τ&lt;sub&gt;max&lt;/sub&gt; = {tau_max()} ksi. Determine the angle that this maximum stress occurs at.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(10, 50, 1))\n        sigma_y.set(sigma_x()+random.randrange(10, 30, 1))\n        tau_max.set(random.randrange(10, 50, 1))        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        tau_xy = math.sqrt(tau_max()**2-((sigma_x()-sigma_y())/2)**2)\n        instr= (math.atan((-sigma_x()+sigma_y())/(2*tau_xy)))/2*180/math.pi\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.13 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_14dynamicsubmit.html",
    "href": "problem12_14dynamicsubmit.html",
    "title": "Problem 12.14 - Principal Stresses",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \nproblem_ID=\"513\"\nsigmax=reactive.Value(\"__\")\nsigmay=reactive.Value(\"__\")\ntauxy=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"For the state of stress shown, determine the ratio of maximum normal stress to maximum shear stress (σ&lt;sub&gt;max&lt;/sub&gt;/τ&lt;sub&gt;max&lt;/sub&gt;). Assume σ&lt;sub&gt;x&lt;/sub&gt; = {sigmax()} ksi, σ&lt;sub&gt;y&lt;/sub&gt; = {sigmay()} ksi, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tauxy()} ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigmax.set(random.randrange(10,50,1))\n        sigmay.set(sigmax()+random.randrange(10,30,1))\n        tauxy.set(random.randrange(10,50,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigma_max = (sigmax()+sigmay())/2+math.sqrt(((sigmax()-sigmay())/2)**2+tauxy()**2)\n        tau_max = math.sqrt(((sigmax()-sigmay())/2)**2+tauxy()**2)\n        instr= sigma_max/tau_max\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.14 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_15dynamicsubmit.html",
    "href": "problem12_15dynamicsubmit.html",
    "title": "Problem 12.15 - Principal Stresses",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"514\"\na=reactive.Value(\"__\")\nFx=reactive.Value(\"__\")\nFy=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A stiff metal plate is placed on a soft rubber material of side length a = {a()} mm and is loaded as shown, where F&lt;xub&gt;x&lt;/sub&gt; = {Fx()} kN and F&lt;sub&gt;y&lt;/sub&gt; = {Fy()} kN. Determine the principal stress with the largest absolute value on the front face. Due to the stiff plate, assume F&lt;sub&gt;x&lt;/sub&gt; generates only a shear stress on the front face and F&lt;sub&gt;y&lt;/sub&gt; generates only a normal stress on the front face. Assume there is no bending stress.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        a.set(random.randrange(200,600,10))\n        Fx.set(random.randrange(10,100,1)/10)\n        Fy.set(random.randrange(10,100,1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        tau = Fx()*1000/((a()/1000)**2)\n        sigmay = -Fy()*1000/((a()/1000)**2)\n        instr= abs(sigmay/2-math.sqrt((sigmay/2)**2+tau**2))/1000000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.15 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_16dynamicsubmit.html",
    "href": "problem12_16dynamicsubmit.html",
    "title": "Problem 12.16 - Principal Stresses",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \nproblem_ID=\"515\"\nsigmay=reactive.Value(\"__\")\ntauxy=reactive.Value(\"__\")\ntaumax=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The state of stress at a point in a beam is shown, where σ&lt;sub&gt;y&lt;/sub&gt; = {sigmay()} ksi, τ&lt;sub&gt;xy&lt;/sub&gt; = {tauxy()} ksi, and σ&lt;sub&gt;x&lt;/sub&gt; is unknown. If the maximum in-plane shear stress is τ&lt;sub&gt;max&lt;/sub&gt; = {taumax()} ksi, determine σ&lt;sub&gt;x&lt;/sub&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigmay.set(random.randrange(10,50,1))\n        tauxy.set(random.randrange(10,50,1))\n        taumax.set(tauxy()+random.randrange(10,20,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= 2*math.sqrt(taumax()**2-tauxy()**2)+sigmay()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.16 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_17dynamicsubmit.html",
    "href": "problem12_17dynamicsubmit.html",
    "title": "Problem 12.17 - Principal Stresses",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"517\"\nL=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A short S6 x 12.5 steel beam of length L = {L()} ft supports a single load F = {F()} lb as shown. Determine the maximum in-plane shear stress at point A. Include the weight of the beam.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(20,100,1)/10)\n        F.set(random.randrange(300,1000,10))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        V = F()+L()*12.5\n        M = 12.5*L()*L()*12/2+F()*L()*12\n        sigma_b = -M*-3.359/22.1\n        Q = -3.374\n        tau = V*Q/(22.1*.232)\n        instr= math.sqrt((sigma_b/2)**2+tau**2)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.17 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_18dynamicsubmit.html",
    "href": "problem12_18dynamicsubmit.html",
    "title": "Problem 12.18 - Principal Stresses",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"518\"\nMx=reactive.Value(\"__\")\nMz=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A solid circular steel bar is loaded with two moments at the free end as shown, where M&lt;sub&gt;x&lt;/sub&gt; = {Mx()} N-m and M&lt;sub&gt;z&lt;/sub&gt; = {Mz()} N-m. If length L = {L()} mm and diameter d = {d()} mm, determine the maximum normal stress (for any coordinate direction) at point A. Hint: M&lt;sub&gt;x&lt;/sub&gt; causes a torsion stress while M&lt;sub&gt;z&lt;/sub&gt; causes a bending stress.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        Mx.set(random.randrange(100,500,10))\n        Mz.set(random.randrange(100,500,10))\n        L.set(random.randrange(200,1000,10))\n        d.set(random.randrange(30,80,2))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        tau = Mx()*d()/2000/(math.pi*(d()/2000)**4/2)\n        sigma_b = -Mz()*d()/2000/(math.pi*(d()/2000)**4/4)\n        instr= (sigma_b/2+math.sqrt((sigma_b/2)**2+tau**2))/1000000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.18 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_25dynamicsubmit.html",
    "href": "problem12_25dynamicsubmit.html",
    "title": "Problem 12.25 - Mohr’s Circle",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"524\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your 1st principal stress in units of ksi\", placeholder=\"Please enter your σ1\"),\n    ui.input_text(\"answer2\", \"Your angle in units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} ksi, σ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} ksi, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} ksi. Construct Mohr's Circle for the given state of stress. Then determine the maximum principal stress σ&lt;sub&gt;1&lt;/sub&gt; for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(20, 80, 1))\n        sigma_y.set(sigma_x()+random.randrange(5, 30, 1))\n        tau_xy.set(random.randrange(20, 60, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = (sigma_x()-sigma_y())/2+math.sqrt(((sigma_x()+sigma_y())/2)**2+tau_xy()**2)\n        instr2 = (math.atan(2*tau_xy()/(sigma_x()+sigma_y())))/2*180/math.pi\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.25 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_26dynamicsubmit.html",
    "href": "problem12_26dynamicsubmit.html",
    "title": "Problem 12.26 - Mohr’s Circle",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"525\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your 1st principal stress in units of MPa\", placeholder=\"Please enter your σ1\"),\n    ui.input_text(\"answer2\", \"Your angle in units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} MPa, σ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} MPa, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} MPa. Construct Mohr's Circle for the given state of stress. Then determine the maximum principal stress σ&lt;sub&gt;1&lt;/sub&gt; for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(10, 40, 1))\n        sigma_y.set(sigma_x()+random.randrange(10, 20, 1))\n        tau_xy.set(random.randrange(10, 40, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = (sigma_x()+sigma_y())/2+math.sqrt(((sigma_x()-sigma_y())/2)**2+tau_xy()**2)\n        instr2 = (math.atan(2*tau_xy()/(sigma_x()-sigma_y())))/2*180/math.pi+90\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.26 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_27dynamicsubmit.html",
    "href": "problem12_27dynamicsubmit.html",
    "title": "Problem 12.27 - Mohr’s Circle",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"526\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your maximum in-plane shear stress in units of MPa\", placeholder=\"Please enter your max in-plane shear stress\"),\n    ui.input_text(\"answer2\", \"Your angle in units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} MPa, σ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} MPa, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} MPa. Construct Mohr's Circle for the given state of stress. Then determine the maximum in-plane shear stress τ&lt;sub&gt;max&lt;/sub&gt; for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_y.set(random.randrange(15, 45, 1))\n        sigma_x.set(sigma_y()+random.randrange(5, 20, 1))\n        tau_xy.set(random.randrange(10, 40, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = math.sqrt(((sigma_x()-sigma_y())/2)**2+tau_xy()**2)\n        instr2 = (math.atan((sigma_x()-sigma_y())/(2*-tau_xy())))/2*180/math.pi\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.27 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_28dynamicsubmit.html",
    "href": "problem12_28dynamicsubmit.html",
    "title": "Problem 12.28 - Mohr’s Circle",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"527\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your maximum principal stress in units of ksi\", placeholder=\"Please enter your σ1\"),\n    ui.input_text(\"answer2\", \"Your angle in units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} ksi, σ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} ksi, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} ksi. Construct Mohr's Circle for the given state of stress. Then determine the maximum principal stress σ&lt;sub&gt;1&lt;/sub&gt; for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_y.set(random.randrange(10, 50, 1))\n        sigma_x.set(sigma_y()+random.randrange(10, 30, 1))\n        tau_xy.set(random.randrange(10, 50, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = (-sigma_x()+sigma_y())/2+math.sqrt(((-sigma_x()-sigma_y())/2)**2+tau_xy()**2)\n        instr2 = (math.atan(2*-tau_xy()/(-sigma_x()-sigma_y())))*180/math.pi/2+90\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.28 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_29dynamicsubmit.html",
    "href": "problem12_29dynamicsubmit.html",
    "title": "Problem 12.29 - Mohr’s Circle",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"529\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your 1st principal stress in units of ksi\", placeholder=\"Please enter your σ1\"),\n    ui.input_text(\"answer2\", \"Your angle units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} ksi, σ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} ksi, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} ksi. Construct Mohr's Circle for the given state of stress. Then determine the maximum principal stress σ&lt;sub&gt;1&lt;/sub&gt; for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(12, 57, 1))\n        sigma_y.set(sigma_x()+random.randrange(11, 29, 1))\n        tau_xy.set(random.randrange(12, 57, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = (sigma_x()-sigma_y())/2+math.sqrt(((sigma_x()+sigma_y())/2)**2+tau_xy()**2)\n        instr2 = (math.atan(2*tau_xy()/(sigma_x()+sigma_y())))*180/math.pi/2\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.29 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_30dynamicsubmit.html",
    "href": "problem12_30dynamicsubmit.html",
    "title": "Problem 12.30 - Mohr’s Circle",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"530\"\nsigmax = reactive.Value(\"__\")\nsigmay = reactive.Value(\"__\")\ntauxy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of ksi\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of degrees\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"The state of stress at a point in a beam is shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigmax()} ksi, σ&lt;sub&gt;y&lt;/sub&gt; = {sigmay()} ksi, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tauxy()} ksi. Construct Mohr's Circle for the given state of stress. Then determine the minimum principal stress σ&lt;sub&gt;2&lt;/sub&gt; for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigmax.set(random.randrange(10,50,1))\n        sigmay.set(sigmax()+random.randrange(10,30,1))\n        tauxy.set(random.randrange(10,50,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        sigma_avg = (-sigmax()+sigmay())/2\n        R = (((-sigmax()-sigmay())/2)**2+tauxy()**2)**0.5\n        instr1 = sigma_avg-R\n        instr2 = 180-(math.atan(sigmay()/(sigmax()))*180/math.pi)\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2'}\"\n        else:\n            check = f\"{'both incorrect'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.30 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_31dynamicsubmit.html",
    "href": "problem12_31dynamicsubmit.html",
    "title": "Problem 12.31 - Mohr’s Circle",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"531\"\nsigmax = reactive.Value(\"__\")\nsigmay = reactive.Value(\"__\")\ntauxy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of MPa\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of degrees\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"The state of stress at a point in a beam is shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigmax()} MPa, σ&lt;sub&gt;y&lt;/sub&gt; = {sigmay()} MPa, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tauxy()} MPa. Construct Mohr's Circle for the given state of stress. Then determine the maximum in-plane shear stress τ&lt;sub&gt;max&lt;/sub&gt; for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigmay.set(random.randrange(10,50,1))\n        sigmax.set(sigmay()+random.randrange(10,30,1))\n        tauxy.set(random.randrange(10,50,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        instr1 = (((-sigmax()+sigmay())/2)**2+tauxy()**2)**0.5\n        instr2 = 180+(math.atan(sigmay()/(sigmax()))*180/math.pi)\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2'}\"\n        else:\n            check = f\"{'both incorrect'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.31 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_32dynamicsubmit.html",
    "href": "problem12_32dynamicsubmit.html",
    "title": "Problem 12.32 - Mohr’s Circle",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"532\"\nsigmax = reactive.Value(\"__\")\nsigmay = reactive.Value(\"__\")\ntauxy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of MPa\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of degrees\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"The state of stress at a point in a beam is shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigmax()} MPa, σ&lt;sub&gt;y&lt;/sub&gt; = {sigmay()} MPa, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tauxy()} MPa. Construct Mohr's Circle for the given state of stress. Then determine the minimum principal stress σ&lt;sub&gt;2&lt;/sub&gt; for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigmay.set(random.randrange(10,50,1))\n        sigmax.set(sigmay()+random.randrange(10,30,1))\n        tauxy.set(random.randrange(10,50,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        instr1 = (-sigmax()-sigmay())/2-(((-sigmax()+sigmay())/2)**2+tauxy()**2)**0.5\n        instr2 = 180+(math.atan(sigmay()/(sigmax()))*180/math.pi)\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2'}\"\n        else:\n            check = f\"{'both incorrect'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.32 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_39dynamicsubmit.html",
    "href": "problem12_39dynamicsubmit.html",
    "title": "Problem 12.39 - 3D Mohr’s Circle",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"686\"\nsigma1 = reactive.Value(\"__\")\nsigma2 = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your max in-plane stress in units of MPa\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your max absolute stress in units of MPa\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A plane stress state results in principal stress σ&lt;sub&gt;1&lt;/sub&gt; = {sigma1()} MPa and σ&lt;sub&gt;2&lt;/sub&gt; = -{sigma2()} MPa. Use Mohr's Circle to determine the maximum in-plane and maximum absolute shear stresses.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma1.set(random.randrange(200, 500, 5))\n        sigma2.set(random.randrange(100, 400, 5))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = (sigma1()+sigma2())/2\n        instr2 = (sigma1()+sigma2())/2\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.39 - 3D Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_40dynamicsubmit.html",
    "href": "problem12_40dynamicsubmit.html",
    "title": "Problem 12.40 - 3D Mohr’s Circle",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"687\"\nsigma1 = reactive.Value(\"__\")\ntau_max = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your σ2 in units of ksi\", placeholder=\"Please enter your σ2\"),\n    ui.input_text(\"answer2\", \"Your max absolute shear stress in units of ksi\", placeholder=\"Please enter your shear stress\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A plane stress state results in principal stress σ&lt;sub&gt;1&lt;/sub&gt; = {sigma1()} ksi and τ&lt;sub&gt;max-in-plane&lt;/sub&gt; = {tau_max()} ksi. Use Mohr's Circle to determine σ&lt;sub&gt;2&lt;/sub&gt; and the maximum absolute shear stresses.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma1.set(random.randrange(10, 50, 1))\n        tau_max.set(sigma1()*random.randrange(20, 40, 1)/100)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = sigma1()-2*tau_max()\n        instr2 = sigma1()/2\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.40 - 3D Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_41dynamicsubmit.html",
    "href": "problem12_41dynamicsubmit.html",
    "title": "Problem 12.41 - 3D Mohr’s Circle",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"688\"\nsigmax = reactive.Value(\"__\")\nsigmay = reactive.Value(\"__\")\ntauxy = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Answer3,Answer4,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of MPa\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of MPa\", placeholder=\"Please enter your answer 2\"),\n    ui.input_text(\"answer3\", \"Your Answer 3 in units of MPa\", placeholder=\"Please enter your answer 3\"),\n    ui.input_text(\"answer4\", \"Your Answer 4 in units of MPa\", placeholder=\"Please enter your answer 4\"),\n\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A state of plane stress is shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigmax()} MPa, σ&lt;sub&gt;y&lt;/sub&gt; = {sigmay()} MPa, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tauxy()} MPa. Use Mohr's circle to determine the principal stresses, the maximum in-plane shear stress, and the maximum absolute shear stress.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigmax.set(random.randrange(250,750,1))\n        sigmay.set(random.randrange(250,750,1))\n        tauxy.set(random.randrange(200,500,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        sigmaavg=(sigmax()+sigmay())/2\n        R=math.sqrt(tauxy()**2+(sigmax()-sigmaavg)**2)\n        instr1 = sigmaavg+R\n        instr2 = sigmaavg-R\n        instr3= R\n        instr4= instr1/2\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        correct3 = math.isclose(float(input.answer3()), instr3, rel_tol=0.01)\n        correct4 = math.isclose(float(input.answer4()), instr4, rel_tol=0.01)\n        \n        if correct1 and correct2 and correct3 and correct4:\n            check = \"All answers are correct.\"\n        else:\n            conditions = []\n            for i, correct in enumerate([correct1, correct2, correct3, correct4], start=1):\n                if correct:\n                    conditions.append(f\"correct for answer {i}\")\n                else:\n                    conditions.append(f\"incorrect for answer {i}\")\n            check = \"; \".join(conditions) + \".\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 and correct3 and correct4 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()}, {input.answer2()}, {input.answer3()}, and {input.answer4()} are {check} For reference in debugging this, the calculated instructor answers are {instr1}, {instr2}, {instr3}, and {instr4}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.41 - 3D Mohr's Circle"
    ]
  },
  {
    "objectID": "problem13_1dynamicsubmit.html",
    "href": "problem13_1dynamicsubmit.html",
    "title": "Problem 13.1 - Cylindrical",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"556\"\nd=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\nT=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A thin-walled cylindrical pressure vessel with an outside diameter d = {d()} in. is subjected to an internal pressure P = {P()} psi and an external torque T = {T()} kip-in. at its top. The base is fixed to the ground. If the vessel wall thickness is t = {t()} in., determine the absolute largest principal stress in the vessel wall.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(10, 30, 1))\n        P.set(random.randrange(100, 500, 10))\n        T.set(random.randrange(200, 800, 10))\n        t.set(random.randrange(2, 8, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        J =  math.pi*((d()/2)**4-(d()/2-t())**4)/2\n        tau_ha = T()*d()/2/J\n        sigma_a = P()*(d()/2-t())/(2*t())/1000\n        sigma_h = P()*(d()/2-t())/t()/1000\n        instr= ((sigma_a+sigma_h)/2+math.sqrt(((sigma_h-sigma_a)/2)**2+tau_ha**2))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 13 Problems",
      "Problem 13.1 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_2dynamicsubmit.html",
    "href": "problem13_2dynamicsubmit.html",
    "title": "Problem 13.2 - Cylindrical",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"558\"\nd=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cylindrical pressure vessel of outer diameter d = {d()} mm experiences an internal pressure P = {P()} kPa. Determine the maximum in-plane shear stress in the vessel wall if the wall thickness is t = {t()} mm.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(500, 1000, 10))\n        P.set(random.randrange(100, 1000, 1)/10)\n        t.set(random.randrange(10, 50, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigma_a = P()*(d()/2-t())/(2*t())\n        sigma_h = P()*(d()/2-t())/t()\n        instr= (math.sqrt(((-sigma_h+sigma_a)/2)**2))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 13 Problems",
      "Problem 13.2 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_3dynamicsubmit.html",
    "href": "problem13_3dynamicsubmit.html",
    "title": "Problem 13.3 - Cylindrical",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"559\"\nri=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A gas storage tank with an internal radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} in. and wall thickness t = {t()} in. is filled to an internal pressure P = {P()} psi. If the original length L = {L()} ft., determine the total axial deflection (change in length) of the tank after filling. Assume E = 29,000 ksi and ν = 0.3.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        ri.set(random.randrange(10, 25, 1))\n        t.set(random.randrange(2, 8, 1)/10)\n        P.set(random.randrange(1000, 5000, 100))\n        L.set(random.randrange(10, 25, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigma_a = P()*ri()/(2*t())/1000\n        sigma_h = P()*ri()/t()/1000\n        v = 0.3\n        E = 29000\n        e = (sigma_a-v*sigma_h)/E\n        instr= L()*12*e\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 13 Problems",
      "Problem 13.3 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_4dynamicsubmit.html",
    "href": "problem13_4dynamicsubmit.html",
    "title": "Problem 13.4 - Cylindrical",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random str ling ofetters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"563\"\ndi=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cylindrical thin-walled pressure vessel with an inner diameter d&lt;sub&gt;i&lt;/sub&gt; = {di()} mm is subjected to an unknown internal pressure, P. A vertical load F = {F()} kN is also applied to the vessel as shown. If length L = {L()} m and the wall thickness t = {t()} mm, what pressure will cause the axial and hoop stresses to be equal?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        di.set(random.randrange(200, 500, 10))\n        F.set(random.randrange(5, 25, 1)/10)\n        L.set(random.randrange(10, 50, 1)/10)\n        t.set(random.randrange(1, 10, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigma_f = F()*1000/(math.pi*((di()/2000+t()/1000)**2-(di()/2000)**2))/1000\n        instr= (2*t()/1000*sigma_f/(di()/2000))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 13 Problems",
      "Problem 13.4 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_5dynamicsubmit.html",
    "href": "problem13_5dynamicsubmit.html",
    "title": "Problem 13.5 - Cylindrical",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"569\"\ntheta=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of GPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cylindrical pressure vessel is welded together at angle Θ = {theta()}° as shown. Determine the normal stress on the welded seam if the internal pressure P = {P()} MPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        theta.set(random.randrange(20,40,1))\n        P.set(random.randrange(50,250,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigma_a = (P()*1/0.02)/1000\n        sigma_h = 2*sigma_a\n        instr= (sigma_a+sigma_h)/2+(sigma_a-sigma_h)/2*math.cos(theta()*math.pi/180)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 13 Problems",
      "Problem 13.5 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_6dynamicsubmit.html",
    "href": "problem13_6dynamicsubmit.html",
    "title": "Problem 13.6 - Cylindrical",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"570\"\nP=reactive.Value(\"__\")\ngage=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A strain gage is attached to a cylindrical pressure vessel in the hoop direction. When the pressure in the tank, P = {P()} MPa, the strain gage reads {gage()} x 10&lt;sup&gt;-6&lt;/sup&gt;. If the inner radius of the tank is r&lt;sub&gt;i&lt;/sub&gt; = {ri()} mm, determine the wall thickness t. Assume E = 210 GPa and ν = 0.3.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        P.set(random.randrange(10,100,1)/10)\n        gage.set(random.randrange(150,250,1))\n        ri.set(random.randrange(100,200,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (2*P()*ri()-0.3*P()*ri())/(2*210*10**3*gage()*10**(-6))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 13 Problems",
      "Problem 13.6 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_7dynamicsubmit.html",
    "href": "problem13_7dynamicsubmit.html",
    "title": "Problem 13.7 - Cylindrical",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"572\"\nP=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of 10\\u207B\\u2076\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A strain gage is attached to a cylindrical pressure vessel in the hoop direction. The tank has dimensions r&lt;sub&gt;i&lt;/sub&gt; = {ri()} m and t = {t()} mm. If the pressure in the tank, P = {P()} MPa, determine the value on the strain gage. Assume E = 210 GPa and ν = 0.3.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        P.set(random.randrange(50,150,1)/10)\n        t.set(random.randrange(20,60,1))\n        ri.set(random.randrange(10,20,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= ((P()*ri()/(t()/1000)-0.3*P()*ri()/(2*t()/1000))/(210*10**3))*10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 13 Problems",
      "Problem 13.7 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_8dynamicsubmit.html",
    "href": "problem13_8dynamicsubmit.html",
    "title": "Problem 13.8 - Cylindrical",
    "section": "",
    "text": "[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"689\"\nri = reactive.Value(\"__\")\nt = reactive.Value(\"__\")\nsigmay = reactive.Value(\"__\")\ntallow = reactive.Value(\"__\")\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer 1 in units of ksi\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer 2 in units of ksi\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A thin-walled cylinder with inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} in. and wall thickness t = {t()} in. is made of steel with yield stress σ&lt;sub&gt;y&lt;/sub&gt; = {sigmay()} ksi and allowable shear stress τ&lt;sub&gt;allow&lt;/sub&gt; = {tallow()} ksi. Determine the internal pressure at which the cylinder would yeild due to tension and the internal pressure at which the cylinder would yield due to shear.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        ri.set(random.randrange(5,25,1))\n        t.set(random.randrange(2,10,1)/10)\n        sigmay.set(random.randrange(30,50,1))\n        tallow.set(sigmay()*random.randrange(40,60,1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n\n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        instr1 = sigmay()*t()/ri()\n        instr2 = 2*tallow()*t()/ri()\n\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = f\"{'both correct.'}\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}. For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 13 Problems",
      "Problem 13.8 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_14dynamicsubmit.html",
    "href": "problem13_14dynamicsubmit.html",
    "title": "Problem 13.14 - Cylindrical",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"504\"\nsigmax=reactive.Value(\"__\")\nsigmay=reactive.Value(\"__\")\ntauxy=reactive.Value(\"__\")\ntheta=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The state of stress on the side of a pressure tank is shown, where σ&lt;sub&gt;x&lt;/sub&gt; = {sigmax()} ksi, σ&lt;sub&gt;y&lt;/sub&gt; = {sigmay()} ksi, and τ&lt;sub&gt;xy&lt;/sub&gt; = {tauxy()} ksi Determine the normal stress in the axial (horizontal) direction if Θ = {theta()}°.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigmax.set(random.randrange(10,50,1))\n        sigmay.set(random.randrange(10,50,1))\n        tauxy.set(random.randrange(10,50,1))\n        theta.set(random.randrange(30,40,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (sigmax()+sigmay())/2+(sigmax()-sigmay())/2*math.cos(2*theta()*math.pi/180)+tauxy()*(2*theta()*math.pi/180)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 13 Problems",
      "Problem 13.14 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_15dynamicsubmit.html",
    "href": "problem13_15dynamicsubmit.html",
    "title": "Problem 13.15 - Spherical",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"554\"\nP=reactive.Value(\"__\")\nsigma_fail=reactive.Value(\"__\")\nFS=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A balloon with a wall thickness of 0.02 in. is inflated to a pressure of {P()} psi. If the balloon material fails in tension at {sigma_fail()} psi, what is the maximum radius of the balloon using a factor of safety of {FS()}?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        P.set(random.randrange(20, 60, 1))\n        sigma_fail.set(random.randrange(5000, 10000, 100))\n        FS.set(random.randrange(15, 30, 1)/10)        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= sigma_fail()/FS()*2*0.02/P()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 13 Problems",
      "Problem 13.15 - Spherical"
    ]
  },
  {
    "objectID": "problem13_16dynamicsubmit.html",
    "href": "problem13_16dynamicsubmit.html",
    "title": "Problem 13.16 - Spherical",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random str ling ofetters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"563\"\nsigma_yield=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\ndi=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A spherical thin-walled pressure vessel is to be constructed of steel with a yield stress of {sigma_yield()} ksi and a wall thickness t = {t()} in. If the internal diameter of the tank is d&lt;sub&gt;i&lt;/sub&gt; = {di()} ft, determine the maximum allowable pressure before yielding.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_yield.set(random.randrange(40, 65, 1))\n        t.set(random.randrange(2, 8, 1)/10)\n        di.set(random.randrange(10, 30, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= 2*sigma_yield()*t()/(di()*6)*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 13 Problems",
      "Problem 13.16 - Spherical"
    ]
  },
  {
    "objectID": "problem14_1dynamicsubmit.html",
    "href": "problem14_1dynamicsubmit.html",
    "title": "Problem 14.1 - Eccentric Axial Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"481\"\nw=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A large column supports a cantilevered load W = {w()} kips as shown. Dimensions b = {b()} ft, h = {h()} ft, L&lt;sub&gt;1&lt;/sub&gt; = {L1()} ft, and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} ft. What is the magnitude of the compressive stress at point A? Assume the cantilevered beam does not fail or bend. Enter a negative sign if the stress is compressive\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(5, 50, 1))\n        b.set(random.randrange(1, 5, 1))\n        h.set(b()*2)\n        L1.set(b()*5)\n        L2.set(random.randrange(5, 15, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (-w()/(b()*h())-(6*w()*L2()*math.cos(60*math.pi/180))/(b()**2*h())-(6*w()*L2()*math.sin(60*math.pi/180)/(h()**2*b())))*6.944444\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 14 Problems",
      "Problem 14.1 - Eccentric Axial Loads"
    ]
  },
  {
    "objectID": "problem14_2dynamicsubmit.html",
    "href": "problem14_2dynamicsubmit.html",
    "title": "Problem 14.2 - Eccentric Axial Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"482\"\nF=reactive.Value(\"__\")\ny=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A metal electric pole supporting a load F = {F()} kN was knocked at an angle during a recent storm. If dimensions x = {x()} mm, y = {y()} mm, and L = {L()} m, determine the magnitude of the maximum normal stress at the base.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(10, 90, 1))\n        y.set(random.randrange(500, 1000, 10))\n        x.set(y()*2)\n        L.set(random.randrange(5, 12, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        M = math.sqrt((x()/1000)**2+(y()/1000)**2)*F()*1000\n        sigmaB = M*0.1/(4637*10**-8)\n        sigmaA = F()*1000/(math.pi*(0.1**2-0.08**2))\n        instr= abs((sigmaA+sigmaB)/10**6)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 14 Problems",
      "Problem 14.2 - Eccentric Axial Loads"
    ]
  },
  {
    "objectID": "problem14_3dynamicsubmit.html",
    "href": "problem14_3dynamicsubmit.html",
    "title": "Problem 14.3 - Eccentric Axial Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"488\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A load F = {F()} kip acts on the corner of a small cube of side length L = {L()} in. Determine the magnitude of the combined axial and bending stress at point A.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(50,300,1)/10)\n        L.set(random.randrange(20,120,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        M = F()*L()/2\n        I = L()*L()**3/12\n        sigmaa = -F()/(L()**2)\n        sigmab = M*-L()/2/I-M*L()/2/I\n        instr = sigmaa+sigmab\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 14 Problems",
      "Problem 14.3 - Eccentric Axial Loads"
    ]
  },
  {
    "objectID": "problem14_4dynamicsubmit.html",
    "href": "problem14_4dynamicsubmit.html",
    "title": "Problem 14.4 - Eccentric Axial Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"495\"\nL=reactive.Value(\"__\")\na=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\ntheta=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A circular disk sits on top of a vertical post of length L = {L()} ft. The post has a square cross-section of side length a = {a()} in. A concentrated load F = {F()} kips acts in the vertical direction at distance d = {d()} in. from the center as shown, where angle Θ = {theta()}°. Determine the maximum absolute stress in the post. Assume the disk does not bend and neglect the weight of the disk and post.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(100,300,1)/10)\n        a.set(random.randrange(5,10,1))\n        F.set(random.randrange(10,100,1)/10)\n        d.set(a()+random.randrange(2,4,1))\n        theta.set(random.randrange(30,40,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        dz=d()*math.cos(theta()*math.pi/180)\n        dy=d()*math.sin(theta()*math.pi/180)\n        Mz=F()*1000*dz\n        My=F()*1000*dy\n        I=a()**4/12\n        instr= -F()*1000/(a()**2)+My*-a()/2/I-Mz*-a()/2/I\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 14 Problems",
      "Problem 14.4 - Eccentric Axial Loads"
    ]
  },
  {
    "objectID": "problem14_9dynamicsubmit.html",
    "href": "problem14_9dynamicsubmit.html",
    "title": "Problem 14.9 - General Combined Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\n\nproblem_ID = \"519\"\nL = reactive.Value(\"__\")\nr = reactive.Value(\"__\")\nF = reactive.Value(\"__\")\nT = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\n        \"**Please enter your ID number from your instructor and click to generate your problem**\"\n    ),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\n        \"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"\n    ),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\n        \"answer\", \"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"\n    ),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A solid circular rod of length L = {L()} m and radius r = {r()} mm is subjected to axial load F = {F()} kN and torsional moment T = {T()} kN-m. Determine the absolute maximum shear stress (for any coordinate direction) at any location in the bar.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(2, 10, 1))\n        r.set(random.randrange(20, 50, 1))\n        F.set(random.randrange(50, 150, 1))\n        T.set(random.randrange(10, 30, 1) / 10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        tau_xy = 2 * T() * 1000 / (math.pi * (r() / 1000) ** 3) / 10**6\n        sigma_y = F() * 1000 / (math.pi * (r() / 1000) ** 2) / 10**6\n        instr = math.sqrt((-sigma_y / 2) ** 2 + tau_xy**2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(\n            f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\"\n        )\n\n        # Show feedback to the user.\n        feedback = ui.markdown(\n            f\"Your answer of {input.answer()} is {check}.\"\n        )\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = (\n            session.encoded_attempt()\n            if session.encoded_attempt is not None\n            else \"No attempts\"\n        )\n        yield f\"{final_encoded}\\n\\n\"\n\n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n\n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(\n                0.25\n            )  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 14 Problems",
      "Problem 14.9 - General Combined Loads"
    ]
  },
  {
    "objectID": "problem14_10dynamicsubmit.html",
    "href": "problem14_10dynamicsubmit.html",
    "title": "Problem 14.10 - General Combined Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"521\"\nL=reactive.Value(\"__\")\nr=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nT=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A solid circular rod of length L = {L()} ft and radius r = {r()} in. is subjected to load F = {F()} kips and torsional moment T = {T()} kip-in. Determine the maximum principal stress at point A.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10, 50, 1)/10)\n        r.set(random.randrange(10, 30, 1)/10)\n        F.set(random.randrange(10, 100, 1)/10)\n        T.set(random.randrange(100, 300, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        tau_xy = 2*T()/(math.pi*r()**3)\n        sigma_x = F()*L()*48/(math.pi*r()**3)\n        instr= sigma_x/2+math.sqrt((sigma_x/2)**2+tau_xy**2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 14 Problems",
      "Problem 14.10 - General Combined Loads"
    ]
  },
  {
    "objectID": "problem14_11dynamicsubmit.html",
    "href": "problem14_11dynamicsubmit.html",
    "title": "Problem 14.11 - General Combined Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"522\"\nL=reactive.Value(\"__\")\nr=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nT=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A solid circular rod of length L = {L()} m and radius r = {r()} mm is subjected to load F = {F()} kN and torsional moment T = {T()} kN-m. Determine the magnitude of the absolute maximum normal stress at point A.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10, 50, 1)/10)\n        r.set(random.randrange(20, 50, 1))\n        F.set(random.randrange(15, 50, 1)/10)\n        T.set(random.randrange(5, 30, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        tau_xy = 2*T()*1000/(math.pi*(r()/1000)**3)/10**6\n        sigma_x = 4000*F()*L()/(math.pi*(r()/1000)**3)/10**6\n        sigma1= -sigma_x/2+math.sqrt((sigma_x/2)**2+tau_xy**2)\n        sigma2= -sigma_x/2-math.sqrt((sigma_x/2)**2+tau_xy**2)\n        instr = max(abs(sigma1),abs(sigma2))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 14 Problems",
      "Problem 14.11 - General Combined Loads"
    ]
  },
  {
    "objectID": "problem14_18dynamicsubmit.html",
    "href": "problem14_18dynamicsubmit.html",
    "title": "Problem 14.18 - General Combined Loads",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"567\"\nL=reactive.Value(\"__\")\nW=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cylindrical pressure vessel of length L = {L()} ft is supported by pin joints at each end as shown. The vessel's weight W = {W()} lb/ft and the internal pressure P = {P()} psi. Determine the maximum combined axial stress at the bottom of the vessel.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50,100,1)/10)\n        W.set(random.randrange(50,150,1))\n        P.set(random.randrange(200,400,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        M = (W()*L()/2*L()/2-W()*L()/2*L()/4)*12\n        sigma_b = M*5.125/50.96\n        sigma_a = P()*5/0.25\n        instr= sigma_b+sigma_a\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 14 Problems",
      "Problem 14.18 - General Combined Loads"
    ]
  },
  {
    "objectID": "problem15_1dynamicsubmit.html",
    "href": "problem15_1dynamicsubmit.html",
    "title": "Problem 15.1 - Buckling & Yield - Euler’s Formula",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random str ling ofetters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"607\"\nL=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A steel (E = 200 GPa) tube column with a yield strength of 250 MPa is pinned at both ends. If length L = {L()} m, outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} mm and inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} mm, determine the maximum allowable load the column can support.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50, 100, 1)/10)\n        ro.set(random.randrange(50, 150, 1))\n        ri.set(ro()-random.randrange(5, 10, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = math.pi/4*(ro()**4-ri()**4)\n        E = 200*10**9\n        instr= (math.pi**2*E*I/10**12/L()**2)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.1 - Buckling & Yield - Euler's Formula"
    ]
  },
  {
    "objectID": "problem15_2dynamicsubmit.html",
    "href": "problem15_2dynamicsubmit.html",
    "title": "Problem 15.2 - Buckling & Yield - Euler’s Formula",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"610\"\nL=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A W14 x 34 beam is used as a column that is pinned at both ends. If length L = {L()} ft and the elastic modulus E = {E()} x 10&lt;sup&gt;6&lt;/sup&gt; psi, determine the critical stress for the column.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(15, 40, 1))\n        E.set(random.randrange(250, 350, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        A = 10\n        I = 23.3\n        instr= math.pi**2*E()*10**6*I/(A*144*L()**2)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.2 - Buckling & Yield - Euler's Formula"
    ]
  },
  {
    "objectID": "problem15_3dynamicsubmit.html",
    "href": "problem15_3dynamicsubmit.html",
    "title": "Problem 15.3 - Buckling & Yield - Euler’s Formula",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"611\"\nF=reactive.Value(\"__\")\nFS=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A column is pinned at both ends and supports a load F = {F()} kN. Determine the maximum allowable column length, L. Use a factor of safety of {FS()} and assume the elastic modulus E = {E()} GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(200, 800, 10))\n        FS.set(random.randrange(15, 30, 1)/10)\n        E.set(random.randrange(170, 250, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = 3.32875*10**-5\n        instr= math.sqrt(math.pi**2*E()*10**9*I/(F()*10**3*FS()))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.3 - Buckling & Yield - Euler's Formula"
    ]
  },
  {
    "objectID": "problem15_4dynamicsubmit.html",
    "href": "problem15_4dynamicsubmit.html",
    "title": "Problem 15.4 - Buckling & Yield – Euler’s Formula",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"608\"\na=reactive.Value(\"__\")\nFS=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A truss is constructed from members with square cross-sections of side length a = {a()} in. If length L = 4 ft and a factor of safety of {FS()} is required, determine the largest load P that may be applied. Consider only buckling failure. assume E = 29,000 ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        a.set(random.randrange(10,30,1)/10)\n        FS.set(random.randrange(15,30,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = a()**4/12\n        ratio1 = 3/5\n        ratio2 = 3/4\n        P1 = math.pi**2*29000*I/((5*12)**2)*ratio1\n        P2 = math.pi**2*29000*I/((4*12)**2)*ratio2\n        load = max(P1,P2)\n        instr= load/FS()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.4 - Buckling & Yield – Euler's Formula"
    ]
  },
  {
    "objectID": "problem15_5dynamicsubmit.html",
    "href": "problem15_5dynamicsubmit.html",
    "title": "Problem 15.5",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"613\"\nd=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of lb\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A simple frame is constructed from members with a solid circular cross-section of diameter d = {d()} in. If length L = {L()} ft, determine the maximum load F that may be applied before a member buckles or yields. Assume E = 29,000 ksi and yield stress σ&lt;sub&gt;y&lt;/sub&gt; = 36 ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(10,30,1)/10)\n        L.set(random.randrange(30,80,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = math.pi*d()**4/64\n        A = math.pi*(d()/2)**2\n        Hyp = ((L()*12)**2+(L()*12)**2)**0.5\n        instr= math.pi**2*29000000*0.017/(Hyp**2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.5"
    ]
  },
  {
    "objectID": "problem15_6dynamicsubmit.html",
    "href": "problem15_6dynamicsubmit.html",
    "title": "Problem 15.6",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"614\"\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Horizontal beam AB is pin-supported at A and carries load F at point B. The beam is supported in it's center by a pinned column, where distance d = {d()} m. The column is a steel tube of length L = {L()} m, outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} mm, and inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} mm. Determine the maximum load F that may be applied before the column buckles or yields. Assume E = 200 GPa and yield stress σ&lt;sub&gt;y&lt;/sub&gt; = 340 MPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(20,60,1)/10)\n        d.set(round(L()*0.8,2))\n        ri.set(random.randrange(30,80,1))\n        ro.set(ri()+random.randrange(5,15,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = math.pi*((ro()/1000)**4-(ri()/1000)**4)/4\n        A = math.pi*((ro()/1000)**2-(ri()/1000)**2)\n        Pcr = math.pi**2*200*10**9*I/(L())\n        sigma_cr = Pcr/A\n        if sigma_cr &gt; 340*10**6:\n            Pcr2 = 340000*A\n            instr = Pcr2/2\n        else:\n            instr = Pcr/2\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.6"
    ]
  },
  {
    "objectID": "problem15_7dynamicsubmit.html",
    "href": "problem15_7dynamicsubmit.html",
    "title": "Problem 15.7",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"615\"\nL=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A wall bracket is constructed from steel pipe of outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} mm and inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} mm. If length L = {L()} m, determine the maximum load F that may be applied to avoid buckling. Assume E = 190 GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10,50,1)/10)\n        ri.set(random.randrange(30,150,5)/100)\n        ro.set(ri()+random.randrange(10,30,5)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = math.pi*((ro()/1000)**4-(ri()/1000)**4)/4\n        Pcr = math.pi**2*190*10**9*I/(L()**2)\n        FCA = Pcr/math.cos(30*math.pi/180)\n        instr = FCA*math.sin(30*math.pi/180)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.7"
    ]
  },
  {
    "objectID": "problem15_8dynamicsubmit.html",
    "href": "problem15_8dynamicsubmit.html",
    "title": "Problem 15.8 - Buckling & yield – Euler’s formula",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"617\"\nri=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\na=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nc=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A simple truss is constructed from steel pipe with inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} in. and outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} in. If lengths a = {a()} ft, b = {b()} ft, and c = {c()} ft, determine the largest load F that may be applied before either member AB or BC buckles? Assume all joints are pin connected and E = 29,000 ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        ri.set(random.randrange(30,150,5)/100)\n        ro.set(ri()+random.randrange(10,30,5)/100)\n        a.set(random.randrange(10,30,1)/10)\n        b.set(a()*2.5)\n        c.set(a()*2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = math.pi*ro()**4/4-math.pi*ri()**4/4\n        LAB = (c()**2+a()**2)**0.5\n        LBC = (c()**2+b()**2)**0.5\n        alpha = math.atan(a()/c())\n        theta = math.atan(b()/c())\n        Pcr1 = math.pi**2*29000000*I/((LBC*12)**2)\n        Pcr2 = math.pi**2*29000000*I/((LAB*12)**2)\n        PBC = (math.sin(theta)*math.cos(alpha)/math.sin(alpha)+math.cos(theta))*Pcr1\n        PAB = (math.sin(theta)*math.cos(alpha)/math.sin(alpha)+math.cos(theta))*math.sin(alpha)/math.sin(theta)*Pcr2\n        instr = min(PBC,PAB)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.8 - Buckling & yield – Euler's formula"
    ]
  },
  {
    "objectID": "problem15_9dynamicsubmit.html",
    "href": "problem15_9dynamicsubmit.html",
    "title": "Problem 15.9 - Buckling & yield – Euler’s formula",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"620\"\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A wooden truss is loaded as shown. The cross-section has dimensions b = {b()} in. and h = {h()} in. If lengths L&lt;sub&gt;1&lt;/sub&gt; = {L1()} ft and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} ft, determine the maximum load F that may be applied to avoid buckling in member BC. Assume E = 1,750 ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b.set(random.randrange(10,30,1)/10)\n        h.set(round(b()*3,2))\n        L1.set(random.randrange(30,100,1)/10)\n        L2.set(L1()*random.randrange(13,17,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = b()*h()**3/12\n        L=(L1()**2+L2()**2)**0.5\n        theta = math.atan(L2()/L1())\n        instr = math.pi**2*1750*I/(L*12)**2*math.sin(theta)\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.9 - Buckling & yield – Euler's formula"
    ]
  },
  {
    "objectID": "problem15_11dynamicsubmit.html",
    "href": "problem15_11dynamicsubmit.html",
    "title": "Problem 15.11 - Effect of Supports",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"612\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A column with a square cross-section is used to support a force F = {F()} kips. The column is fixed at its base and free at the other end. If length L = {L()} ft and elastic modulus E = 29,000 ksi, determine the minimum dimension, h, so that the column will not buckle.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(50, 150, 1)/10)\n        L.set(random.randrange(100, 200, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (48*F()*1000*L()**2*144/(math.pi**2*29*10**6))**0.25\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.11 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem15_12dynamicsubmit.html",
    "href": "problem15_12dynamicsubmit.html",
    "title": "Problem 15.12 - Effect of Supports",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"621\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A W16 x 40 beam is used as a column with a length L = {L()} ft. It is fixed at both ends and subjected to load F = {F()} kips. If the elastic modulus E = 29,000 ksi, determine the factor of safety with respect to buckling.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(200, 500, 10))\n        L.set(random.randrange(100, 200, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Pcr = math.pi**2*29*10**3*28.9/(0.5*L()*12)**2\n        instr= Pcr/F()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.12 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem15_13dynamicsubmit.html",
    "href": "problem15_13dynamicsubmit.html",
    "title": "Problem 15.13 - Effect of Supports",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"623\"\nL=reactive.Value(\"__\")\nFS=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kips\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A W8 x 15 beam (I&lt;sub&gt;x&lt;/sub&gt; = 48.0 in.&lt;sup&gt;4&lt;/sup&gt;, I&lt;sub&gt;y&lt;/sub&gt; = 3.41 in.&lt;sup&gt;4&lt;/sup&gt;) is used as a column with one end fixed and the other end pinned. If the length of the column L = {L()} ft, determine the largest load it can carry with a factor of safety of {FS()}. The elastic modulus E = {E()} ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(150, 300, 1)/10)\n        FS.set(random.randrange(15, 50, 1)/10)\n        E.set(random.randrange(15000, 30000, 100))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Pcr = math.pi**2*E()*3.41/(0.7*L()*12)**2\n        instr= Pcr/FS()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.13 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem15_14dynamicsubmit.html",
    "href": "problem15_14dynamicsubmit.html",
    "title": "Problem 15.14 - Effect of Supports",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"624\"\nF = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\nFS = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\nui.row(\n        ui.column(12, ui.div(\n            ui.row(\n                ui.column(1, ui.tags.label(\"W\", class_=\"form-label\", style=\"line-height: 38px;\")),\n                ui.column(3, ui.input_text(\"answer1\", \"\", placeholder=\"Enter your answer 1\")),\n                ui.column(1, ui.tags.label(\"x\", class_=\"form-label\", style=\"line-height: 38px; margin-left: 10px;\")),\n                ui.column(3, ui.input_text(\"answer2\", \"\", placeholder=\"Enter your answer 2\")),\n            ),\n            class_=\"d-flex justify-content-center align-items-center\"\n        ))\n    ),  \n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A wide-flange column that is fixed at both ends is required to carry a load F = {F()} kips. If length L = {L()} ft and the elastic modulus E = 29,000 ksi, identify the lightest structural member in Appendix A that can be used. Use a factor of safety of {FS()} against buckling.\\n\\n Enter two numbers below such that the answer is in the form W 24 x 16.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(300, 800, 10))\n        L.set(random.randrange(150, 300, 1) / 10)\n        FS.set(random.randrange(15, 40, 1) / 10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        I = F()*L()**2*144*FS()/(4*math.pi**2*29000)\n\n        # Create a dataframe\n        df = pd.DataFrame()\n\n        # Define Beam Name Columns\n        df[\"I-Beam First Num\"] = [40,40,40,36,36,36,30,30,30,24,24,24,21,21,21,18,18,18,16,16,16,14,14,14,12,12,12]\n\n        #Define Weight Column\n        df[\"Weight\"] = [431,297,264,487,247,210,326,173,99,279,131,84,201,122,68,130,76,40,67,40,31,90,53,34,106,53,26]\n        \n        # Define Iy Column\n        df[\"Iy (in\\u2074)\"] = [1690,1090,493,2250,1010,411,1240,598,128,823,340,94.4,542,305,64.7,278,152,19.1,119,28.9,12.4,362,57.7,23.3,301,95.8,17.3]\n\n        # Create Solution Dataframe\n        instr=pd.DataFrame()\n        instr[\"First Num\"] =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        instr[\"Second Num\"] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        \n        # Search for Possible Solutions\n        i = 0\n        while i &lt; 27:\n            if df.iloc[i, 2] &gt;= I:\n                instr.iloc[i, 0] = df.iloc[i, 0]\n                instr.iloc[i, 1] = df.iloc[i, 1]\n            i += 1\n        instr = instr.loc[(instr != 0).any(axis=1)]\n\n        #Find Minimum Weight\n        wmin = min(instr.iloc[:,1])\n        mask = instr['Second Num'] == wmin\n        instr = pd.DataFrame(instr[mask])\n\n        correct1 = float(input.answer1()) == instr.iloc[0,0]\n        correct2 = float(input.answer2()) == instr.iloc[0,1]\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct' if correct2 else 'incorrect'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.14 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem15_15dynamicsubmit.html",
    "href": "problem15_15dynamicsubmit.html",
    "title": "Problem 15.15 - Effect of Supports",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"625\"\nL=reactive.Value(\"__\")\nFS=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of lb\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"To draw attention, a junkyard owner mounts a car on top of a column of length L = {L()} ft made from a W8 x 15 beam (I&lt;sub&gt;x&lt;/sub&gt; = 48.0 in.&lt;sup&gt;4&lt;/sup&gt;, I&lt;sub&gt;y&lt;/sub&gt; = 3.41 in.&lt;sup&gt;4&lt;/sup&gt;). If the elastic modulus E = 29,000 ksi, what is the heaviest car body that can be used to avoid buckling? Use a factor of safety of {FS()}.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(150, 250, 1)/10)\n        FS.set(random.randrange(15, 30, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Pcr = math.pi**2*29*10**6*3.41/(4*L()**2*144)\n        instr= Pcr/FS()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.15 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem15_16dynamicsubmit.html",
    "href": "problem15_16dynamicsubmit.html",
    "title": "Problem 15.16 - Effect of supports",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"622\"\nL=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of cm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A wood post of length L = {L()} m has one free end and one fixed end. The post supports a load F = {F()} kN. Determine the minimum dimension, a, necessary for the post to avoid buckling. Assume E = {E()} GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(15,50,1)/10)\n        F.set(random.randrange(100,200,1))\n        E.set(random.randrange(180,250,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = F()*1000*4*L()**2/(math.pi**2*E()*10**9)\n        instr = (I*12)**0.25*100\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.16 - Effect of supports"
    ]
  },
  {
    "objectID": "problem15_17dynamicsubmit.html",
    "href": "problem15_17dynamicsubmit.html",
    "title": "Problem 15.17 - Effect of supports",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"626\"\nL=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A C100 x 11 channel is used as a column with both ends fixed. If length L = {L()} m, determine the maximum load F that may be applied. Assume E = {E()} GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(150,250,1)/10)\n        E.set(random.randrange(190,210,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr = 4*math.pi**2*E()*10**6*0.174*10**-6/L()**2\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.17 - Effect of supports"
    ]
  },
  {
    "objectID": "problem15_19dynamicsubmit.html",
    "href": "problem15_19dynamicsubmit.html",
    "title": "Problem 15.19 - Effect of supports",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"629\"\nL=reactive.Value(\"__\")\na=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A wood column is fixed at its ends and pin-connected at its midheight around the y-axis. If length L = {L()} m and dimension a = {a()} mm, determine the maximum load F the column can support so that it does not buckle. Assume E = {E()} GPA.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10,40,1)/10)\n        a.set(random.randrange(75,200,1))\n        E.set(random.randrange(100,150,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = (a()/1000)**4/12\n        Pcrx = 4*math.pi**2*E()*10**6*I/(2*L())**2\n        Pcry = 2.046*math.pi**2*E()*10**6*I/(L()**2)\n        instr = min(Pcrx,Pcry)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.19 - Effect of supports"
    ]
  },
  {
    "objectID": "problem15_20dynamicsubmit.html",
    "href": "problem15_20dynamicsubmit.html",
    "title": "Problem 15.20 - Effect of supports",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"630\"\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A steel W10 x 30 beam is used as a column. It is fixed at its base and braced at the top such that the support around the weak axis acts as a pin but the column is free around the strong axis. If length L = {L()} ft, determine the load F that may be applied so that the column does not buckle. Assume E = 29,000 ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(200,300,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Pcrx = math.pi**2*29000*170/(4*(L()*12)**2)\n        Pcry = math.pi**2*29000*16.7/((L()*12)**2)\n        instr = min(Pcrx,Pcry)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.20 - Effect of supports"
    ]
  },
  {
    "objectID": "problem15_21dynamicsubmit.html",
    "href": "problem15_21dynamicsubmit.html",
    "title": "Problem 15.21 - Effect of supports",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"631\"\nr=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A semi-circular column of radius r = {r()} mm and length L = {L()} m is fixed at one end and free at the other. Determine the critical load, P&lt;sub&gt;cr&lt;/sub&gt; for the column. Assume E = {E()} GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        r.set(random.randrange(100,300,1))\n        L.set(random.randrange(80,150,1)/10)\n        E.set(random.randrange(100,150,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Iy = math.pi*(r()/1000)**4/8\n        Ix = (r()/1000)**4*(math.pi/8-8/(9*math.pi))\n        instr = math.pi**2*E()*1000000*min(Iy,Ix)/(4*L()**2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.21 - Effect of supports"
    ]
  },
  {
    "objectID": "problem15_22dynamicsubmit.html",
    "href": "problem15_22dynamicsubmit.html",
    "title": "Problem 15.22 - Effect of supports",
    "section": "",
    "text": "[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"632\"\na=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A column with an equilateral triangular cross-section of side length a = {a()} in. and length L = {L()} ft is fixed at its base and pinned at its top. Determine the critical load, P&lt;sub&gt;cr&lt;/sub&gt;, for the column. Assume E = {E()} x 10&lt;sup&gt;3&lt;/sup&gt; ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        a.set(random.randrange(50,150,1)/10)\n        L.set(random.randrange(25,50,1))\n        E.set(random.randrange(30,50,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = a()*(a()*math.cos(math.pi/6))**3/36\n        instr = 2.046*math.pi**2*E()*10**3*73.9/((L()*12)**2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.22 - Effect of supports"
    ]
  },
  {
    "objectID": "problem2_1staticsubmit.html",
    "href": "problem2_1staticsubmit.html",
    "title": "Problem 2.1 - Average Normal Stress",
    "section": "",
    "text": "Problem Statement\nA series of solid circular bars are loaded with three loads as shown, F1 = 60 N, F2 = 20 N, and F3 = 40 N. What is the largest absolute normal stress in any bar?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.1 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_2staticsubmit.html",
    "href": "problem2_2staticsubmit.html",
    "title": "Problem 2.2 - Average Normal Stress",
    "section": "",
    "text": "Problem Statement\nTwo cylinders are stacked on top of one another and two forces are applied at the top surface and at the joint between the cylinders as shown. If L1 = 3 in., L2 = 4 in., FA = 500 lb, and FB = 200 lb, find the average normal stress in cylinder B.\n [Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.2 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_3staticsubmit.html",
    "href": "problem2_3staticsubmit.html",
    "title": "Problem 2.3 - Average Normal Stress",
    "section": "",
    "text": "Problem Statement\nA plastic cylindrical peg is constrained by a metal cap as shown. An axial load of F = 40 lb is applied to the peg. If d1 = 0.5 in and d2 = 0.9 in, determine the normal stress in the peg. Assume the axial load is evenly distributed across the peg and that the metal cap is fixed and does not move.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.3 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_3staticsubmit.html#problem-statement",
    "href": "problem2_3staticsubmit.html#problem-statement",
    "title": "Problem 2.3 - Average Normal Stress",
    "section": "",
    "text": "Figure 1: A plastic cylindrical peg is constrained by a metal cap",
    "crumbs": [
      "Chapter 2",
      "Problem 2.3 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_4staticsubmit.html",
    "href": "problem2_4staticsubmit.html",
    "title": "Problem 2.4 - Average Normal Stress",
    "section": "",
    "text": "Problem Statement\nA crate weighing 45 kN is suspended by a set of cables. The diameter of each cable is 30 mm. What is the maximum stress in any cable, excluding the cable attached to the crate.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.4 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_21staticsubmit.html",
    "href": "problem2_21staticsubmit.html",
    "title": "Problem 2.21 - Average Shear Stress",
    "section": "",
    "text": "Problem Statement\nA double lap joint is glued together using glue with a shear stress failure strength of 8000 psi. If dimensions L = 6 in. and t = 8 in., what is the maximum load P that the joint can withstand? Assume the load is evenly distributed across the joint on both sides.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.21 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_22staticsubmit.html",
    "href": "problem2_22staticsubmit.html",
    "title": "Problem 2.22 - Average Shear Stress",
    "section": "",
    "text": "Problem Statement\nA bracket is attached to a wall with two circular rivets of diameter d = 20 mm. A load F = 50 kN is applied in the center of the bracket. Assuming the load is split evenly between the two rivits, determine the shear stress in each rivet.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.22 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_23staticsubmit.html",
    "href": "problem2_23staticsubmit.html",
    "title": "Problem 2.23 - Average Shear Stress",
    "section": "",
    "text": "Problem Statement\nA square bar of length L1 = 10 in. and L2 = 14 in. is pinned at one end and rests on a circular rod of diameter d = 5/8 in. A force F = 60 lb is applied at the free end. What is the average shear stress in the circular rod?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.23 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_38staticsubmit.html",
    "href": "problem2_38staticsubmit.html",
    "title": "Problem 2.38 - Bearing Stress",
    "section": "",
    "text": "Problem Statement\nA crate of weight W = 8000 lb hangs from a solid circular metal rod of diameter d1 = 1 in.. The cable is wrapped around a support collar of diameter d2 = 3 in. and thickness t = 2 in. to evenly distribute the cable load. What is the bearing stress on the support collar due to the rod?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.38 - Bearing Stress"
    ]
  },
  {
    "objectID": "problem2_39staticsubmit.html",
    "href": "problem2_39staticsubmit.html",
    "title": "Problem 2.39 - Bearing Stress",
    "section": "",
    "text": "Problem Statement\nA link mechanism is connected with pins of diameter d = 1/2 in. A force F = 500 lb is applied to the mechanism as shown. The mechanism has width w = 1 in. and thickness t = 1/4 in. What is the bearing stress in member BC at joint B due to the pin at B?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.39 - Bearing Stress"
    ]
  },
  {
    "objectID": "problem2_39staticsubmit.html#problem-statement",
    "href": "problem2_39staticsubmit.html#problem-statement",
    "title": "Problem 2.39 - Bearing Stress",
    "section": "",
    "text": "Figure 1: A link mechanism is connected with pins.",
    "crumbs": [
      "Chapter 2",
      "Problem 2.39 - Bearing Stress"
    ]
  },
  {
    "objectID": "problem2_41staticsubmit.html",
    "href": "problem2_41staticsubmit.html",
    "title": "Problem 2.41 - Bearing Stress",
    "section": "",
    "text": "Problem Statement\nA steel connector plate is hung from a brass rod of diameter d = 1 in. The plate has dimensions t = 0.5 in. and w = 2 in. Considering only bearing stress, find the minimum load that will cause the connector or rod to fail. Assume the failure bearing stress for brass is 70 ksi and for steel is 75 ksi.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.41 - Bearing Stress"
    ]
  },
  {
    "objectID": "problem2_47staticsubmit.html",
    "href": "problem2_47staticsubmit.html",
    "title": "Problem 2.47 - Stress on an Inclined Plane",
    "section": "",
    "text": "Problem Statement\nTwo slanted brackets are glued together as shown. If F = 500 lb, L = 4 in., and Θ = 20 °, determine the shear stress parallel to the inclined plane. Assume loads are inline and there is no rotation.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.47 - Stress on an Inclined Plane"
    ]
  },
  {
    "objectID": "problem2_48staticsubmit.html",
    "href": "problem2_48staticsubmit.html",
    "title": "Problem 2.48 - Stress on an Inclined Plane",
    "section": "",
    "text": "Problem Statement\nA 2 inch thick board is cut and then glued back together along a line that is Θ = 15° off the vertical as shown. If height h = 10 in. and F = 3500 lb, determine the normal stress along the cut line.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.48 - Stress on an Inclined Plane"
    ]
  },
  {
    "objectID": "problem3_2staticsubmit.html",
    "href": "problem3_2staticsubmit.html",
    "title": "Problem 3.2 - Normal Strain",
    "section": "",
    "text": "Problem Statement\nDuring a tension test of a rectangular prism, the original gage length L = 200 mm is increased to L’ = 201.43 mm. determine the normal strain, ε, in the prism.\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 3",
      "Problem 3.2 - Normal Strain"
    ]
  },
  {
    "objectID": "problem3_7staticsubmit.html",
    "href": "problem3_7staticsubmit.html",
    "title": "Problem 3.7 - Shear Strain",
    "section": "",
    "text": "Problem Statement\nA square plate is deformed due to shear with the new shape shown. If length L = 300 mm and x = 42 mm, determine the shear strain at corner A\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 3",
      "Problem 3.7 - Shear Strain"
    ]
  },
  {
    "objectID": "problem4_5staticsubmit.html",
    "href": "problem4_5staticsubmit.html",
    "title": "Problem 4.5 - Hooke’s Law",
    "section": "",
    "text": "Problem Statement\nA single force F = 3 kips pulls on three cylindrical rods, each of length L = 6 in., Diameter d1 = 2 in., and d2 = 1 in. What is the strain in the steel cylinder? Assume Esteel = 29,000 ksi and Ealuminum = 10,000 ksi.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.5 - Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_5staticsubmit.html#problem-statement",
    "href": "problem4_5staticsubmit.html#problem-statement",
    "title": "Problem 4.5 - Hooke’s Law",
    "section": "",
    "text": "Figure 1: A single force pulls on three cylindrical rods that are fixed to a wall.",
    "crumbs": [
      "Chapter 4",
      "Problem 4.5 - Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_6staticsubmit.html",
    "href": "problem4_6staticsubmit.html",
    "title": "Problem 4.6 - Hooke’s Law",
    "section": "",
    "text": "Problem Statement\nA polymer test specimen is subjected to an axial load of F = 18 kips. The central portion of the specimen has an initial length L = 8 in., w = 3 in., and t = 1/4 in. If the length increases by dL = 0.052 in., determine the elastic modulus of the material.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.6 - Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_6staticsubmit.html#problem-statement",
    "href": "problem4_6staticsubmit.html#problem-statement",
    "title": "Problem 4.6 - Hooke’s Law",
    "section": "",
    "text": "Figure 1: A polymer test specimen is pulled from the top and bottom.",
    "crumbs": [
      "Chapter 4",
      "Problem 4.6 - Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_10staticsubmit.html",
    "href": "problem4_10staticsubmit.html",
    "title": "Problem 4.10 - Poisson’s Ratio",
    "section": "",
    "text": "Problem Statement\nA circular rod of an unknown metallic alloy is placed in tension with a P = 5 kip axial load. The length of the rod is L = 10 in. and the diameter is d = 1 in. After applying the load, the rod length increases by 0.0035 in and the diameter decreases by 0.00014 in. What is the Poisson’s ratio of the alloy?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.10 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_10staticsubmit.html#problem-statement",
    "href": "problem4_10staticsubmit.html#problem-statement",
    "title": "Problem 4.10 - Poisson’s Ratio",
    "section": "",
    "text": "Figure 1: A circular road is placed in tension with an axial load.",
    "crumbs": [
      "Chapter 4",
      "Problem 4.10 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_11staticsubmit.html",
    "href": "problem4_11staticsubmit.html",
    "title": "Problem 4.11 - Poisson’s Ratio",
    "section": "",
    "text": "Problem Statement\nAn aluminum circular rod of radius r1 = 2 in is inserted into space that is slightly wider than the rod, where r2 = 2.003 in. What load P is needed so that the rod expands and fills the space in the radial direction? Assume E = 15,000 ksi and v = 0.33.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.11 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_11staticsubmit.html#problem-statement",
    "href": "problem4_11staticsubmit.html#problem-statement",
    "title": "Problem 4.11 - Poisson’s Ratio",
    "section": "",
    "text": "Figure 1: A circular rod is inserted into a space slightly wider than the rod.",
    "crumbs": [
      "Chapter 4",
      "Problem 4.11 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_12staticsubmit.html",
    "href": "problem4_12staticsubmit.html",
    "title": "Problem 4.12 - Poisson’s Ratio",
    "section": "",
    "text": "Problem Statement\nA rectangular bar is pulled in tension by a load P in the x-direction. The bar deflects by d1 = 0.0350 in and d2 = 0.0012 in, in the x- and y-direction, respectively. The length in the x-direction is 5 in, and the length in the y direction is 1 in. What is the Poisson’s ratio of the material? The z-direction deflection is not known.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.12 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_12staticsubmit.html#problem-statement",
    "href": "problem4_12staticsubmit.html#problem-statement",
    "title": "Problem 4.12 - Poisson’s Ratio",
    "section": "",
    "text": "Figure 1: A rectangular rod is pulled in tension in the x-direction.",
    "crumbs": [
      "Chapter 4",
      "Problem 4.12 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_18staticsubmit.html",
    "href": "problem4_18staticsubmit.html",
    "title": "Problem 4.18 - Thermal Strain",
    "section": "",
    "text": "Problem Statement\nA copper pipe (α = 17x10-6 /°C) of length L = 6.2 m is cooled from 31°C to to 4°C. Determine the longitudinal strain in the cooled pipe.\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.18 - Thermal Strain"
    ]
  },
  {
    "objectID": "problem4_19staticsubmit.html",
    "href": "problem4_19staticsubmit.html",
    "title": "Problem 4.19 - Thermal Strain",
    "section": "",
    "text": "Problem Statement\nUpon plant startup, a steel steam pipe (α = 6.5 x 10-6 /°F) of length L = 120 ft is raised in temperature from an ambient temperature of 65°F to 413°F. Determine the change in length of the pipe.\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.19 - Thermal Strain"
    ]
  },
  {
    "objectID": "problem4_23staticsubmit.html",
    "href": "problem4_23staticsubmit.html",
    "title": "Problem 4.23 - Multiaxial Hooke’s Law",
    "section": "",
    "text": "Problem Statement\nA square steel plate of side length L = 6 in. and thickness t = 1/2 in. is uniformly pulled by two forces Fx = 15 kips and Fy = 25 kips as shown. If E = 29,000 ksi and Poisson’s ratio v = 0.29, determine the change in thickness of the plate.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.23 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_23staticsubmit.html#problem-statement",
    "href": "problem4_23staticsubmit.html#problem-statement",
    "title": "Problem 4.23 - Multiaxial Hooke’s Law",
    "section": "",
    "text": "Figure 1: A block is pulled in by two forces.",
    "crumbs": [
      "Chapter 4",
      "Problem 4.23 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_24staticsubmit.html",
    "href": "problem4_24staticsubmit.html",
    "title": "Problem 4.24 - Multiaxial Hooke’s Law",
    "section": "",
    "text": "Problem Statement\nA strain gauge is placed on a polymer test sample with an elastic modulus E = 1 x 107 psi and a Poisson’s ratio of v = 0.3. When a P1 = 5 kip vertical load is applied to the test sample, the strain gauge reads a strain of SG = 11 x 10-6 in the x-direction. What is the relative error of the strain gauge compared to the theoretical strain of the test sample? Note: relative error is defined to be the difference between the measured value and the theoretical value divided by the theoretical value.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.24 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_24staticsubmit.html#problem-statement",
    "href": "problem4_24staticsubmit.html#problem-statement",
    "title": "Problem 4.24 - Multiaxial Hooke’s Law",
    "section": "",
    "text": "Figure 1: A strain gauge is placed on a test sample and a vertical load is applied to the test sample.",
    "crumbs": [
      "Chapter 4",
      "Problem 4.24 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_25staticsubmit.html",
    "href": "problem4_25staticsubmit.html",
    "title": "Problem 4.25 - Multiaxial Hooke’s Law",
    "section": "",
    "text": "Problem Statement\nA block is pulled in all three directions (Px = 3 kN, Py = 3 kN, Pz = 6 kN). What is the percent change in volume after all three loads are applied? Assume E = 1,500 MPa and v = 0.35.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.25 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_25staticsubmit.html#problem-statement",
    "href": "problem4_25staticsubmit.html#problem-statement",
    "title": "Problem 4.25 - Multiaxial Hooke’s Law",
    "section": "",
    "text": "Figure 1: A block is pulled in all three directions.",
    "crumbs": [
      "Chapter 4",
      "Problem 4.25 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_35staticsubmit.html",
    "href": "problem4_35staticsubmit.html",
    "title": "Problem 4.35 - Allowable Stress/Safety Factor",
    "section": "",
    "text": "Problem Statement\nA small truss is constructed with solid square wood members and subjected to a load of F = 30 kN. Determine the minimum dimension, a, of the member so that the truss will have a factor of safety of 2. All members have the same cross-section. The wood has a failure stress of σfail = 50 MPa.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.35 - Allowable Stress/Safety Factor"
    ]
  },
  {
    "objectID": "problem5_6staticsubmit.html",
    "href": "problem5_6staticsubmit.html",
    "title": "Problem 5.6 - Stress Concentrations",
    "section": "",
    "text": "Problem Statement\nA flat bar of thickness t = 9 mm contains a hole as shown. The bar is subjected to a tensile load P = 4.7 kN. Determine the maximum tensile stress in the bar.\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.6 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_8staticsubmit.html",
    "href": "problem5_8staticsubmit.html",
    "title": "Problem 5.8 - Stress Concentrations",
    "section": "",
    "text": "Problem Statement\nA flat bar of thickness t = 0.25 in. narrows with fillets as shown. If a load P = 3200 lb is applied, determine the maximum stress in the bar.\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.8 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_8staticsubmit.html#problem-statement",
    "href": "problem5_8staticsubmit.html#problem-statement",
    "title": "Problem 5.8 - Stress Concentrations",
    "section": "",
    "text": "Figure 1: A bar narrows in width.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.8 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_10staticsubmit.html",
    "href": "problem5_10staticsubmit.html",
    "title": "Problem 5.10 - Stress Concentrations",
    "section": "",
    "text": "Problem Statement\nThe linkage of thickness t = 0.5 in. shown is subjected to load P = 25 kips. Determine the maximum stress in the linkage.\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.10 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_10staticsubmit.html#problem-statement",
    "href": "problem5_10staticsubmit.html#problem-statement",
    "title": "Problem 5.10 - Stress Concentrations",
    "section": "",
    "text": "Figure 1: A linkage is subjected to a loading as shown.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.10 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_11staticsubmit.html",
    "href": "problem5_11staticsubmit.html",
    "title": "Problem 5.11 - Axial Deformation",
    "section": "",
    "text": "Problem Statement\nA series of solid, steel, circular bars are loaded with forces as shown, where F1 = 3 kN, F2 = 2 kN, F3 = 3 kN, and F4 = 4 kN. What is the total change in length of the system? Assume E = 210 GPa for steel.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.11 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_11staticsubmit.html#problem-statement",
    "href": "problem5_11staticsubmit.html#problem-statement",
    "title": "Problem 5.11 - Axial Deformation",
    "section": "",
    "text": "Figure 1: A series of solid, steel, circular bars are loaded with forces.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.11 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_12staticsubmit.html",
    "href": "problem5_12staticsubmit.html",
    "title": "Problem 5.12 - Axial Deformation",
    "section": "",
    "text": "Problem Statement\nTwo forces, F1 = 15 kN and F2 = 10 kN, are applied to the system of cylinders as shown. If L1 = 5 m, L2 = 3 m, and L3 = 4 m, what is the total change in length of the system? Assume Esteel = 210 GPa and Ealuminum = 70 GPa.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.12 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_12staticsubmit.html#problem-statement",
    "href": "problem5_12staticsubmit.html#problem-statement",
    "title": "Problem 5.12 - Axial Deformation",
    "section": "",
    "text": "Figure 1: Two forces are applied to the system of cylinders.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.12 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_13staticsubmit.html",
    "href": "problem5_13staticsubmit.html",
    "title": "Problem 5.13 - Axial Deformation",
    "section": "",
    "text": "Problem Statement\nTwo forces, F1 = 1 kN and F2 = 2 kN, are applied to the system of cylinders as shown. If L1 = 10 mm and L2 = 14 mm, what is the total change in length of the system. Assume Ebrass = 100 GPa and Ealuminum = 70 GPa.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.13 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_13staticsubmit.html#problem-statement",
    "href": "problem5_13staticsubmit.html#problem-statement",
    "title": "Problem 5.13 - Axial Deformation",
    "section": "",
    "text": "Figure 1: Two forces are applied to the system of cylinders.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.13 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_14staticsubmit.html",
    "href": "problem5_14staticsubmit.html",
    "title": "Problem 5.14 - Axial Deformation",
    "section": "",
    "text": "Problem Statement\nA series of solid circular steel bars are loaded as shown, where F1 = 60 N, F2 = 20 N, and F3 = 40 N. If lengths L1 = L2 = 30 cm and L3 = 40 cm, determine the total change in length of the system. Assume Esteel = 210 GPa.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.14 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_14staticsubmit.html#problem-statement",
    "href": "problem5_14staticsubmit.html#problem-statement",
    "title": "Problem 5.14 - Axial Deformation",
    "section": "",
    "text": "Figure 1: A series of solid circular steel bars are loaded with three loads.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.14 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_15staticsubmit.html",
    "href": "problem5_15staticsubmit.html",
    "title": "Problem 5.15 - Axial Deformation",
    "section": "",
    "text": "Problem Statement\nA crate weight W = 120 lb is attached to a cable constructed from steel of length L1 = 12 in. and Area A1 = 0.02 in.2 and aluminum of length L2 = 24 in. and area A2 = 0.03 in.2. What is the total deflection of the crate after it is attached to the wire? Assume Esteel = 29,000 ksi and Ealuminum = 10,000 ksi. Neglect the weight of the wires.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.15 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_27staticsubmit.html",
    "href": "problem5_27staticsubmit.html",
    "title": "Problem 5.27 - Deformation in Systems of Bars",
    "section": "",
    "text": "Problem Statement\nA bar is attached to two wires, one steel and one aluminum. If the lengths of the wires L1 = 8 in. and L2 = 10 in., find the distance x that load F = 5 kips must be placed at so that the bar remains horizontal after the load is applied. Both wires have the same cross-section area A = 0.02 in.2. Assume Esteel = 29,000 ksi, Ealuminum = 10,000 ksi and that the bar is of length L = 12 in.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.27 - Deformation in Systems of Bars"
    ]
  },
  {
    "objectID": "problem5_27staticsubmit.html#problem-statement",
    "href": "problem5_27staticsubmit.html#problem-statement",
    "title": "Problem 5.27 - Deformation in Systems of Bars",
    "section": "",
    "text": "Figure 1: A bar is attached to two wires, one steel and one aluminum.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.27 - Deformation in Systems of Bars"
    ]
  },
  {
    "objectID": "problem5_34staticsubmit.html",
    "href": "problem5_34staticsubmit.html",
    "title": "Problem 5.34 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA copper circular rod of radius r = 4 cm is inserted into an aluminum tube with inner radius ri = 5 cm and outer radius ro = 6 cm as shown. Load P is applied to the rigid top plate. If length L = 15 cm, what load P will cause the plate to deflect dL = 0.23 mm downward? Assume Ecopper = 110 GPa and Ealuminum = 70 GPa.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.34 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_34staticsubmit.html#problem-statement",
    "href": "problem5_34staticsubmit.html#problem-statement",
    "title": "Problem 5.34 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: A copper circular rod is inserted into an aluminum tube as shown.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.34 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_35staticsubmit.html",
    "href": "problem5_35staticsubmit.html",
    "title": "Problem 5.35 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nTwo blocks with square cross-sections are stacked as shown, with the top block inserted into the bottom block and subjected to load F = 3.4 kips. The top block is aluminum (E = 10,000 ksi) with side length w1 = 2 in. and the bottom block is steel (E = 29,000 ksi) with side length w2 = 3 in. If length L = 5 in., what is the total deflection of the top surface? Ignore the weight of the blocks.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.35 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_35staticsubmit.html#problem-statement",
    "href": "problem5_35staticsubmit.html#problem-statement",
    "title": "Problem 5.35 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: Two blocks with square cross sections are stacked and loaded at the top.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.35 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_36staticsubmit.html",
    "href": "problem5_36staticsubmit.html",
    "title": "Problem 5.36 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nTwo square members are attached to two fixed walls as shown. Force F is applied at point B and point B is displaced d = 0.002 in. to the right. If L = 5 in., Ewood = 1,750 ksi, and Eplastic = 400 ksi, determine the applied force F.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.36 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_36staticsubmit.html#problem-statement",
    "href": "problem5_36staticsubmit.html#problem-statement",
    "title": "Problem 5.36 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: Two square members are placed between two fixed walls.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.36 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_37staticsubmit.html",
    "href": "problem5_37staticsubmit.html",
    "title": "Problem 5.37 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nTwo aluminum circular rods are attached to two fixed walls as shown. Assume E = 70 MPa for both cylinders, F = 30 kN, d1 = 20 mm, d2 = 30 mm, L1 = 300 mm, and L2 = 200 mm. Determine the normal stress in member 1.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.37 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_37staticsubmit.html#problem-statement",
    "href": "problem5_37staticsubmit.html#problem-statement",
    "title": "Problem 5.37 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: Two aluminum circular rods are placed between two fixed walls.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.37 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_38staticsubmit.html",
    "href": "problem5_38staticsubmit.html",
    "title": "Problem 5.38 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA distributed load w = 100 N/cm2 is applied to a short column made from wood and concrete. Assume Econcrete = 25 GPa, Ewood = 12 GPa, b = 3 cm, h1 = 3 cm, and h2 = 6 cm. What load is carried by the concrete center?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.38 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_38staticsubmit.html#problem-statement",
    "href": "problem5_38staticsubmit.html#problem-statement",
    "title": "Problem 5.38 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: A pressure load is applied to a short column made of wood and concrete.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.38 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_39staticsubmit.html",
    "href": "problem5_39staticsubmit.html",
    "title": "Problem 5.39 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA concrete post of length L = 0.3 m and diameter dc = 120 mm supports a load F = 150 kN. The concrete is reinforced with 6 steel rods of diameter ds = 10 mm. Assume Econcrete = 25 GPa and Esteel = 200 GPa. Determine the stress in the concrete.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.39 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_39staticsubmit.html#problem-statement",
    "href": "problem5_39staticsubmit.html#problem-statement",
    "title": "Problem 5.39 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: A concrete post with 6 steel rebar rods embedded in the concrete supports a load.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.39 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_50staticsubmit.html",
    "href": "problem5_50staticsubmit.html",
    "title": "Problem 5.50 - Thermal Deformation",
    "section": "",
    "text": "Problem Statement\nThe axial stress in a solid circular bar between two fixed walls is 30 ksi. Find the temperature change necessary to relieve the stress. Assume L = 30 in., E = 29,000 ksi, and α = 6.5 x 10-6 / °F.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.50 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_50staticsubmit.html#problem-statement",
    "href": "problem5_50staticsubmit.html#problem-statement",
    "title": "Problem 5.50 - Thermal Deformation",
    "section": "",
    "text": "Figure 1: A solid circular bar is between two fixed walls.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.50 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_51staticsubmit.html",
    "href": "problem5_51staticsubmit.html",
    "title": "Problem 5.51 - Thermal Deformation",
    "section": "",
    "text": "Problem Statement\nThe W = 1,000 kg weight is placed on a L = 1 m tall brass bar with a cross section of d = 2.5 cm. If the bar undergoes a temperature change of 50°C, what is the total deformation of the bar? Assume the Young’s Modulus and thermal coefficient of expansion is 100 GPa and 10 x 10-6 /°C, respectively. Also, assume no buckling.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.51 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_51staticsubmit.html#problem-statement",
    "href": "problem5_51staticsubmit.html#problem-statement",
    "title": "Problem 5.51 - Thermal Deformation",
    "section": "",
    "text": "Figure 1: A weight is placed on a tall brass bar.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.51 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_52staticsubmit.html",
    "href": "problem5_52staticsubmit.html",
    "title": "Problem 5.52 - Thermal Deformation",
    "section": "",
    "text": "Problem Statement\nTwo cylindrical rods are heated until they expand, just closing the gap of d = 0.01 in. The coefficient of thermal expansion, α, for material A and B is 6 x 10-6/°F and 10 x 10-6/°F, respectively. The radius of A rA = 0.5 in and the length is L1 = 10 in. The radius of B is rB = 0.8 in and the length is L2 = 6 in. What is the change in temperature?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.52 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_52staticsubmit.html#problem-statement",
    "href": "problem5_52staticsubmit.html#problem-statement",
    "title": "Problem 5.52 - Thermal Deformation",
    "section": "",
    "text": "Figure 1: Two cylindrical rods are connected and heated until they expand to close a gap.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.52 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_53staticsubmit.html",
    "href": "problem5_53staticsubmit.html",
    "title": "Problem 5.53 - Thermal Deformation",
    "section": "",
    "text": "Problem Statement\nThree cylindrical rods of lengths L1 = 0.12 m, L2 = 0.1 m, and L3 = 0.08 m are connected together. A force F = 15 kN is applied to the free end and all three rods are heated by 120 °C. The coefficient of thermal expansion, α, and elastic modulus, E, for each material are αA = 10 x 10-6 /°C, αB = 5 x 10-6 /°C, αC = 7 x 10-6 /°C, EA = 40 GPa, EB = 120 GPa, and EC = 80 GPa. What is the total deflection of the right rod tip?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.53 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_53staticsubmit.html#problem-statement",
    "href": "problem5_53staticsubmit.html#problem-statement",
    "title": "Problem 5.53 - Thermal Deformation",
    "section": "",
    "text": "Figure 1: Three cylindrical rods are rigidly connected togehter with a load applied to the free end.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.53 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_54staticsubmit.html",
    "href": "problem5_54staticsubmit.html",
    "title": "Problem 5.54 - Thermal Deformation",
    "section": "",
    "text": "Problem Statement\nA square brass bar is placed between two fixed walls and heated from 5 °C to 35 °C. If L = 450 mm, h = 15 mm, E = 100 GPa, and α = 20 x 10-6 /°C, determine the stress in the bar.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.54 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_54staticsubmit.html#problem-statement",
    "href": "problem5_54staticsubmit.html#problem-statement",
    "title": "Problem 5.54 - Thermal Deformation",
    "section": "",
    "text": "Figure 1: A long square brass bar is placed between two fixed walls.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.54 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_55staticsubmit.html",
    "href": "problem5_55staticsubmit.html",
    "title": "Problem 5.55 - Thermal Deformation",
    "section": "",
    "text": "Problem Statement\nBars AB and BC are pinned at joint B. Both bars are made from the same material with E = 200 GPa, v = 0.32, and a = 11.7 x 10-6 /°C. Dimensions L = 400 mm, t = 33 mm, h = 15 mm, and d = 10 mm. If both bars are heated by 20 °C, determine the shear stress generated in the pin at B.\n{fig-alt=” Two bars are pinned at joint B between two walls. Joint AB is on the left hand side and joint BC is on the right hand side. Both bars are length L and thickness t and height h. The diameter of the bolt holding them together is d. “}\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.55 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem6_1staticsubmit.html",
    "href": "problem6_1staticsubmit.html",
    "title": "Problem 6.1 - Torsional Stress",
    "section": "",
    "text": "Problem Statement\nWhat torque is required to create a maximum shear stress of τ = 50 MPa in a solid circular bar of diameter d = 60 mm?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.1 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_1staticsubmit.html#problem-statement",
    "href": "problem6_1staticsubmit.html#problem-statement",
    "title": "Problem 6.1 - Torsional Stress",
    "section": "",
    "text": "Figure 1: A bar is fixed to a wall at one end.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.1 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_2staticsubmit.html",
    "href": "problem6_2staticsubmit.html",
    "title": "Problem 6.2 - Torsional Stress",
    "section": "",
    "text": "Problem Statement\nA force F = 150 lb is applied to a hand crank that is stuck and will not turn. If L = 10 in. and y = 5 in., determine the maximum shear stress due to torsion in the crank rod between A and B. Assume the crank has diameter d = 0.5 in.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.2 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_2staticsubmit.html#problem-statement",
    "href": "problem6_2staticsubmit.html#problem-statement",
    "title": "Problem 6.2 - Torsional Stress",
    "section": "",
    "text": "Figure 1: A hand crank is attached to a wall.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.2 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_3staticsubmit.html",
    "href": "problem6_3staticsubmit.html",
    "title": "Problem 6.3 - Torsional Stress",
    "section": "",
    "text": "Problem Statement\nTwo torques are applied to a two part circular rod as shown. If T1 = 6 kip-in., T2 = 2 kip-in., d1 = 5 in., and d2 = 4 in., what is the magnitude of the maximum shear stress?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.3 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_4staticsubmit.html",
    "href": "problem6_4staticsubmit.html",
    "title": "Problem 6.4 - Torsional Stress",
    "section": "",
    "text": "Problem Statement\nThree belt pulleys are connected to a solid circular shaft of diameter d = 3 in. that rotates freely at joints A and E. The pulleys are subjected to forces F1 = 1 kips, F2 = 1 kips, and F3 = 1.5 kips. What is the maximum shear stress in the shaft between pulleys B and C?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.4 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_5staticsubmit.html",
    "href": "problem6_5staticsubmit.html",
    "title": "Problem 6.5 - Torsional Stress",
    "section": "",
    "text": "Problem Statement\nTwo torques ,TB = 0.6 kip-ft and TC = 0.3 kip-ft, are applied to the hollow pipe as shown. If L = 1 ft., ro = 2.5 in., and ri = 2 in., determine the maximum shear stress in the pipe.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.5 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_5staticsubmit.html#problem-statement",
    "href": "problem6_5staticsubmit.html#problem-statement",
    "title": "Problem 6.5 - Torsional Stress",
    "section": "",
    "text": "Figure 1: Two torques are applied to a hollow pipe attached to the wall.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.5 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_11staticsubmit.html",
    "href": "problem6_11staticsubmit.html",
    "title": "Problem 6.11 - Torsional Deformation",
    "section": "",
    "text": "Problem Statment\nA hollow copper rod (E = 110 GPa, v = 0.33) is subjected to torque T as shown. If length L = 0.8 m, outer diameter do = 80 mm, and inner diameter di = 40 mm, determine torque T if the rod twists 2°.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.11 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_11staticsubmit.html#problem-statment",
    "href": "problem6_11staticsubmit.html#problem-statment",
    "title": "Problem 6.11 - Torsional Deformation",
    "section": "",
    "text": "Figure 1: A hollow copper rod is fixed to a wall at one end and a torque is applied",
    "crumbs": [
      "Chapter 6",
      "Problem 6.11 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_12staticsubmit.html",
    "href": "problem6_12staticsubmit.html",
    "title": "Problem 6.12 - Torsional Deformation",
    "section": "",
    "text": "Problem Statement\nA bar with a shear modulus G = 11 x 106 psi is subjected to torques T1 = 1,500 lb-ft at its center and T2 at its free end. The inner diameter is 1 in and the outer diameter is 2 in and the total length of the bar is 10 in. If the rotation of the rod at its free end is Φ = 2° clockwise, what is the magnitude of torque T2?\n{fig-alt=” A bar is attached to a wall. The bar has an inner diameter of 1 in and outer diameter of 2 in. Torque, T[1] is applied halfway down the bar. The bar length is 10 in total.”}\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.12 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_13staticsubmit.html",
    "href": "problem6_13staticsubmit.html",
    "title": "Problem 6.13 - Torsional Deformation",
    "section": "",
    "text": "Problem Statement\nThree moments are applied to the system of cylinders as shown. Assume T1 = 3 kN-m, T2 = 6 kN-m, and T3 = -4 kN-m. If Gsteel = 77 GPa and Galuminum = 27 GPa, determine the total angle of twist at the free end.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.13 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_13staticsubmit.html#problem-statement",
    "href": "problem6_13staticsubmit.html#problem-statement",
    "title": "Problem 6.13 - Torsional Deformation",
    "section": "",
    "text": "Figure 1: A system of cylinders are attached to the wall at one end.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.13 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_14staticsubmit.html",
    "href": "problem6_14staticsubmit.html",
    "title": "Problem 6.14 - Torsional Deformation",
    "section": "",
    "text": "Problem Statement\nA circular rod of length L = 350 mm, outer radius ro = 30 mm, and unknown inner radius ri has a shear modulus G = 80 GPa. The rod is subjected to torque T = 1.25 kN-m at the free end. If the angle of twist must not exceed 2° and the shear stress must not exceed 100 MPa, what is the minimum required inner radius?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.14 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_14staticsubmit.html#problem-statement",
    "href": "problem6_14staticsubmit.html#problem-statement",
    "title": "Problem 6.14 - Torsional Deformation",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"270\"\nL=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\nT=reactive.Value(\"__\")\nG=reactive.Value(\"__\")\nstress=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A circular rod of length L = {L()} mm, outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} mm, and unknown inner radius r&lt;sub&gt;i&lt;/sub&gt; has a shear modulus G = {G()} GPa. The rod is subjected to torque T = {T()} kN-m at the free end. If the angle of twist must not exceed 2° and the shear stress must not exceed {stress()} MPa, what is the minimum required inner radius?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(250, 500, 10))\n        ro.set(random.randrange(30, 75, 1))\n        G.set(random.randrange(60, 100, 1))\n        T.set(random.randrange(10, 100, 1)/10)\n        stress.set(random.randrange(75, 150, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        r1= ((ro()/1000)**4-(2*T()*1000*ro()/1000/(math.pi*stress()*10**6)))**0.25*1000\n        r2 = ((ro()/1000)**4-(2*T()*1000*L()/1000/(math.pi*G()*10**9*2*math.pi/180)))**0.25*1000\n        if r1&gt;r2:\n            instr = r2\n        else:\n            instr = r1\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6",
      "Problem 6.14 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_15staticsubmit.html",
    "href": "problem6_15staticsubmit.html",
    "title": "Problem 6.15 - Torsional Deformation",
    "section": "",
    "text": "Problem Statement\nA hollow circular rod is attached to a wall and subjected to a torque T = 3 kN-m at the free end.The rod has inner diameter 8 cm and outer diameter 10 cm. Determine the angle of twist at x = 300 mm. Assume G = 100 GPa and L = 500 mm.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.15 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_15staticsubmit.html#problem-statement",
    "href": "problem6_15staticsubmit.html#problem-statement",
    "title": "Problem 6.15 - Torsional Deformation",
    "section": "",
    "text": "Figure 1: A hollow circualr rod is attached to a wall and subjected to a torque at the free end.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.15 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_22staticsubmit.html",
    "href": "problem6_22staticsubmit.html",
    "title": "Problem 6.22 - Power Transmission & Gear Assemblies",
    "section": "",
    "text": "Problem Statement\nThe steel shaft is being turned by an electric motor providing 20 kW of power at 180 rpm. Power is extracted at B with a torque of 600 N⸱m. Determine the remaining torque available for the gear at C.\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.22 - Power Transmission & Gear Assemblies"
    ]
  },
  {
    "objectID": "problem6_23staticsubmit.html",
    "href": "problem6_23staticsubmit.html",
    "title": "Problem 6.23 - Power Transmission & Gear Assemblies",
    "section": "",
    "text": "Problem Statement\nA lawnmower engine supplying 2 hp running at 3200 rpm is being used to power a homemade winch. Given the gearing shown, determine the heaviest load that can be lifted.\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.23 - Power Transmission & Gear Assemblies"
    ]
  },
  {
    "objectID": "problem6_27staticsubmit.html",
    "href": "problem6_27staticsubmit.html",
    "title": "Problem 6.27 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA steel rod of diameter d = 40 mm is attached to walls A and C as shown. Two forces F = 2 kN are applied at distance L = 100 mm. If the shear modulus of the rod G = 75 GPa, determine the maximum shear stress in the rod.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.27 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem6_28staticsubmit.html",
    "href": "problem6_28staticsubmit.html",
    "title": "Problem 6.28 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA composite circular rod is made from two different plastics. A torque of T = 4 kN-m is applied at the midpoint. The right end is free. What is the maximum stress in either material? Assume length L = 10 cm and the shear modulus of the two materials are G1 = 2 GPa and G2 = 1 GPa.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.28 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem6_28staticsubmit.html#problem-statement",
    "href": "problem6_28staticsubmit.html#problem-statement",
    "title": "Problem 6.28 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: A composite circular rod is made from two different plastics. A torque is applied at the midpoint.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.28 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem6_29staticsubmit.html",
    "href": "problem6_29staticsubmit.html",
    "title": "Problem 6.29 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA composite circular rod is made from aluminum (G = 3,800 ksi) and steel (G = 11,000 ksi) as shown. A torque T = 800 lb-ft is applied to the free end. What is the maximum stress in either material? Assume length L = 12 in., outer radius ro = 1.5 in., and inner radius ri = 1 in.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.29 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem6_29staticsubmit.html#problem-statement",
    "href": "problem6_29staticsubmit.html#problem-statement",
    "title": "Problem 6.29 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: A composite circular rod is made from aluminum and steel.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.29 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem6_30staticsubmit.html",
    "href": "problem6_30staticsubmit.html",
    "title": "Problem 6.30 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA shaft is fixed between two walls. One portion is made from nickel (Gnickel = 11.4 x 106 psi) with a diameter of d1 = 2 in. The other portion is aluminum (Galuminum = 4 x 106 psi) with a diameter of d2 = 4 in. A torque T = 1,000 lb-ft is applied at the point where the two materials meet. If lengths L1 = 8 ft and L2 = 4 ft, what is the maximum shear stress in the shaft?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.30 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem6_30staticsubmit.html#problem-statement",
    "href": "problem6_30staticsubmit.html#problem-statement",
    "title": "Problem 6.30 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: A shaft made of two different materials is fixed between two walls.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.30 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem6_31staticsubmit.html",
    "href": "problem6_31staticsubmit.html",
    "title": "Problem 6.31 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nTwo steel (G = 80 GPa) circular rods are firmly welded together and attached between two walls. Assume d1 = 5 mm, d2 = 4 mm, and L = 25 mm. A torque T = 10 N-m is applied at the welded joint as shown. What is the highest stress in either rod?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.31 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem6_31staticsubmit.html#problem-statement",
    "href": "problem6_31staticsubmit.html#problem-statement",
    "title": "Problem 6.31 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: Two steel circular rods are firmly welded together and attached between two walls.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.31 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem7_1staticsubmit.html",
    "href": "problem7_1staticsubmit.html",
    "title": "Problem 7.1 - Internal Shear Force & Bending Moment by Equilibrium",
    "section": "",
    "text": "Problem Statement\nA beam is subjected to the loading shown, where w = 60 lb/ft and F = 400 lb. Determine the internal shear force and bending moment at section a-a.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.1 - Internal Shear Force & Bending Moment by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_1staticsubmit.html#problem-statement",
    "href": "problem7_1staticsubmit.html#problem-statement",
    "title": "Problem 7.1 - Internal Shear Force & Bending Moment by Equilibrium",
    "section": "",
    "text": "Figure 1: A beam is subjected to a distributed load and force applied.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.1 - Internal Shear Force & Bending Moment by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_2staticsubmit.html",
    "href": "problem7_2staticsubmit.html",
    "title": "Problem 7.2 - Internal Shear Force & Bending Moment by Equilibrium",
    "section": "",
    "text": "Problem Statement\nA beam is subjected to the loading shown, where w = 4 kN/m and L = 2 m. What is the internal bending moment at section a-a at x = 1 m?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.2 - Internal Shear Force & Bending Moment by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_2staticsubmit.html#problem-statement",
    "href": "problem7_2staticsubmit.html#problem-statement",
    "title": "Problem 7.2 - Internal Shear Force & Bending Moment by Equilibrium",
    "section": "",
    "text": "Figure 1: A beam is subjected to a triangular load as shown.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.2 - Internal Shear Force & Bending Moment by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_3staticsubmit.html",
    "href": "problem7_3staticsubmit.html",
    "title": "Problem 7.3 - Internal Shear Force & Bending Moment by Equilibrium",
    "section": "",
    "text": "Problem Statement\nThree loads are applied to the structure as shown, where F1 = 10 lb., F2 = 13 lb., and F3 = 10 lb applied at an angle Θ = 50°. Determine the internal shear force and bending moment at section aa.\n{fig-alt=” unsure how to describe.”}\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.3 - Internal Shear Force & Bending Moment by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_14staticsubmit.html",
    "href": "problem7_14staticsubmit.html",
    "title": "Problem 7.14 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "Problem Statement\nPlot the shear force and bending moment diagrams for the loading shown. Assume w = 5 kip/ft and L = 6 ft. What is the maximum absolute shear force and maximum absolute bending moment?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.14 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_14staticsubmit.html#problem-statement",
    "href": "problem7_14staticsubmit.html#problem-statement",
    "title": "Problem 7.14 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "Figure 1: A distributed load is applied to a beam.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.14 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_15staticsubmit.html",
    "href": "problem7_15staticsubmit.html",
    "title": "Problem 7.15 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "Problem Statement\nPlot the shear force and bending moment diagrams for the loading shown. Assume M = 10 kip-ft, L1 = 3 ft, and L2 = 4 ft. What is the maximum absolute shear force and maximum absolute bending moment?\n{fig-alt=” A beam is subjected to a clockwise moment at the left end A with supports at B and C. The distance between A and B is L1 and the distance between B and C is L2.”}\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.15 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_16staticsubmit.html",
    "href": "problem7_16staticsubmit.html",
    "title": "Problem 7.16 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "Problem Statement\nPlot the shear force and bending moment diagrams for the loading shown. Assume w = 10 lb/ft, M = 200 lb-ft, and L = 10 ft. What is the maximum absolute shear force and maximum absolute bending moment?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.16 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_16staticsubmit.html#problem-statement",
    "href": "problem7_16staticsubmit.html#problem-statement",
    "title": "Problem 7.16 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "Figure 1: A beam is subjected to a distributed load and a moment with supports at A and B.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.16 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_25staticsubmit.html",
    "href": "problem7_25staticsubmit.html",
    "title": "Problem 7.25 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Problem Statement\nA shelf is loaded with four boxes as shown. Assume W1 = 5 lb, W2 = 10 lb, and L = 1 ft. Determine the maximum internal shear force.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.25 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_25staticsubmit.html#problem-statement",
    "href": "problem7_25staticsubmit.html#problem-statement",
    "title": "Problem 7.25 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Figure 1: A shelf is loaded with four boxes.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.25 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_26staticsubmit.html",
    "href": "problem7_26staticsubmit.html",
    "title": "Problem 7.26 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Problem Statement\nPlot the shear force and bending moment diagrams for the loading shown. Assume w = 30 kN/m, L1 = 3.6 m, and L2 = 1.2 m. What is the maximum absolute shear force and maximum absolute bending moment?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.26 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_26staticsubmit.html#problem-statement",
    "href": "problem7_26staticsubmit.html#problem-statement",
    "title": "Problem 7.26 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Figure 1: A beam is subjected to a distributed load with supports at A and B.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.26 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_27staticsubmit.html",
    "href": "problem7_27staticsubmit.html",
    "title": "Problem 7.27 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Problem Statement\nA beam is loaded as shown. Determine the distance from point A to where the internal shear force is zero. Assume w = 3 kN/m, F1 = 8 kN, and F2 = 5 kN.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.27 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_27staticsubmit.html#problem-statement",
    "href": "problem7_27staticsubmit.html#problem-statement",
    "title": "Problem 7.27 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Figure 1: A beam is loaded as shown.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.27 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_28staticsubmit.html",
    "href": "problem7_28staticsubmit.html",
    "title": "Problem 7.28 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Problem Statement\nPlot the shear force and bending moment diagrams for the loading shown. Assume w1 = 50 kN/m, and w2 = 10 kN/m. What is the maximum absolute shear force and maximum absolute bending moment?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.28 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_28staticsubmit.html#problem-statement",
    "href": "problem7_28staticsubmit.html#problem-statement",
    "title": "Problem 7.28 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Figure 1: A beam is subjected to two distributed loads.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.28 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_29staticsubmit.html",
    "href": "problem7_29staticsubmit.html",
    "title": "Problem 7.29 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Problem Statement\nPlot the shear force and bending moment diagrams for the loading shown. Assume w1 = 2 kip/ft and w2 = 4 kip/ft. What is the maximum absolute shear force and maximum absolute bending moment?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.29 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_29staticsubmit.html#problem-statement",
    "href": "problem7_29staticsubmit.html#problem-statement",
    "title": "Problem 7.29 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Figure 1: A beam is subjected to a non-uniform distributed load.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.29 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem8_1staticsubmit.html",
    "href": "problem8_1staticsubmit.html",
    "title": "Problem 8.1 - Centroid",
    "section": "",
    "text": "Problem Statement\nFor the composite cross-section shown, determine the centroid location, measured from the base. Assume dimensions b1 = 20 mm, b2 = 130 mm, h1 = 6 mm, h2 = 130 mm, and t = 4 mm.\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 8",
      "Problem 8.1 - Centroid"
    ]
  },
  {
    "objectID": "problem8_2staticsubmit.html",
    "href": "problem8_2staticsubmit.html",
    "title": "Problem 8.2 - Centroid",
    "section": "",
    "text": "Problem Statement\nFor the beam cross-section shown, determine the centroid location, measured from the top surface. Assume dimensions a = 3 in. and b = 3 in.\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 8",
      "Problem 8.2 - Centroid"
    ]
  },
  {
    "objectID": "problem8_7staticsubmit.html",
    "href": "problem8_7staticsubmit.html",
    "title": "Problem 8.7 - Area Moment of Inertia",
    "section": "",
    "text": "Problem Statement\nThe cross-section shows a concrete beam with two hollow round holes. Determine the area moment of inertia about the beam’s centroid. Assume lengths a = 5 in., b = 2 in., c = 6 in., d = 4 in., d1 = 3 in., and d2 = 6 in.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 8",
      "Problem 8.7 - Area Moment of Inertia"
    ]
  },
  {
    "objectID": "problem8_7staticsubmit.html#problem-statement",
    "href": "problem8_7staticsubmit.html#problem-statement",
    "title": "Problem 8.7 - Area Moment of Inertia",
    "section": "",
    "text": "Figure 1: A cross section has two round holes.",
    "crumbs": [
      "Chapter 8",
      "Problem 8.7 - Area Moment of Inertia"
    ]
  },
  {
    "objectID": "problem9_1staticsubmit.html",
    "href": "problem9_1staticsubmit.html",
    "title": "Problem 9.1 - Bending Stress",
    "section": "",
    "text": "Problem Statement\nA beam with a rectangular cross-section of base b = 80 mm and h = 200 mm is subjected to the leading shown. If w = 2 kN/m and L = 2 m, determine the magnitude of the largest bending stress in the beam.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.1 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_1staticsubmit.html#problem-statement",
    "href": "problem9_1staticsubmit.html#problem-statement",
    "title": "Problem 9.1 - Bending Stress",
    "section": "",
    "text": "Figure 1: Beam undergoing a distributed load.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.1 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_2staticsubmit.html",
    "href": "problem9_2staticsubmit.html",
    "title": "Problem 9.2 - Bending Stress",
    "section": "",
    "text": "Problem Statement\nA beam has the cross-section shown, where b1 = 10 mm, b2 = 30 mm, h1 = 20 mm, and h2 = 10 mm. The beam is subjected to a concentrated load F = 2 kN at its midpoint. If length L = 2 m, determine the magnitude of the maximum bending stress in the beam.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.2 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_2staticsubmit.html#problem-statement",
    "href": "problem9_2staticsubmit.html#problem-statement",
    "title": "Problem 9.2 - Bending Stress",
    "section": "",
    "text": "Figure 1: A beam has a force applied to it.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.2 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_3staticsubmit.html",
    "href": "problem9_3staticsubmit.html",
    "title": "Problem 9.3 - Bending Stress",
    "section": "",
    "text": "Problem Statement\nA person of mass m = 80 kg stands on the end of a diving board with cross-section b = 300 mm and h = 50 mm. If lengths L1 = 1 m and L2 = 2 m, determine the maximum bending stress in the board. Assume g = 9.81 m/s2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.3 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_3staticsubmit.html#problem-statement",
    "href": "problem9_3staticsubmit.html#problem-statement",
    "title": "Problem 9.3 - Bending Stress",
    "section": "",
    "text": "Figure 1: A diving board with a person standing on it.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.3 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_4staticsubmit.html",
    "href": "problem9_4staticsubmit.html",
    "title": "Problem 9.4 - Bending Stress",
    "section": "",
    "text": "Problem Statement\nA beam with a hollow circular cross-section of outer radius ro = 5.5 in. and inner radius ri = 5 in. is subjected to a distributed load as shown. If w = 100 lb/ft, L1 = 5 ft, and L2 = 10 ft, determine the magnitude of the maximum bending stress in the beam.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.4 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_4staticsubmit.html#problem-statement",
    "href": "problem9_4staticsubmit.html#problem-statement",
    "title": "Problem 9.4 - Bending Stress",
    "section": "",
    "text": "Figure 1: A beam with a circular cross section is subjected to a distributed load.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.4 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_5staticsubmit.html",
    "href": "problem9_5staticsubmit.html",
    "title": "Problem 9.5 - Bending Stress",
    "section": "",
    "text": "Problem Statement\nA beam has the cross-section shown where b = 2 in. and h = 2 in. If the cross-section is subjected to an internal bending moment of 10 kip-in, determine the magnitude of the bending stress at the bottom of the cross-section.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.5 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_5staticsubmit.html#problem-statement",
    "href": "problem9_5staticsubmit.html#problem-statement",
    "title": "Problem 9.5 - Bending Stress",
    "section": "",
    "text": "Figure 1: The cross section of a beam.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.5 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_21staticsubmit.html",
    "href": "problem9_21staticsubmit.html",
    "title": "Problem 9.21 - Beam Design",
    "section": "",
    "text": "Problem Statement\nA beam with a rectangular cross-section is subjected to a distributed load w = 3 kN/m as shown. The maximum allowable bending stress in the beam is 7 MPa. If length L = 5 m and the cross-sectional area of the beam is A = 0.025 m2, determine the required width (b) of the cross-section.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.21 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_21staticsubmit.html#problem-statement",
    "href": "problem9_21staticsubmit.html#problem-statement",
    "title": "Problem 9.21 - Beam Design",
    "section": "",
    "text": "Figure 1: A beam is subjected to a distributed load.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.21 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_22staticsubmit.html",
    "href": "problem9_22staticsubmit.html",
    "title": "Problem 9.22 - Beam Design",
    "section": "",
    "text": "Problem Statement\nA wide-flange beam supports two loads F = 12 kN as shown. If L = 2 m and the allowable stress is σ = 250 MPa, what is the lightest W-beam in Appendix A that could be used for the beam?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.22 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_22staticsubmit.html#problem-statement",
    "href": "problem9_22staticsubmit.html#problem-statement",
    "title": "Problem 9.22 - Beam Design",
    "section": "",
    "text": "Figure 1: A wide flange beam is subjected to two loads.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.22 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_23staticsubmit.html",
    "href": "problem9_23staticsubmit.html",
    "title": "Problem 9.23 - Beam Design",
    "section": "",
    "text": "Problem Statement\nA wide flange beam supports the distributed load shown, where w0 = 5 kN/m. If length L = 3 m and the allowable stress is σ = 150 MPa, what is the lightest W-beam in Appendix A that could be used for the beam?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.23 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_23staticsubmit.html#problem-statement",
    "href": "problem9_23staticsubmit.html#problem-statement",
    "title": "Problem 9.23 - Beam Design",
    "section": "",
    "text": "Figure 1: An I beam is subjected to a triangular load.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.23 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_24staticsubmit.html",
    "href": "problem9_24staticsubmit.html",
    "title": "Problem 9.24 - Beam Design",
    "section": "",
    "text": "Problem Statement\nA wide flange I-beam is fixed at one end into a wall, and loaded with both a distributed load w = 0.5 kN/m and a point load F = 1 kN. If length L = 12 m and the failure stress is 250 MPa, what is the lightest W-beam from Appendix A that could be used for the beam? Use a factor of safety of 2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.24 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_24staticsubmit.html#problem-statement",
    "href": "problem9_24staticsubmit.html#problem-statement",
    "title": "Problem 9.24 - Beam Design",
    "section": "",
    "text": "Figure 1: An I beam is subjected to a distribued load and a tip force.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.24 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_25staticsubmit.html",
    "href": "problem9_25staticsubmit.html",
    "title": "Problem 9.25 - Beam Design",
    "section": "",
    "text": "Problem Statement\nA wide flange I-beam is subjected to both a distributed load w = 4 kN/m and a point load F = 25 kN. If length L1 = 10 m, L2 = 5 m, and the failure stress is 375 MPa, what is the lightest W-beam from Appendix A that could be used for the beam?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.25 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_25staticsubmit.html#problem-statement",
    "href": "problem9_25staticsubmit.html#problem-statement",
    "title": "Problem 9.25 - Beam Design",
    "section": "",
    "text": "Figure 1: A I beam is subjected to a distributed load and a tip load.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.25 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_31staticsubmit.html",
    "href": "problem9_31staticsubmit.html",
    "title": "Problem 9.31 - Unsymmetric Bending",
    "section": "",
    "text": "Problem Statement\nTwo loads, F1 = 8 kips and F2 = 12 kips, are applied at the end of a cantilever beam as shown. Both loads act through the center of the rectangular cross-section of base b = 6 in. and height h = 12 in. If length L = 5 ft, determine the stress at point P in the beam at the wall.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.31 - Unsymmetric Bending"
    ]
  },
  {
    "objectID": "problem9_32staticsubmit.html",
    "href": "problem9_32staticsubmit.html",
    "title": "Problem 9.32 - Unsymmetric Bending",
    "section": "",
    "text": "Problem Statement\nTwo moments, Mz = 1.5 kN-m and My = 1.0 kN-m, act on a beam with the rectangular cross-section shown. If base b = 80 mm and height h = 60 mm, determine the bending stress at point A. Recall the convention that tensile stresses are positive and compressive stresses are negative.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.32 - Unsymmetric Bending"
    ]
  },
  {
    "objectID": "problem9_33staticsubmit.html",
    "href": "problem9_33staticsubmit.html",
    "title": "Problem 9.33 - Unsymmetric Bending",
    "section": "",
    "text": "Problem Statement\nA W14 x 34 steel beam supports a load F = 5 kips at its center. The beam is on a sloped roof so the load acts at an angle Θ = 22° as shown. If length L = 4 ft, determine the stress at point A. Recall the convention that tensile stresses are positive and compressive stresses are negative.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.33 - Unsymmetric Bending"
    ]
  },
  {
    "objectID": "problem9_34staticsubmit.html",
    "href": "problem9_34staticsubmit.html",
    "title": "Problem 9.34 - Unsymmetric Bending",
    "section": "",
    "text": "Problem Statement\nA cantilevered beam is subjected to a load F = 10 kN at its end, oriented Θ = 25° from the vertical. If length L = 0.35 m, determine the maximum bending stress in the beam. The beam has outer radius ro = 40 mm and inner radius ri = 30 mm.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.34 - Unsymmetric Bending"
    ]
  },
  {
    "objectID": "problem10_1staticsubmit.html",
    "href": "problem10_1staticsubmit.html",
    "title": "Problem 10.1 - 1st Moment of Area",
    "section": "",
    "text": "Problem Statement\nFor the built-up T-beam shown, determine the first moment of area, Q, at point A and at the centroid of the cross-section. Assume dimensions b1 = 1.5 in., b2 = 5.5 in., h1 = 7.5 in., and h2 = 1.5 in.\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.1 - 1st Moment of Area"
    ]
  },
  {
    "objectID": "problem10_4staticsubmit.html",
    "href": "problem10_4staticsubmit.html",
    "title": "Problem 10.4 - Shear Stress",
    "section": "",
    "text": "Problem Statement\nA simply supported beam is constructed from two wooden boards as shown. The beam supports a distributed load w = 3.5 kN/m. If lengths L1 = 1.5 m and L2 = 3 m, what is the maximum shear stress in the glue that holds the boards together?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.4 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_4staticsubmit.html#problem-statement",
    "href": "problem10_4staticsubmit.html#problem-statement",
    "title": "Problem 10.4 - Shear Stress",
    "section": "",
    "text": "Figure 1: A simply supported beam constructed of two wood boards is subjected to a force as shown.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.4 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_5staticsubmit.html",
    "href": "problem10_5staticsubmit.html",
    "title": "Problem 10.5 - Shear Stress",
    "section": "",
    "text": "Problem Statement\nA simply supported beam is constructed from two wooden boards as shown. The beam supports a concentrated load F = 10 kN. If length L = 5 m and cross-section dimensions b = 40 mm and h = 20 mm, determine the shear stress in the glue that holds the boards together.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.5 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_5staticsubmit.html#problem-statement",
    "href": "problem10_5staticsubmit.html#problem-statement",
    "title": "Problem 10.5 - Shear Stress",
    "section": "",
    "text": "Figure 1: A simply supported beam constructed of two wood boards is subjected to a force as shown.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.5 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_6staticsubmit.html",
    "href": "problem10_6staticsubmit.html",
    "title": "Problem 10.6 - Shear Stress",
    "section": "",
    "text": "Problem Statement\nA T-beam has dimensions b1 = 1 in., b2 = 9 in., h1 = 6 in., and h2 = 1 in. If the shear force at this section is V = 5 kips, determine the shear stress at section a-a.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.6 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_6staticsubmit.html#problem-statement",
    "href": "problem10_6staticsubmit.html#problem-statement",
    "title": "Problem 10.6 - Shear Stress",
    "section": "",
    "text": "Figure 1: A T-beam is subjected to a shear load.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.6 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_7staticsubmit.html",
    "href": "problem10_7staticsubmit.html",
    "title": "Problem 10.7 - Shear Stress",
    "section": "",
    "text": "Problem Statement\nA beam of length L = 10 ft is constructed by gluing together two boards and is subjected to a concentrated load F = 500 lb. The cross-section has dimensions b = 3 in. and h = 1 in. Determine the shear stress at the seam between the two boards at section a-a.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.7 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_7staticsubmit.html#problem-statement",
    "href": "problem10_7staticsubmit.html#problem-statement",
    "title": "Problem 10.7 - Shear Stress",
    "section": "",
    "text": "Figure 1: A beam constructed of two sections glued together is subjected to a force.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.7 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_8staticsubmit.html",
    "href": "problem10_8staticsubmit.html",
    "title": "Problem 10.8 - Shear Stress",
    "section": "",
    "text": "Problem Statement\nA cantilever beam is loaded as shown, where w = 1 lb/in., F1 = 5 lb, and F2 = 10 lb. What is the maximum shear stress in the beam?",
    "crumbs": [
      "Chapter 10",
      "Problem 10.8 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_8staticsubmit.html#problem-image",
    "href": "problem10_8staticsubmit.html#problem-image",
    "title": "Problem 10.8 - Shear Stress",
    "section": "Problem Image",
    "text": "Problem Image\n\n\n\nFigure 1: A cantilever beam is subjected to the loading as shown.\n\n\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.8 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_17staticsubmit.html",
    "href": "problem10_17staticsubmit.html",
    "title": "Problem 10.17 - Shear Flow",
    "section": "",
    "text": "Problem Statement\nA beam of length L = 10 ft is constructed by nailing together two boards with dimensions b = 3.5 in. and h = 1.5 in. The beam is subjected to a concentrated load F = 100 lb as shown. Each nail can withstand a shear load of 100 lb. What is the maximum permissible spacing between nails?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.17 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_17staticsubmit.html#problem-statement",
    "href": "problem10_17staticsubmit.html#problem-statement",
    "title": "Problem 10.17 - Shear Flow",
    "section": "",
    "text": "Figure 1: A cantilever beam constructed of two boards nailed together is subjected to a point load.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.17 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_18staticsubmit.html",
    "href": "problem10_18staticsubmit.html",
    "title": "Problem 10.18 - Shear Flow",
    "section": "",
    "text": "Problem Statement\nA 4-m-long beam is constructed by nailing together two wooden boards as shown. The nails each have a diameter d = 5 mm and can withstand an average shear stress of 100 MPa. If loads F1 = 3 kN, F2 = 4 kN, and F3 = 2 kN, determine the maximum permissible spacing between the nails.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.18 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_18staticsubmit.html#problem-statement",
    "href": "problem10_18staticsubmit.html#problem-statement",
    "title": "Problem 10.18 - Shear Flow",
    "section": "",
    "text": "Figure 1: A cantilever beam constructed of two boards nailed together is subjected to the loading as shown.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.18 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_19staticsubmit.html",
    "href": "problem10_19staticsubmit.html",
    "title": "Problem 10.19 - Shear Flow",
    "section": "",
    "text": "Problem Statement\nA beam of length L = 8 ft is constructed by nailing together three wooden boards. The beam is subjected to a concentrated load F = 300 lb. If each nail can resist a shear load of 100 lb, determine the maximum permissible spacing between the nails.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.19 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_19staticsubmit.html#problem-statement",
    "href": "problem10_19staticsubmit.html#problem-statement",
    "title": "Problem 10.19 - Shear Flow",
    "section": "",
    "text": "Figure 1: A simply supported beam consisting of three pieces nailed together is subjected to a point load.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.19 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_20staticsubmit.html",
    "href": "problem10_20staticsubmit.html",
    "title": "Problem 10.20 - Shear Flow",
    "section": "",
    "text": "Problem Statement\nA T-beam is constructed from two wooden boards nailed together as shown. The nails can withstand a shear load of 10 kN and the beam is subjected to a maximum shear force V = 30 kN. If dimensions b1 =20 mm, b2 = 200 mm, h1 = 160 mm, and h2 = 20 mm, determine the minimum permissible spacing between the nails.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.20 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_20staticsubmit.html#problem-statement",
    "href": "problem10_20staticsubmit.html#problem-statement",
    "title": "Problem 10.20 - Shear Flow",
    "section": "",
    "text": "Figure 1: A T-beam is constructed of two plywood sheets nailed together.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.20 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_21staticsubmit.html",
    "href": "problem10_21staticsubmit.html",
    "title": "Problem 10.21 - Shear Flow",
    "section": "",
    "text": "Problem Statement\nA beam is constructed from two boards nailed together as shown, with dimensions b = 3 in., h1 = 1 in., and h2 = 2 in. The nails can withstand a shear load of 850 lb and the beam is subjected to a maximum shear force V = 2 kips. Determine the maximum permissible spacing between the nails.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.21 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_21staticsubmit.html#problem-statement",
    "href": "problem10_21staticsubmit.html#problem-statement",
    "title": "Problem 10.21 - Shear Flow",
    "section": "",
    "text": "Figure 1: A beam is constructed from two pieces nailed together.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.21 - Shear Flow"
    ]
  },
  {
    "objectID": "problem11_1staticsubmit.html",
    "href": "problem11_1staticsubmit.html",
    "title": "Problem 11.1 - By Integration of Moment Equation",
    "section": "",
    "text": "Problem Statement\nA cantilever beam of length L = 7.5 m is subjected to a distributed load w = 6.5 kN/m and concentrated load P = 15 kN. Determine the maximum deflection of the beam. Assume EI = 25,000 kN-m2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.1 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_1staticsubmit.html#problem-statement",
    "href": "problem11_1staticsubmit.html#problem-statement",
    "title": "Problem 11.1 - By Integration of Moment Equation",
    "section": "",
    "text": "Figure 1: A cantilever beam is subjected to the loading shown.",
    "crumbs": [
      "Chapter 11",
      "Problem 11.1 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_2staticsubmit.html",
    "href": "problem11_2staticsubmit.html",
    "title": "Problem 11.2 - By Integration of Moment Equation",
    "section": "",
    "text": "Problem Statement\nA cantilever beam of length L = 1.5 m is subjected to a linear distributed load where w0 = 1 kN/m. Determine the magnitude of the slope of the beam at the free end. Assume EI = 10 kN-m2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.2 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_2staticsubmit.html#problem-statement",
    "href": "problem11_2staticsubmit.html#problem-statement",
    "title": "Problem 11.2 - By Integration of Moment Equation",
    "section": "",
    "text": "Figure 1: A cantilever beam is subjected to the loading shown.",
    "crumbs": [
      "Chapter 11",
      "Problem 11.2 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_3staticsubmit.html",
    "href": "problem11_3staticsubmit.html",
    "title": "Problem 11.3 - By Integration of Moment Equation",
    "section": "",
    "text": "Problem Statement\nA cantilever beam of length L = 4 m is subjected to a distributed load w = 2 kN/m and couple M = 5 kN-m. Determine the deflection of the beam at the free end. Assume EI = 25,000 kN-m2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.3 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_3staticsubmit.html#problem-statement",
    "href": "problem11_3staticsubmit.html#problem-statement",
    "title": "Problem 11.3 - By Integration of Moment Equation",
    "section": "",
    "text": "Figure 1: A cantilever beam is subjected to the loading shown.",
    "crumbs": [
      "Chapter 11",
      "Problem 11.3 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_4staticsubmit.html",
    "href": "problem11_4staticsubmit.html",
    "title": "Problem 11.4 - By Integration of Moment Equation",
    "section": "",
    "text": "Problem Statement\nA cantilever beam of length L = 5.5 m is subjected to a distributed load w = 5.5 kN/m. Determine the magnitude of the deflection of the beam at point B. Assume EI = 25,000 kN-m2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.4 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_4staticsubmit.html#problem-statement",
    "href": "problem11_4staticsubmit.html#problem-statement",
    "title": "Problem 11.4 - By Integration of Moment Equation",
    "section": "",
    "text": "Figure 1: A cantilever beam is subjected to the loading shown.",
    "crumbs": [
      "Chapter 11",
      "Problem 11.4 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_5staticsubmit.html",
    "href": "problem11_5staticsubmit.html",
    "title": "Problem 11.5 - By Integration of Moment Equation",
    "section": "",
    "text": "Problem Statement\nA cantilever beam of length L = 6.5 ft is subjected to a distributed load w = 300 lb/in. and a concentrated load F = 2.5 kips as shown. Determine the magnitude of the deflection of the beam at point B. Assume EI = 45,000 kip-in.2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.5 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_5staticsubmit.html#problem-statement",
    "href": "problem11_5staticsubmit.html#problem-statement",
    "title": "Problem 11.5 - By Integration of Moment Equation",
    "section": "",
    "text": "Figure 1: A simply supported beam is subjected to the loading shown.",
    "crumbs": [
      "Chapter 11",
      "Problem 11.5 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_17staticsubmit.html",
    "href": "problem11_17staticsubmit.html",
    "title": "Problem 11.17 - By Integration of Load Equation",
    "section": "",
    "text": "Problem Statement\nA beam of length L = 10 m is subjected to a distributed load as shown where w0 = 35 kN/m. Determine the magnitude of the deflection at x = 0.55L. Assume EI = 15,000 kN-m2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.17 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_17staticsubmit.html#problem-statement",
    "href": "problem11_17staticsubmit.html#problem-statement",
    "title": "Problem 11.17 - By Integration of Load Equation",
    "section": "",
    "text": "Figure 1: A simply supported beam is subjected to the loading shown.",
    "crumbs": [
      "Chapter 11",
      "Problem 11.17 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_18staticsubmit.html",
    "href": "problem11_18staticsubmit.html",
    "title": "Problem 11.18 - By Integration of Load Equation",
    "section": "",
    "text": "Problem Statement\nA beam of length L = 10 ft is subjected to a distributed load as shown where w0 = 50 kip/ft. Determine the magnitude of the deflection at x = 0.5L. Assume EI = 45,000 kip-ft2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.18 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_18staticsubmit.html#problem-statement",
    "href": "problem11_18staticsubmit.html#problem-statement",
    "title": "Problem 11.18 - By Integration of Load Equation",
    "section": "",
    "text": "Figure 1: A simply supported beam is subjected to the loading shown.",
    "crumbs": [
      "Chapter 11",
      "Problem 11.18 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_19staticsubmit.html",
    "href": "problem11_19staticsubmit.html",
    "title": "Problem 11.19 - By Integration of Load Equation",
    "section": "",
    "text": "Problem Statement\nA beam of length L = 15 ft is subjected to a distributed load as shown where w0 = 25 kip/ft. Determine the magnitude of the deflection at x = 0.5L. Assume EI = 45,000 kip-ft2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.19 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_19staticsubmit.html#problem-statement",
    "href": "problem11_19staticsubmit.html#problem-statement",
    "title": "Problem 11.19 - By Integration of Load Equation",
    "section": "",
    "text": "Figure 1: A cantilever beam is subjected to the loading shown.",
    "crumbs": [
      "Chapter 11",
      "Problem 11.19 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_22staticsubmit.html",
    "href": "problem11_22staticsubmit.html",
    "title": "Problem 11.22 - By Superposition",
    "section": "",
    "text": "Problem Statement\nA cantilever beam is loaded as shown where L = 10 m, M = 50 kN-m, and F = 50 kN. Determine the magnitude of the deflection at the free end of the beam. Assume EI = 45000 kN-m2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.22 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_23staticsubmit.html",
    "href": "problem11_23staticsubmit.html",
    "title": "Problem 11.23 - By Superposition",
    "section": "",
    "text": "Problem Statement\nA simply supported beam is loaded as shown where L = 5 m, M = 2 kN-m, w = 1.5 kN/m, and F = 1 kN. Determine the magnitude of the deflection at the center of the beam. Assume EI = 30000 kN-m2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.23 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_24staticsubmit.html",
    "href": "problem11_24staticsubmit.html",
    "title": "Problem 11.24 - By Superposition",
    "section": "",
    "text": "Problem Statement\nA simply supported beam is loaded as shown where L = 2 m, w1 = 2 kN/m, and w2 = 3 kN/m. Determine the magnitude of the deflection at the center of the beam. Assume EI = 30,000 kN-m2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.24 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_25staticsubmit.html",
    "href": "problem11_25staticsubmit.html",
    "title": "Problem 11.25 - By Superposition",
    "section": "",
    "text": "Problem Statement\nAn overhanging beam is loaded as shown where L = 7.5 m and w = 7.5 kN/m. Determine the magnitude of the deflection at point A. Assume EI = 30,000 kN-m2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.25 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_26staticsubmit.html",
    "href": "problem11_26staticsubmit.html",
    "title": "Problem 11.26 - By Superposition",
    "section": "",
    "text": "Problem Statement\nAn overhanging beam is loaded as shown where L1 = 7 ft, L2 = 5 ft, and w = 200 kip/ft. Determine the deflection at the point C. Assume EI = 29,000 kip-ft2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.26 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_36staticsubmit.html",
    "href": "problem11_36staticsubmit.html",
    "title": "Problem 11.36 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA beam of length L1 = 3 ft and L2 = 6 ft is subjected to a distributed load w = 250 kip/ft as shown. Determine the reaction force at support B. Assume EI = 20,000 kip-ft2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.36 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem11_37staticsubmit.html",
    "href": "problem11_37staticsubmit.html",
    "title": "Problem 11.37 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA beam is subjected to two distributed loads, w1 = 2 kN/m and w2 = 3 kN/m as shown. It is supported by a pin at A and rollers at B and C. If length L = 2 m, determine the reaction force at support B. Assume EI = 30,000 kN-m2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.37 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem11_38staticsubmit.html",
    "href": "problem11_38staticsubmit.html",
    "title": "Problem 11.38 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA propped cantilever beam is subjected to a distributed load w = 2 kip/ft as shown. If length L1 = 2 ft, L2 = 3 ft, and L3 = 3 ft, determine the magnitude of the moment reaction at the wall. Assume EI = 20,000 kip-ft2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.38 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem11_39staticsubmit.html",
    "href": "problem11_39staticsubmit.html",
    "title": "Problem 11.39 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA beam is subjected to force F = 155 kN as shown. If length L = 4 m, determine the reaction force at support B. Assume EI = 30,000 kN-m2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.39 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem11_40staticsubmit.html",
    "href": "problem11_40staticsubmit.html",
    "title": "Problem 11.40 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA beam is subjected to force F = 10 kN as shown. If length L = 2 m, determine the reaction force at support B. Assume EI = 12,500 kN-m2.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.40 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem11_50staticsubmit.html",
    "href": "problem11_50staticsubmit.html",
    "title": "Problem 11.50 - Intermediate Beam Design",
    "section": "",
    "text": "Problem Statement\nA W18 x 76 shape (E = 29,000 ksi) is to be simply-supported and carry a uniform distributed load, w. If the beam has an allowable bending stress σ = 34 ksi, allowable shear stress τ = 14 ksi, and allowable deflection of span/240, determine the maximum load, w, for a span L = 30 ft. Ignore self-weight.\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.50 - Intermediate Beam Design"
    ]
  },
  {
    "objectID": "problem11_50staticsubmit.html#problem-statement",
    "href": "problem11_50staticsubmit.html#problem-statement",
    "title": "Problem 11.50 - Intermediate Beam Design",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"681\"\nsigma=reactive.Value(\"__\")\ntau=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip/ft\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A W18 x 76 shape (E = 29,000 ksi) is to be simply-supported and carry a uniform distributed load, ω. If the beam has an allowable bending stress σ = {sigma()} ksi, allowable shear stress τ = {tau()} ksi, and allowable deflection of span/240, determine the maximum load, ω, for a span L = {L()} ft. Ignore self-weight.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma.set(random.randrange(20, 30, 1))\n        tau.set(sigma()-random.randrange(6, 12, 1))\n        L.set(random.randrange(20, 40, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= 8*146*sigma()/(L()*12)**2*12\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11",
      "Problem 11.50 - Intermediate Beam Design"
    ]
  },
  {
    "objectID": "problem11_51staticsubmit.html",
    "href": "problem11_51staticsubmit.html",
    "title": "Problem 11.51 - Intermediate Beam Design",
    "section": "",
    "text": "Problem Statement\nA window manufacturer is considering maximum sizes possible for a hollow aluminum tube section (E = 67 GPa). The tube will be simply-supported with a uniform distributed load, w = 6.2 kN/m. If the aluminum tube has an allowable bending stress σ = 250 MPa, allowable shear stress τ = 150 MPa, and deflection limit of span/480, determine the longest span allowed. Assume dimensions b = 102 mm and h = 154 mm.\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.51 - Intermediate Beam Design"
    ]
  },
  {
    "objectID": "problem11_51staticsubmit.html#problem-statement",
    "href": "problem11_51staticsubmit.html#problem-statement",
    "title": "Problem 11.51 - Intermediate Beam Design",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"682\"\nw=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A window manufacturer is considering maximum sizes possible for a hollow aluminum tube section (E = 67 GPa). The tube will be simply-supported with a uniform distributed load, ω = {w()} kN/m. If the aluminum tube has an allowable bending stress σ = 250 MPa, allowable shear stress τ = 150 MPa, and deflection limit of span/480, determine the longest span allowed. Assume dimensions b = {b()} mm and h = {h()} mm.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(50, 100, 1)/10)\n        b.set(random.randrange(80, 120, 1))\n        h.set(random.randrange(150, 200, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = b()*h()**3/12-((b()-7.4)*(h()-7.4)**3/12)\n        instr= (384*67*I/(2400*w()/1000))**(1/3)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11",
      "Problem 11.51 - Intermediate Beam Design"
    ]
  },
  {
    "objectID": "problem11_53staticsubmit.html",
    "href": "problem11_53staticsubmit.html",
    "title": "Problem 11.53 - Intermediate Beam Design",
    "section": "",
    "text": "Problem Statement\nA pipe with an outer diameter of 100 mm is to be used as a cantilever beam of length L = 2.5 m carrying a load P = 6.8 kN at the free end. Determine the minimum required pipe wall thickness if the allowable bending stress, σallow = 400 MPa, the allowable shear stress, τallow = 240 MPa, and the allowable deflection = 50 mm. Assume E = 200 GPa.\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.53 - Intermediate Beam Design"
    ]
  },
  {
    "objectID": "problem12_1staticsubmit.html",
    "href": "problem12_1staticsubmit.html",
    "title": "Problem 12.1 - Equations",
    "section": "",
    "text": "Problem Statement\nA point in a beam is subjected to the state of stress shown, where σx = 20 ksi, σy = 35 ksi, and τxy = 15 ksi. Determine the normal stress acting on plane a-a if angle Θ = 25°.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.1 - Equations"
    ]
  },
  {
    "objectID": "problem12_2staticsubmit.html",
    "href": "problem12_2staticsubmit.html",
    "title": "Problem 12.2 - Equations",
    "section": "",
    "text": "Problem Statement\nA point in a beam is subjected to the state of stress shown, where σx = 12 MPa, σy = 24 MPa, and τxy = 6 MPa. Determine the normal stress acting on plane a-a if angle Θ = 25°.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.2 - Equations"
    ]
  },
  {
    "objectID": "problem12_3staticsubmit.html",
    "href": "problem12_3staticsubmit.html",
    "title": "Problem 12.3 - Equations",
    "section": "",
    "text": "Problem Statement\nA point in a beam is subjected to the state of stress shown, where σx = 5.0 MPa, σy = 12.5 MPa, and τxy = 3.5 MPa. Determine the magnitude of the normal stress and the magnitude of the shear stress acting on plane a-a if angle Θ = 67°.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.3 - Equations"
    ]
  },
  {
    "objectID": "problem12_4staticsubmit.html",
    "href": "problem12_4staticsubmit.html",
    "title": "Problem 12.4 - Equations",
    "section": "",
    "text": "Problem Statement\nA material made from fibers is stressed as shown in the diagram. Stresses σx = 20 ksi, σy = 10 ksi, and τxy = 10 ksi. Determine the magnitude of the normal stress acting perpendicular to the fibers and the magnitude of the shear stress acting parallel to the fibers if angle Θ = 20°.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.4 - Equations"
    ]
  },
  {
    "objectID": "problem12_5staticsubmit.html",
    "href": "problem12_5staticsubmit.html",
    "title": "Problem 12.5 - Equations",
    "section": "",
    "text": "Problem Statement\nA material made from fibers is stressed as shown in the diagram. Stresses σx = 45 ksi, σy = 5 ksi, and τxy = 10 ksi. Determine the magnitude of the normal stress acting perpendicular to the fibers and the magnitude of the shear stress acting parallel to the fibers if angle Θ = 18°.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.5 - Equations"
    ]
  },
  {
    "objectID": "problem12_9staticsubmit.html",
    "href": "problem12_9staticsubmit.html",
    "title": "Problem 12.9 - Principal Stresses",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where σx = 30 MPa, σy = 20 MPa, and τxy = 15 MPa. Determine the maximum principal stress σ1 for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.9 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_10staticsubmit.html",
    "href": "problem12_10staticsubmit.html",
    "title": "Problem 12.10 - Principal Stresses",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where σx = 30 ksi, σy = 10 ksi, and τxy = 15 ksi. Determine the maximum shear stress for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.10 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_11staticsubmit.html",
    "href": "problem12_11staticsubmit.html",
    "title": "Problem 12.11 - Principal Stresses",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where σx = 35.8 ksi, σy = 11.5 ksi, and τxy = 56.3 ksi. Determine the maximum shear stress for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.11 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_11staticsubmit.html#problem-statement",
    "href": "problem12_11staticsubmit.html#problem-statement",
    "title": "Problem 12.11 - Principal Stresses",
    "section": "",
    "text": "Figure 1: A member is subjected to a state of stress.",
    "crumbs": [
      "Chapter 12",
      "Problem 12.11 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_12staticsubmit.html",
    "href": "problem12_12staticsubmit.html",
    "title": "Problem 12.12 - Principal Stresses",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where σx = 3 MPa, σy = 5 MPa, and τxy = 3 MPa. Determine the maximum principal stress σ1 for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.12 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_13staticsubmit.html",
    "href": "problem12_13staticsubmit.html",
    "title": "Problem 12.13 - Principal Stresses",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where σx = 25 ksi, σy = 15 ksi, and τxy is unknown. The maximum shear stress for this state of stress is τmax = 30 ksi. Determine the angle that this maximum stress occurs at.\n{fig-alt=A member is subjected to a state of stress caused by sigma_x, and sigma_y.”} [Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.13 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_25staticsubmit.html",
    "href": "problem12_25staticsubmit.html",
    "title": "Problem 12.25 - Mohr’s Circle",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where σx = 30 ksi, σy = 20 ksi, and τxy = 10 ksi. Construct Mohr’s Circle for the given state of stress. Then determine the maximum principal stress σ1 for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.25 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_26staticsubmit.html",
    "href": "problem12_26staticsubmit.html",
    "title": "Problem 12.26 - Mohr’s Circle",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where σx = 20 MPa, σy = 10 MPa, and τxy = 10 MPa. Construct Mohr’s Circle for the given state of stress. Then determine the maximum principal stress σ1 for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.26 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_27staticsubmit.html",
    "href": "problem12_27staticsubmit.html",
    "title": "Problem 12.27 - Mohr’s Circle",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where σx = 10 MPa, σy = 10 MPa, and τxy = 5 MPa. Construct Mohr’s Circle for the given state of stress. Then determine the maximum in-plane shear stress τmax for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.27 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_28staticsubmit.html",
    "href": "problem12_28staticsubmit.html",
    "title": "Problem 12.28 - Mohr’s Circle",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where σx = 35 ksi, σy = 15 ksi, and τxy = 25 ksi. Construct Mohr’s Circle for the given state of stress. Then determine the maximum principal stress σ1 for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.28 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_29staticsubmit.html",
    "href": "problem12_29staticsubmit.html",
    "title": "Problem 12.29 - Mohr’s Circle",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where σx = 13.2 ksi, σy = 7.5 ksi, and τxy = 1.8 ksi. Construct Mohr’s Circle for the given state of stress. Then determine the maximum principal stress σ1 for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.29 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_39staticsubmit.html",
    "href": "problem12_39staticsubmit.html",
    "title": "Problem 12.39 - 3D Mohr’s Circle",
    "section": "",
    "text": "Problem Statement\nA plane stress state results in principal stress σ1 = 435 MPa and σ2 = -124 MPa. Use Mohr’s Circle to determine the maximum in-plane and maximum absolute shear stresses.\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.39 - 3D Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_40staticsubmit.html",
    "href": "problem12_40staticsubmit.html",
    "title": "Problem 12.40 - 3D Mohr’s Circle",
    "section": "",
    "text": "Problem Statement\nA plane stress state results in principal stress σ1 = 3.2 ksi and τmax-in-plane = 1.04 ksi. Use Mohr’s Circle to determine σ2 and the maximum absolute shear stresses.\n[Problem adapted from © Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.40 - 3D Mohr's Circle"
    ]
  },
  {
    "objectID": "problem13_1staticsubmit.html",
    "href": "problem13_1staticsubmit.html",
    "title": "Problem 13.1 - Cylindrical",
    "section": "",
    "text": "Problem Statement\nA thin-walled cylindrical pressure vessel with an outside diameter d = 18 in. is subjected to an internal pressure P = 100 psi and an external torque T = 180 kip-in. at its top. The base is fixed to the ground. If the vessel wall thickness is t = 0.25 in., determine the absolute largest principal stress in the vessel wall.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 13",
      "Problem 13.1 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_2staticsubmit.html",
    "href": "problem13_2staticsubmit.html",
    "title": "Problem 13.2 - Cylindrical",
    "section": "",
    "text": "Problem Statement\nA cylindrical pressure vessel of outer diameter d = 750 mm experiences an internal pressure P = 20 kPa. Determine the maximum in-plane shear stress in the vessel wall if the wall thickness is t = 10 mm.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 13",
      "Problem 13.2 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_3staticsubmit.html",
    "href": "problem13_3staticsubmit.html",
    "title": "Problem 13.3 - Cylindrical",
    "section": "",
    "text": "Problem Statement\nA gas storage tank with an internal radius ri = 18 in. and wall thickness t = 3/8 in. is filled to an internal pressure P = 2,000 psi. If the original length L = 18 ft., determine the total axial deflection (change in length) of the tank after filling. Assume E = 29,000 ksi and ν = 0.3.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 13",
      "Problem 13.3 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_4staticsubmit.html",
    "href": "problem13_4staticsubmit.html",
    "title": "Problem 13.4 - Cylindrical",
    "section": "",
    "text": "Problem Statement\nA cylindrical thin-walled pressure vessel with an inner diameter di = 240 mm is subjected to an unknown internal pressure, P. A vertical load F = 1 kN is also applied to the vessel as shown. If length L = 3.2 m and the wall thickness t = 1 mm, what pressure will cause the axial and hoop stresses to be equal?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 13",
      "Problem 13.4 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_15staticsubmit.html",
    "href": "problem13_15staticsubmit.html",
    "title": "Problem 13.15 - Spherical",
    "section": "",
    "text": "Problem Statement\nA balloon with a wall thickness of 0.02 in. is inflated to a pressure of 30 psi. If the balloon material fails in tension at 8,000 psi, what is the maximum radius of the balloon using a factor of safety of 2?\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 13",
      "Problem 13.15 - Spherical"
    ]
  },
  {
    "objectID": "problem13_16staticsubmit.html",
    "href": "problem13_16staticsubmit.html",
    "title": "Problem 13.16 - Spherical",
    "section": "",
    "text": "Problem Statement\nA spherical thin-walled pressure vessel is to be constructed of steel with a yield stress of 50 ksi and a wall thickness t = 1/4 in. If the internal diameter of the tank is di = 20 ft, determine the maximum allowable pressure before yielding.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 13",
      "Problem 13.16 - Spherical"
    ]
  },
  {
    "objectID": "problem14_1staticsubmit.html",
    "href": "problem14_1staticsubmit.html",
    "title": "Problem 14.1 - Eccentric Axial Loads",
    "section": "",
    "text": "Problem Statement\nA large column supports a cantilevered load W = 8 kips as shown. Dimensions b = 2 ft, h = 4 ft, L1 = 10 ft, and L2 = 10 ft. What is the magnitude of the compressive stress at point A? Assume the cantilevered beam does not fail or bend.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 14",
      "Problem 14.1 - Eccentric Axial Loads"
    ]
  },
  {
    "objectID": "problem14_2staticsubmit.html",
    "href": "problem14_2staticsubmit.html",
    "title": "Problem 14.2 - Eccentric Axial Loads",
    "section": "",
    "text": "Problem Statement\nA metal electric pole supporting a load F = 50 kN was knocked at an angle during a recent storm. If dimensions x = 2000 mm, y = 1000 mm, and L = 8 m, determine the magnitude of the maximum normal stress at the base.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 14",
      "Problem 14.2 - Eccentric Axial Loads"
    ]
  },
  {
    "objectID": "problem14_9staticsubmit.html",
    "href": "problem14_9staticsubmit.html",
    "title": "Problem 14.9 - General Combined Loads",
    "section": "",
    "text": "Problem Statement\nA solid circular rod of length L = 6 m and radius r = 35 mm is subjected to axial load F = 17.5 kN and torsional moment T = 17.5 kN-m. Determine the absolute maximum shear stress (for any coordinate direction) at any location in the bar.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 14",
      "Problem 14.9 - General Combined Loads"
    ]
  },
  {
    "objectID": "problem14_10staticsubmit.html",
    "href": "problem14_10staticsubmit.html",
    "title": "Problem 14.10 - General Combined Loads",
    "section": "",
    "text": "Problem Statement\nA solid circular rod of length L = 2 ft and radius r = 2 in. is subjected to load F = 0.5 kips and torsional moment T = 12 kip-in. Determine the maximum principal stress at point A.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 14",
      "Problem 14.10 - General Combined Loads"
    ]
  },
  {
    "objectID": "problem14_11staticsubmit.html",
    "href": "problem14_11staticsubmit.html",
    "title": "Problem 14.11 - General Combined Loads",
    "section": "",
    "text": "Problem Statement\nA solid circular rod of length L = 1.2 m and radius r = 50 mm is subjected to load F = 1 kN and torsional moment T = 0.5 kN-m. Determine the absolute maximum normal stress at point A.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 14",
      "Problem 14.11 - General Combined Loads"
    ]
  },
  {
    "objectID": "problem15_1staticsubmit.html",
    "href": "problem15_1staticsubmit.html",
    "title": "Problem 15.1 - Buckling & Yield - Euler’s Formula",
    "section": "",
    "text": "Problem Statement\nA steel (E = 200 GPa) tube column with a yield strength of 250 MPa is pinned at both ends. If length L = 6 m, outer radius ro = 75 mm and inner radius ri = 70 mm, determine the maximum allowable load the column can support.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 15",
      "Problem 15.1 - Buckling & Yield - Euler's Formula"
    ]
  },
  {
    "objectID": "problem15_2staticsubmit.html",
    "href": "problem15_2staticsubmit.html",
    "title": "Problem 15.2 - Buckling & Yield - Euler’s Formula",
    "section": "",
    "text": "Problem Statement\nA W14 x 34 beam is used as a column that is pinned at both ends. If length L = 30 ft and the elastic modulus E = 280 x 106 psi, determine the critical stress for the column.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 15",
      "Problem 15.2 - Buckling & Yield - Euler's Formula"
    ]
  },
  {
    "objectID": "problem15_3staticsubmit.html",
    "href": "problem15_3staticsubmit.html",
    "title": "Problem 15.3 - Buckling & Yield - Euler’s Formula",
    "section": "",
    "text": "Problem Statement\nA column is pinned at both ends and supports a load F = 500 kN. Determine the maximum allowable column length, L. Use a factor of safety of 2 and assume the elastic modulus E = 200 GPa.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 15",
      "Problem 15.3 - Buckling & Yield - Euler's Formula"
    ]
  },
  {
    "objectID": "problem15_11staticsubmit.html",
    "href": "problem15_11staticsubmit.html",
    "title": "Problem 15.11 - Effect of Supports",
    "section": "",
    "text": "Problem Statement\nA column with a square cross-section is used to support a force F = 5 kips. The column is fixed at its base and free at the other end. If length L = 18 ft and elastic modulus E = 29,000 ksi, determine the minimum dimension, h, so that the column will not buckle.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 15",
      "Problem 15.11 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem15_12staticsubmit.html",
    "href": "problem15_12staticsubmit.html",
    "title": "Problem 15.12 - Effect of Supports",
    "section": "",
    "text": "Problem Statement\nA W16 x 40 beam is used as a column with a length L = 20 ft. It is fixed at both ends and subjected to load F = 300 kips. If the elastic modulus E = 29,000 ksi, determine the factor of safety with respect to buckling.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 15",
      "Problem 15.12 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem15_13staticsubmit.html",
    "href": "problem15_13staticsubmit.html",
    "title": "Problem 15.13 - Effect of Supports",
    "section": "",
    "text": "Problem Statement\nA W8 x 15 beam (Ix = 48.0 in.4, Iy = 3.41 in.4) is used as a column with one end fixed and the other end pinned. If the length of the column L = 25 ft, determine the largest load it can carry with a factor of safety of 2. The elastic modulus E = 10,000 ksi.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 15",
      "Problem 15.13 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem15_14staticsubmit.html",
    "href": "problem15_14staticsubmit.html",
    "title": "Problem 15.14 - Effect of Supports",
    "section": "",
    "text": "Problem Statement\nA wide-flange column that is fixed at both ends is required to carry a load F = 500 kips. If length L = 30 ft and the elastic modulus E = 29,000 ksi, determine the lightest structural member in Appendix A that can be used. Use a factor of safety of 2 against buckling.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 15",
      "Problem 15.14 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem15_15staticsubmit.html",
    "href": "problem15_15staticsubmit.html",
    "title": "Problem 15.15 - Effect of Supports",
    "section": "",
    "text": "Problem Statement\nTo draw attention, a junkyard owner mounts a car on top of a column of length L = 30 ft made from a W8 x 15 beam (Ix = 48.0 in.4, Iy = 3.41 in.4). If the elastic modulus E = 29,000 ksi, what is the heaviest car body that can be used to avoid buckling? Use a factor of safety of 2.25.\n[Problem adapted from © Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 15",
      "Problem 15.15 - Effect of Supports"
    ]
  }
]