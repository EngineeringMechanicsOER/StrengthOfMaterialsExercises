[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Strength of Materials Problem Exercises",
    "section": "",
    "text": "Welcome to Demo Site\nWelcome to this demonstration site of the Strength of Materials Open Problem Exercises companion to the Strength of Materials Open Textbook.\nAt this time, we are simply using this site as a demonstration and shell for our ongoing work. The intent is to demonstrate a more traditional static style problem exercise pack along with dynamic versions which allow students to quickly check answers and receive basic feedback, and/or to input their math in an interactive interface which will provide them with targeted feedback based on their atempted solution.\nThis work is still very much in progress and you may find bugs. We would welcome any input or feedback you have about this. Thanks!",
    "crumbs": [
      "Welcome to Demo Site"
    ]
  },
  {
    "objectID": "problem2_1dynamicsubmit.html",
    "href": "problem2_1dynamicsubmit.html",
    "title": "Problem 2.1",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.1"
    ]
  },
  {
    "objectID": "problem2_1dynamicsubmit.html#problem-image",
    "href": "problem2_1dynamicsubmit.html#problem-image",
    "title": "Problem 2.1",
    "section": "",
    "text": "Figure 1: A series of solid circular bars are loaded with three loads\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"138\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\nd1=8\nd2=6\nd3=10\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n    \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A series of solid circular bars are loaded with three loads as shown, F&lt;sub&gt;1&lt;/sub&gt; = {F1()} N, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} N, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} N. What is the largest absolute normal stress in any bar?\")]\n     \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(50, 70, 1))\n        F2.set(random.randrange(10, 30, 1))\n        F3.set(F1()-F2())\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        \n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        instr= (F1()/(math.pi*(d2/(1000*2))**2))/10**6\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.1"
    ]
  },
  {
    "objectID": "problem2_2dynamicsubmit.html",
    "href": "problem2_2dynamicsubmit.html",
    "title": "Problem 2.2",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.2"
    ]
  },
  {
    "objectID": "problem2_2dynamicsubmit.html#problem-image",
    "href": "problem2_2dynamicsubmit.html#problem-image",
    "title": "Problem 2.2",
    "section": "",
    "text": "Figure 1: Two sylinders are stacked on top of each other.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"139\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nFA=reactive.Value(\"__\")\nFB=reactive.Value(\"__\")\nE = 30*10**6\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two cylinders are stacked on top of one another and two forces are applied at the top surface and at the joint between the cylinders as shown. If L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in., L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in., F&lt;sub&gt;A&lt;/sub&gt; = {FA()} lb, and F&lt;sub&gt;B&lt;/sub&gt; = {FB()} lb, find the total deflection in the stack of cylinders. Assume E = 30 x 10&lt;sup&gt;6&lt;/sup&gt; psi for both cylinders. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        FA.set(random.randrange(300, 700, 10))\n        FB.set(random.randrange(100, 300, 10))\n        L1.set(random.randrange(2, 7, 1))\n        L2.set(L1() * 1.3)\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        instr= (FA()*L1())/((math.pi*(5/2)**2)*E) + (FB()*L2())/((math.pi*(3/2)**2)*E)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.2"
    ]
  },
  {
    "objectID": "problem2_3dynamicsubmit.html",
    "href": "problem2_3dynamicsubmit.html",
    "title": "Problem 2.3",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.3"
    ]
  },
  {
    "objectID": "problem2_3dynamicsubmit.html#problem-image",
    "href": "problem2_3dynamicsubmit.html#problem-image",
    "title": "Problem 2.3",
    "section": "",
    "text": "Figure 1: A plastic cylindrical peg is constrained by a metal cap\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"144\"\nF=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A plastic cylindrical peg is constrained by a metal cap as shown. An axial load of F = {F()} lb is applied to the peg. If d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in and d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in, determine the largest normal stress in the peg. Assume the axial load is evenly distributed across the peg and that the metal cap is fixed and does not move.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(20, 80, 5))\n        d1.set(random.randrange(3, 8, 1)/10)\n        d2.set(round(d1() * 1.6, 2))\n        \n \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= F()/(math.pi*((d1()/2)**2))\n        #check=math.isclose(float(input.answer()),instr,rel_tol=0.001)\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.3"
    ]
  },
  {
    "objectID": "problem2_4dynamicsubmit.html",
    "href": "problem2_4dynamicsubmit.html",
    "title": "Problem 2.4",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.4"
    ]
  },
  {
    "objectID": "problem2_4dynamicsubmit.html#problem-image",
    "href": "problem2_4dynamicsubmit.html#problem-image",
    "title": "Problem 2.4",
    "section": "",
    "text": "Figure 1: A crate is suspended by a set of cables\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"146\"\nW=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nangle1=math.radians(45)\nangle2=math.radians(30)\nangle3=math.radians(75)\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of GPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A crate weighing {W()} kN is suspended by a set of cables. The diameter of each cable is {d()}  mm. What is the maximum stress in any cable, exluding the cable attached to the crate.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W.set(random.randrange(30, 90, 1))\n        d.set(random.randrange(20, 90, 1)/10)\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        R1 = W()/(((math.cos(angle1)/math.cos(angle2))*math.sin(angle2))+math.sin(angle1))\n        instr= (R1*10**3/(math.pi*((d()/(1000*2))**2)))/10**9\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.4"
    ]
  },
  {
    "objectID": "problem2_47dynamicsubmit.html",
    "href": "problem2_47dynamicsubmit.html",
    "title": "Problem 2.47",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.47"
    ]
  },
  {
    "objectID": "problem2_47dynamicsubmit.html#problem-image",
    "href": "problem2_47dynamicsubmit.html#problem-image",
    "title": "Problem 2.47",
    "section": "",
    "text": "Figure 1: Two slanted brackets are glued together\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"153\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nΘ=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two slanted brackets are glued together as shown. If F = {F()} lb, L = {L()} in., and Θ = {Θ()} °, determine the shear stress parallel to the inclined plane. Assume loads are inline and there is no rotation.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(200, 800, 10))\n        L.set(random.randrange(20, 80, 1)/10)\n        Θ.set(random.randrange(15, 30, 1))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        instr= (F()*math.sin(math.radians(Θ()))/(L()*2))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.47"
    ]
  },
  {
    "objectID": "problem2_48dynamicsubmit.html",
    "href": "problem2_48dynamicsubmit.html",
    "title": "Problem 2.48",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.48"
    ]
  },
  {
    "objectID": "problem2_48dynamicsubmit.html#problem-image",
    "href": "problem2_48dynamicsubmit.html#problem-image",
    "title": "Problem 2.48",
    "section": "",
    "text": "Figure 1: A 2 inch thick board is cut and then glued back together along a line\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"156\"\nF=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nΘ=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A 2 inch thick board is cut and then glued back together along a line that is Θ = {Θ()} ° off the vertical as shown. If height h = {h()} in. and F = {F()} lb, determine the normal stress along the cut line.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(2000, 6000, 100))\n        h.set(random.randrange(50, 150, 1)/10)\n        Θ.set(random.randrange(10, 20, 1))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        \n        instr= (F()/(2*h()))*(math.cos(math.radians(Θ()))**2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.48"
    ]
  },
  {
    "objectID": "problem4_35dynamicsubmit.html",
    "href": "problem4_35dynamicsubmit.html",
    "title": "Problem 4.37",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Complete Problems",
      "Problem 4.37"
    ]
  },
  {
    "objectID": "problem4_35dynamicsubmit.html#problem-image",
    "href": "problem4_35dynamicsubmit.html#problem-image",
    "title": "Problem 4.37",
    "section": "",
    "text": "Figure 1: A small truss is constructed with solid square wood members\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"157\"\nF=reactive.Value(\"__\")\nFS=reactive.Value(\"__\")\nσfail=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of centimeters\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A small truss is constructed with solid square wood members and subjected to a load of F = {F()} kN. Determine the minimum dimension, a, of the member so that the truss will have a factor of safety of {FS()}. All members have the same cross-section. The wood has a failure stress of σ&lt;sub&gt;fail&lt;/sub&gt; = {σfail()} MPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(15, 50, 1))\n        FS.set(random.randrange(15, 40, 1)/10)\n        σfail.set(random.randrange(40, 60, 1))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        dl = FS()*F()\n        A = (dl/(σfail()*10**3))*100*100\n        instr= math.sqrt(A)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Complete Problems",
      "Problem 4.37"
    ]
  },
  {
    "objectID": "problem2_21dynamicsubmit.html",
    "href": "problem2_21dynamicsubmit.html",
    "title": "Problem 2.21",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.21"
    ]
  },
  {
    "objectID": "problem2_21dynamicsubmit.html#problem-image",
    "href": "problem2_21dynamicsubmit.html#problem-image",
    "title": "Problem 2.21",
    "section": "",
    "text": "Figure 1: A double lap joint is glued together\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"164\"\nτfail=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kips\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A double lap joint is glued together using glue with a shear stress failure strength of {τfail()} psi. If dimensions L = {L()} in. and t = {t()} in., what is the maximum load P that the joint can withstand? Assume the load is evenly distributed across the joint on both sides.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        τfail.set(random.randrange(7000, 9000, 100))\n        L.set(random.randrange(40, 100, 1)/10)\n        t.set(random.randrange(40, 100, 1)/10)\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        A = L()*t()*2\n        instr= (τfail()*A)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.21"
    ]
  },
  {
    "objectID": "problem2_22dynamicsubmit.html",
    "href": "problem2_22dynamicsubmit.html",
    "title": "Problem 2.22",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.22"
    ]
  },
  {
    "objectID": "problem2_22dynamicsubmit.html#problem-image",
    "href": "problem2_22dynamicsubmit.html#problem-image",
    "title": "Problem 2.22",
    "section": "",
    "text": "Figure 1: A bracket is attached to a wall with two circular rivets\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"165\"\nF=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A bracket is attached to a wall with two circular rivets of diameter d = {d()} mm. A load F = {F()} kN is applied in the center of the bracket. Assuming the load is split evenly between the two rivits, determine the shear stress in each rivet. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(30, 100, 1))\n        d.set(random.randrange(10, 40, 1))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.  \n      \n        A = math.pi*(d()/(1000*2))**2\n        instr= ((F()/2)/A)/1000\n        if math.isclose(float(input.answer()), instr, abs_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.22"
    ]
  },
  {
    "objectID": "problem2_38dynamicsubmit.html",
    "href": "problem2_38dynamicsubmit.html",
    "title": "Problem 2.38",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.38"
    ]
  },
  {
    "objectID": "problem2_38dynamicsubmit.html#problem-image",
    "href": "problem2_38dynamicsubmit.html#problem-image",
    "title": "Problem 2.38",
    "section": "",
    "text": "Figure 1: A crate is hanged on a circular solid metal rod.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"166\"\nW=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n    \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A crate of weight {W()} = lb hangs from a solid circular metal rod of diameter {d1()} = in.. The cable is wrapped around a support collar of diameter {d2()} = in. and thickness {t()} = in. to evenly distribute the cable load. What is the bearing stress on the support collar due to the rod? \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W.set(random.randrange(4000, 9000, 100))\n        d1.set(random.randrange(5, 30, 1)/10)\n        d2.set(d1()*3)\n        t.set(d1()*2)\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        \n        instr= W()/(d1()*t()*1000)\n        \n        if math.isclose(float(input.answer()), instr, abs_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Complete Problems",
      "Problem 2.38"
    ]
  },
  {
    "objectID": "problem2_1staticsubmit.html",
    "href": "problem2_1staticsubmit.html",
    "title": "Problem 2.1",
    "section": "",
    "text": "Problem Statement\nA series of solid circular bars are loaded with three loads as shown, F1 = 60 N, F2 = 20 N, and F3 = 40 N. What is the largest absolute normal stress in any bar?",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.1"
    ]
  },
  {
    "objectID": "problem2_1staticsubmit.html#problem-image",
    "href": "problem2_1staticsubmit.html#problem-image",
    "title": "Problem 2.1",
    "section": "Problem Image",
    "text": "Problem Image\n\n\n\nFigure 1: A series of solid circular bars are loaded with three loads",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.1"
    ]
  },
  {
    "objectID": "problem2_2staticsubmit.html",
    "href": "problem2_2staticsubmit.html",
    "title": "Problem 2.2",
    "section": "",
    "text": "Problem Statement\nTwo cylinders are stacked on top of one another and two forces are applied at the top surface and at the joint between the cylinders as shown. If L1 = 3 in., L2 = 4 in., FA = 500 lb, and FB = 200 lb, find the total deflection in the stack of cylinders. Assume E = 30 x 106 psi for both cylinders.",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.2"
    ]
  },
  {
    "objectID": "problem2_2staticsubmit.html#problem-image",
    "href": "problem2_2staticsubmit.html#problem-image",
    "title": "Problem 2.2",
    "section": "Problem Image",
    "text": "Problem Image\n\n\n\nFigure 1: Two sylinders are stacked on top of each other.",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.2"
    ]
  },
  {
    "objectID": "problem2_3staticsubmit.html",
    "href": "problem2_3staticsubmit.html",
    "title": "Problem 2.3",
    "section": "",
    "text": "Problem Statement\nA plastic cylindrical peg is constrained by a metal cap as shown. An axial load of F = 40 lb is applied to the peg. If d1 = 0.5 in and d2 = 0.9 in, determine the normal stress in the peg. Assume the axial load is evenly distributed across the peg and that the metal cap is fixed and does not move.",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.3"
    ]
  },
  {
    "objectID": "problem2_3staticsubmit.html#problem-image",
    "href": "problem2_3staticsubmit.html#problem-image",
    "title": "Problem 2.3",
    "section": "Problem Image",
    "text": "Problem Image\n\n\n\nFigure 1: A plastic cylindrical peg is constrained by a metal cap",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.3"
    ]
  },
  {
    "objectID": "problem2_4staticsubmit.html",
    "href": "problem2_4staticsubmit.html",
    "title": "Problem 2.4",
    "section": "",
    "text": "Problem Statement\nA crate weighing 45 kN is suspended by a set of cables. The diameter of each cable is 5 mm. What is the maximum stress in any cable, exluding the cable attached to the crate.",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.4"
    ]
  },
  {
    "objectID": "problem2_4staticsubmit.html#problem-image",
    "href": "problem2_4staticsubmit.html#problem-image",
    "title": "Problem 2.4",
    "section": "Problem Image",
    "text": "Problem Image\n\n\n\nFigure 1: A crate is suspended by a set of cables",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.4"
    ]
  },
  {
    "objectID": "problem2_47staticsubmit.html",
    "href": "problem2_47staticsubmit.html",
    "title": "Problem 2.47",
    "section": "",
    "text": "Problem Statement\nTwo slanted brackets are glued together as shown. If F = 500 lb, L = 4 in., and Θ = 20 °, determine the shear stress parallel to the inclined plane. Assume loads are inline and there is no rotation.",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.47"
    ]
  },
  {
    "objectID": "problem2_47staticsubmit.html#problem-image",
    "href": "problem2_47staticsubmit.html#problem-image",
    "title": "Problem 2.47",
    "section": "Problem Image",
    "text": "Problem Image\n\n\n\nFigure 1: Two slanted brackets are glued together",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.47"
    ]
  },
  {
    "objectID": "problem2_48staticsubmit.html",
    "href": "problem2_48staticsubmit.html",
    "title": "Problem 2.48",
    "section": "",
    "text": "Problem Statement\nA 2 inch thick board is cut and then glued back together along a line that is Θ = 15° off the vertical as shown. If height h = 10 in. and F = 3500 lb, determine the normal stress along the cut line.",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.48"
    ]
  },
  {
    "objectID": "problem2_48staticsubmit.html#problem-image",
    "href": "problem2_48staticsubmit.html#problem-image",
    "title": "Problem 2.48",
    "section": "Problem Image",
    "text": "Problem Image\n\n\n\nFigure 1: A 2 inch thick board is cut and then glued back together along a line",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.48"
    ]
  },
  {
    "objectID": "problem4_35staticsubmit.html",
    "href": "problem4_35staticsubmit.html",
    "title": "Problem 4.37",
    "section": "",
    "text": "Problem Statement\nA small truss is constructed with solid square wood members and subjected to a load of F = 30 kN. Determine the minimum dimension, a, of the member so that the truss will have a factor of safety of 2. All members have the same cross-section. The wood has a failure stress of σfail = 50 MPa.",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 4.37"
    ]
  },
  {
    "objectID": "problem4_35staticsubmit.html#problem-image",
    "href": "problem4_35staticsubmit.html#problem-image",
    "title": "Problem 4.37",
    "section": "Problem Image",
    "text": "Problem Image\n\n\n\nFigure 1: A small truss is constructed with solid square wood members",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 4.37"
    ]
  },
  {
    "objectID": "problem2_21staticsubmit.html",
    "href": "problem2_21staticsubmit.html",
    "title": "Problem 2.21",
    "section": "",
    "text": "Problem Statement\nA double lap joint is glued together using glue with a shear stress failure strength of 8000 psi. If dimensions L = 6 in. and t = 8 in., what is the maximum load P that the joint can withstand? Assume the load is evenly distributed across the joint on both sides.",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.21"
    ]
  },
  {
    "objectID": "problem2_21staticsubmit.html#problem-image",
    "href": "problem2_21staticsubmit.html#problem-image",
    "title": "Problem 2.21",
    "section": "Problem Image",
    "text": "Problem Image\n\n\n\nFigure 1: A double lap joint is glued together",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.21"
    ]
  },
  {
    "objectID": "problem2_22staticsubmit.html",
    "href": "problem2_22staticsubmit.html",
    "title": "Problem 2.22",
    "section": "",
    "text": "Problem Statement\nA bracket is attached to a wall with two circular rivets of diameter d = 20 mm. A load F = 50 kN is applied in the center of the bracket. Assuming the load is split evenly between the two rivits, determine the shear stress in each rivet.",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.22"
    ]
  },
  {
    "objectID": "problem2_22staticsubmit.html#problem-image",
    "href": "problem2_22staticsubmit.html#problem-image",
    "title": "Problem 2.22",
    "section": "Problem Image",
    "text": "Problem Image\n\n\n\nFigure 1: A bracket is attached to a wall with two circular rivets",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.22"
    ]
  },
  {
    "objectID": "problem2_38staticsubmit.html",
    "href": "problem2_38staticsubmit.html",
    "title": "Problem 2.38",
    "section": "",
    "text": "Problem Statement\nA crate of weight W = 8000 lb hangs from a solid circular metal rod of diameter d1 = 1 in.. The cable is wrapped around a support collar of diameter d2 = 3 in. and thickness t = 2 in. to evenly distribute the cable load. What is the bearing stress on the support collar due to the rod?",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.38"
    ]
  },
  {
    "objectID": "problem2_38staticsubmit.html#problem-image",
    "href": "problem2_38staticsubmit.html#problem-image",
    "title": "Problem 2.38",
    "section": "Problem Image",
    "text": "Problem Image\n\n\n\nFigure 1: A crate is hanged on a circular solid metal rod.",
    "crumbs": [
      "List of Complete Problems - Static Version",
      "Problem 2.38"
    ]
  },
  {
    "objectID": "interfacedemo.html",
    "href": "interfacedemo.html",
    "title": "Interactive Problem Interface",
    "section": "",
    "text": "To scaffold your learning in this example, we have provided a free body diagram for you and a repeat of the problem statement.\nA city planner is installing a new traffic light. Light A weighs 65 lb, while lights B and C weigh 50 lb each. The post at O has a hollow circular cross-section with an outer diameter of 5 inches and a wall thickness of 0.2 inches. Please calculate the magnitude of the maximum combined stress in the post. You may ignore the weight of the post.\n\n\n\nFigure 1: Three traffic light installation with loads\n\n\nPlease work through the problem step by step showing your math in the interactive interface here.\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\n\n\nimport io\nimport numpy as np\nimport asyncio\nfrom datetime import datetime\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom shiny import App, render, ui, reactive, req\nfrom sympy import solve, Eq, Symbol\nfrom sympy.parsing.sympy_parser import parse_expr\nfrom shiny.ui import h4\n\n# load equations lists\n\n\nclass eqn:\n    def __init__(self, name, inline_math, newline_math, working_sym, working_eqn_latex,working_eqn_solver):\n        self.name = name\n        self.inline_math = inline_math\n        self.newline_math = newline_math\n        self.working_sym = working_sym\n        self.working_eqn_latex = working_eqn_latex\n        self.working_eqn_solver = working_eqn_solver\n\nStaticsSumFx = eqn(\n    \"Equilibrium Forces in X\", \n    \"\\(\\Sigma F_x=0\\)\", \n    \"$$\\Sigma F_x=0$$\", \n    \"SigmaFx\",\n    \"$$F_x1+F_x2+F_x3+F_x4+F_x5=0$$\",\n    \"F_x1+F_x2+F_x3+F_x4+F_x5=0\"\n)\n\nStaticsSumFy = eqn(\n    \"Equilibrium Forces in Y\", \n    \"\\(\\Sigma F_y=0\\)\", \n    \"$$\\Sigma F_y=0$$\", \n    \"SigmaFy\",\n    \"$$F_y1+F_y2+F_y3+F_y4+F_y5=0$$\",\n    \"F_y1+F_y2+F_y3+F_y4+F_y5=0\"\n)\n\nStaticsSumM = eqn(\n    \"Equilibrium Moments about O\", \n    \"\\(\\Sigma M_O=0\\)\", \n    \"$$\\Sigma M_O=0$$\", \n    \"SigmaM\",\n    \"$$M_1+M_2+M_3+M_4+M_5=0$$\",\n    \"M_1+M_2+M_3+M_4+M_5=0\"\n)\n\nStressEqn = eqn(\n    \"Stress Equation\", \n    \"\\(\\sigma=\\\\frac{F}{A}\\)\", \n    \"$$\\sigma=\\\\frac{F}{A}$$\", \n    \"sigma,F,A\",\n    \"$$\\sigma=\\\\frac{(F)}{(A)}$$\",\n    \"Eq(sigma,(F)/(A))\"\n)\n\nAxialDeform = eqn(\n    \"Axial Deformation by Force\",\n    \"\\(\\delta_l=\\\\frac{P L}{AE}\\)\",\n    \"$$\\delta_l=\\\\frac{P\\cdot L}{A \\cdot E}$$\",\n    \"delta_l,P,L,A,E\",\n    \"$$\\delta_l=\\\\frac{(P)(L)}{(A)(E)}$$\",\n    \"Eq(delta_l,(P)*(L)/(A)/(E))\"\n)\n\nThermalDeform = eqn(\n    \"Axial Deformation by Thermal\",\n    \"\\(\\delta_t= \\\\alpha \\Delta T L\\)\",\n    \"$$\\delta_t= \\\\alpha \\cdot \\Delta T \\cdot L$$\",\n    \"delta_t,alpha,DeltaT,L\",\n    \"$$\\delta_t= \\\\alpha \\Delta T L$$\",\n    \"delta_t= alpha*(Delta_T)*L\"\n)\n\nAreaTube = eqn(\n    \"Area of a Tube\", \n    \"\\(A_{tube}=\\pi(r_o^2-r_i^2)\\)\", \n    \"$$A_{tube}=\\pi(r_o^2-r_i^2)$$\", \n    \"A_tube,r_o,r_i\",\n    \"$$A_{tube}=\\pi(r_o^2-r_i^2)$$\",\n    \"Eq(A_tube,pi*((r_o)**2-(r_i)**2))\"\n)\n\nITube = eqn(\n    \"Moment of Inertia of a Tube\",\n    \"\\(I_{tube}=\\\\frac{\\pi}{4}(r_o^4-r_i^4)\\)\",\n    \"$$I_{tube}=\\\\frac{\\pi}{4}(r_o^4-r_i^4)$$\",\n    \"I_tube,r_o,r_i\",\n    \"$$I_{tube}=\\\\frac{\\pi}{4}(r_o^4-r_i^4)$$\", \n    \"Eq(I_tube,pi/4*((r_o)**4-(r_i)**4))\" \n)\n\nBendingStress = eqn(\n    \"Bending Stress from a Moment\",\n    \"\\(\\sigma_b=\\\\frac{M*y}{I}\\)\",\n    \"$$\\sigma_b=\\\\frac{M*y}{I}$$\",\n    \"sigma_b,M,y,I,\",\n    \"$$\\sigma_b=\\\\frac{M*y}{I}$$\", \n    \"Eq(sigma_b,M*y/I))\" \n)\n\nCompatability1 = eqn(\n    \"Compatability Equation 1\",\n    \"\\(a_1+\\ldots=b_1+b_2+\\ldots\\)\", \n    \"$$a_1+\\ldots=b_1+b_2+\\ldots$$\", \n    \"\",\n    \"$$a_1+a_n=b_1+b_n$$\",\n    \"Eq(a_1+a_n=b_1+b_n)\" \n)\n\nCompatability2 = eqn(\n    \"Compatability Equation 2\",\n    \"\\(c_1+\\ldots=d_1+d_2+\\ldots\\)\", \n    \"$$c_1+\\ldots=d_1+d_2+\\ldots$$\", \n    \"\",\n    \"$$c_1+c_n=d_1+d_n$$\",\n    \"Eq(c_1+c_n=d_1+d_n)\" \n)\n\n\nstatics_eqnbank_inline = {\n    StaticsSumFx.name: StaticsSumFx.inline_math,\n    StaticsSumFy.name: StaticsSumFy.inline_math,\n    StaticsSumM.name: StaticsSumM.inline_math,\n}\ndeforms_eqnbank_inline = {\n    StressEqn.name: StressEqn.inline_math,\n    AxialDeform.name: AxialDeform.inline_math,\n    ThermalDeform.name: ThermalDeform.inline_math,\n}\n\ngeom_eqnbank_inline = {\n    AreaTube.name: AreaTube.inline_math,\n    ITube.name: ITube.inline_math,\n}\n\neqnbank_inline = {\n    StaticsSumFx.name: StaticsSumFx.inline_math,\n    StaticsSumFy.name: StaticsSumFy.inline_math,\n    StaticsSumM.name: StaticsSumM.inline_math,\n    StressEqn.name: StressEqn.inline_math,\n    BendingStress.name: BendingStress.inline_math,\n    AxialDeform.name: AxialDeform.inline_math,\n    ThermalDeform.name: ThermalDeform.inline_math,\n    AreaTube.name: AreaTube.inline_math,\n    ITube.name: ITube.inline_math,\n    Compatability1.name: Compatability1.inline_math,\n    Compatability2.name: Compatability2.inline_math,\n}\n\neqnbank_newline = {\n    StaticsSumFx.name: StaticsSumFx.newline_math,\n    StaticsSumFy.name: StaticsSumFy.newline_math,\n    StaticsSumM.name: StaticsSumM.newline_math,\n    StressEqn.name: StressEqn.newline_math,\n    BendingStress.name: BendingStress.newline_math,\n    AxialDeform.name: AxialDeform.newline_math,\n    ThermalDeform.name: ThermalDeform.newline_math,\n    AreaTube.name: AreaTube.newline_math,\n    ITube.name: ITube.newline_math,\n    Compatability1.name: Compatability1.newline_math,\n    Compatability2.name: Compatability2.newline_math,\n}\n\n\n\nworking_equations_solver=reactive.Value([])\nworking_equations_latex_render=reactive.Value([])\nworking_symbols=reactive.Value([])\n\nfeedback_equations=reactive.Value([])\nfeedback_solns=reactive.Value([])\nfeedback_syms=reactive.Value([])\n\nworking_SumFx_render=reactive.Value(\"\")\nworking_SumFy_render=reactive.Value(\"\")\nworking_SumM_render=reactive.Value(\"\")\nworking_StressEqn_render=reactive.Value(\"\")\nworking_BendingStress_render=reactive.Value(\"\")\nworking_AxialDeform_render=reactive.Value(\"\")\nworking_ThermalDeform_render=reactive.Value(\"\")\nworking_AreaTube_render=reactive.Value(\"\")\nworking_Itube_render=reactive.Value(\"\")\nworking_Compatability1_render=reactive.Value(\"\")\nworking_Compatability2_render=reactive.Value(\"\")\n\nworking_SumFx_string=reactive.Value(\"\")\nworking_SumFy_string=reactive.Value(\"\")\nworking_SumM_string=reactive.Value(\"\")\nworking_StressEqn_string=reactive.Value(\"\")\nworking_BendingStress_string=reactive.Value(\"\")\nworking_AxialDeform_string=reactive.Value(\"\")\nworking_ThermalDeform_string=reactive.Value(\"\")\nworking_AreaTube_string=reactive.Value(\"\")\nworking_Itube_string=reactive.Value(\"\")\nworking_Compatability1_string=reactive.Value(\"\")\nworking_Compatability2_string=reactive.Value(\"\")\n\nNumForcesY=reactive.Value(2)\nF1y=reactive.Value(\"\")\nF2y=reactive.Value(\"\")\nF3y=reactive.Value(\"\")\nF4y=reactive.Value(\"\")\nF5y=reactive.Value(\"\")\nEquil_latex=reactive.Value(\"\")\n\nNumForcesX=reactive.Value(2)\nF1x=reactive.Value(\"\")\nF2x=reactive.Value(\"\")\nF3x=reactive.Value(\"\")\nF4x=reactive.Value(\"\")\nF5x=reactive.Value(\"\")\n\nNumMoments=reactive.Value(2)\nM1=reactive.Value(\"\")\nM2=reactive.Value(\"\")\nM3=reactive.Value(\"\")\nM4=reactive.Value(\"\")\nM5=reactive.Value(\"\")\n\naxial_stress_sigma=reactive.Value(\"\")\naxial_stress_force=reactive.Value(\"\")\naxial_stress_area=reactive.Value(\"\")\n\nbending_stress_sigma=reactive.Value(\"\")\nbending_stress_M=reactive.Value(\"\")\nbending_stress_y=reactive.Value(\"\")\nbending_stress_I=reactive.Value(\"\")\n\naxial_delta_l=reactive.Value(\"\")\naxial_P=reactive.Value(\"\")\naxial_L=reactive.Value(\"\")\naxial_A=reactive.Value(\"\")\naxial_E=reactive.Value(\"\")\n\nthermal_delta_t=reactive.Value(\"\")\nthermal_alpha=reactive.Value(\"\")\nthermal_Delta_T=reactive.Value(\"\")\nthermal_L=reactive.Value(\"\")\n\narea_tube_A_tube=reactive.Value(\"\")\narea_tube_Ar_o=reactive.Value(\"\")\narea_tube_Ar_i=reactive.Value(\"\")\n\nI_tube_I_tube=reactive.Value(\"\")\nI_tube_Ir_o=reactive.Value(\"\")\ni_tube_Ir_i=reactive.Value(\"\")\n\nCompatability1_NumLHS=reactive.Value(1)\nCompatability1_NumRHS=reactive.Value(2)\nCompatability1_a_1=reactive.Value(\"\")\nCompatability1_a_2=reactive.Value(\"\")\nCompatability1_a_3=reactive.Value(\"\")\nCompatability1_a_4=reactive.Value(\"\")\nCompatability1_a_5=reactive.Value(\"\")\nCompatability1_b_1=reactive.Value(\"\")\nCompatability1_b_2=reactive.Value(\"\")\nCompatability1_b_3=reactive.Value(\"\")\nCompatability1_b_4=reactive.Value(\"\")\nCompatability1_b_5=reactive.Value(\"\")\n\nCompatability2_NumLHS=reactive.Value(1)\nCompatability2_NumRHS=reactive.Value(2)\nCompatability2_c_1=reactive.Value(\"\")\nCompatability2_c_2=reactive.Value(\"\")\nCompatability2_c_3=reactive.Value(\"\")\nCompatability2_c_4=reactive.Value(\"\")\nCompatability2_c_5=reactive.Value(\"\")\nCompatability2_d_1=reactive.Value(\"\")\nCompatability2_d_2=reactive.Value(\"\")\nCompatability2_d_3=reactive.Value(\"\")\nCompatability2_d_4=reactive.Value(\"\")\nCompatability2_d_5=reactive.Value(\"\")\n\nactive_eqn_tab=reactive.Value(\"Instructions\")\n\nprob_statement=\"To scaffold your learning in this example, we have provided a free body diagram for you and a repeat of the problem statement. A city planner is installing a new traffic light. Light A weighs 65 lb, while lights B and C weigh 50 lb each. The post at O has a hollow circular cross-section with an outer diameter of 5 inches and a wall thickness of 0.2 inches. Please calculate the magnitude of the maximum combined stress in the post. You may ignore the weight of the post.\"\n\napp_ui = ui.page_fluid(\n    ui.head_content(\n        ui.tags.script(\n            src=\"https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"\n        ),\n        ui.tags.script(\n            \"if (window.MathJax) MathJax.Hub.Queue(['Typeset', MathJax.Hub]);\"\n        ),\n    ),\n    ui.panel_title(\"Interactive Problem Solving Environment\"),\n        ui.row(\n            ui.column(6,\n                ui.markdown(\"**Problem Statement**\"),\n                ui.markdown(prob_statement),\n                ),\n            ui.column(6,ui.output_ui(\"dyn_ui_nav\")),\n            ),\n        #ui.row(\n        #    ui.output_ui(\"dyn_ui_nav\"),\n        #    ),\n        ui.row(\n            ui.markdown(\"**Your Equation Workspace**\"),\n            #ui.column(6,ui.output_ui(\"dyn_ui_nav\")),\n            ui.column(4,\n                ui.navset_tab_card(\n                    ui.nav(\"Equation Bank\",\n                        ui.input_checkbox_group(\"selected_eqns\",\"Choose your equations:\",eqnbank_inline,\n                        ),\n                    ),\n                ),\n            ),\n            ui.column(2,ui.output_ui(\"dyn_eqns\"),style='border-right:1px solid;'),\n            ui.column(4,ui.output_ui(\"dyn_working_eqns\"),ui.output_text(\"txt\")),\n        ),\n        ui.row(\n          ui.output_ui(\"ui_equation_bookkeeping\")\n        ),\n        #ui.row(ui.input_action_button(\n        #            \"solveEquations\", \"Solve Equations\", class_=\"btn-success\", width=\"240px\", style='margin-bottom:10px')\n        #      ),\n        ui.output_ui(\"ui_solutions\"),\n)\n\n\ndef server(input, output, session):\n   \n    @output\n    @render.ui\n    def dyn_eqns():\n        eqns_keys = input.selected_eqns()\n        req(eqns_keys)\n        lookup_eqns = [eqnbank_newline[key] for key in eqns_keys]\n        mystring_eqns = \"\".join(lookup_eqns)\n        feedback_equations.set(lookup_eqns)\n\n        return [\n            ui.markdown(mystring_eqns),\n            ui.tags.script(\n                \"if (window.MathJax) MathJax.Hub.Queue(['Typeset', MathJax.Hub]);\"\n            ),\n        ]\n\n    @output\n    @render.ui\n    def dyn_working_eqns():\n        eqns_keys = input.selected_eqns()\n        req(eqns_keys)\n        lookup_eqns = [eqnbank_newline[key] for key in eqns_keys]\n        \n\n        # Dynamic Filling of Force equations \n        if StaticsSumFy.newline_math in lookup_eqns:\n            StaticsSumFy_list = [\"F_y1\",\"F_y2\",\"F_y3\",\"F_y4\",\"F_y5\"]\n            StaticsSumFy_list = StaticsSumFy_list[:input.NumForcesY()]\n            StaticsSumFy.working_sym = \",\".join(StaticsSumFy_list)\n            StaticsSumFy.working_eqn_latex = \"$$\" + \"+\".join(StaticsSumFy_list) + \"=0$$\"\n            StaticsSumFy.working_eqn_solver = \"+\".join(StaticsSumFy_list)\n            \n            if str(input.F1y()) != \"\" : \n                StaticsSumFy.working_eqn_latex = StaticsSumFy.working_eqn_latex.replace(\"F_y1\",str(input.F1y()))\n                StaticsSumFy.working_sym = StaticsSumFy.working_sym.replace(\"F_y1\",str(input.F1y()))\n                StaticsSumFy.working_eqn_solver = StaticsSumFy.working_eqn_solver.replace(\"F_y1\",str(input.F1y()))\n            else:\n                StaticsSumFy.working_eqn_latex = StaticsSumFy.working_eqn_latex.replace(\"F_y1\",\"\\\\boxed{F_{y_1}}\")\n        \n            if str(input.F2y()) != \"\" : \n                StaticsSumFy.working_eqn_latex = StaticsSumFy.working_eqn_latex.replace(\"F_y2\",str(input.F2y()))\n                StaticsSumFy.working_sym = StaticsSumFy.working_sym.replace(\"F_y2\",str(input.F2y()))\n                StaticsSumFy.working_eqn_solver = StaticsSumFy.working_eqn_solver.replace(\"F_y2\",str(input.F2y()))\n            else:\n                StaticsSumFy.working_eqn_latex = StaticsSumFy.working_eqn_latex.replace(\"F_y2\",\"\\\\boxed{F_{y_2}}\")\n        \n            if str(input.F3y()) != \"\" : \n                StaticsSumFy.working_eqn_latex = StaticsSumFy.working_eqn_latex.replace(\"F_y3\",str(input.F3y()))\n                StaticsSumFy.working_sym = StaticsSumFy.working_sym.replace(\"F_y3\",str(input.F3y()))\n                StaticsSumFy.working_eqn_solver = StaticsSumFy.working_eqn_solver.replace(\"F_y3\",str(input.F3y()))\n            else:\n                StaticsSumFy.working_eqn_latex = StaticsSumFy.working_eqn_latex.replace(\"F_y3\",\"\\\\boxed{F_{y_3}}\")\n        \n            if str(input.F4y()) != \"\" : \n                StaticsSumFy.working_eqn_latex = StaticsSumFy.working_eqn_latex.replace(\"F_y4\",str(input.F4y()))\n                StaticsSumFy.working_sym = StaticsSumFy.working_sym.replace(\"F_y4\",str(input.F4y()))\n                StaticsSumFy.working_eqn_solver = StaticsSumFy.working_eqn_solver.replace(\"F_y4\",str(input.F4y()))\n            else:\n                StaticsSumFy.working_eqn_latex = StaticsSumFy.working_eqn_latex.replace(\"F_y4\",\"\\\\boxed{F_{y_4}}\")\n        \n            if str(input.F5y()) != \"\" : \n                StaticsSumFy.working_eqn_latex = StaticsSumFy.working_eqn_latex.replace(\"F_y5\",str(input.F5y()))\n                StaticsSumFy.working_sym = StaticsSumFy.working_sym.replace(\"F_y5\",str(input.F5y()))\n                StaticsSumFy.working_eqn_solver = StaticsSumFy.working_eqn_solver.replace(\"F_y5\",str(input.F5y()))\n            else:\n                StaticsSumFy.working_eqn_latex = StaticsSumFy.working_eqn_latex.replace(\"F_y5\",\"\\\\boxed{F_{y_5}}\")\n      \n  # Dynamic Filling of Force equations \n        if StaticsSumFx.newline_math in lookup_eqns:\n            StaticsSumFx_list = [\"F_x1\",\"F_x2\",\"F_x3\",\"F_x4\",\"F_x5\"]\n            StaticsSumFx_list = StaticsSumFx_list[:input.NumForcesX()]\n            StaticsSumFx.working_sym = \",\".join(StaticsSumFx_list)\n            StaticsSumFx.working_eqn_latex = \"$$\" + \"+\".join(StaticsSumFx_list) + \"=0$$\"\n            StaticsSumFx.working_eqn_solver = \"+\".join(StaticsSumFx_list)\n            \n            if str(input.F1x()) != \"\" : \n                StaticsSumFx.working_eqn_latex = StaticsSumFx.working_eqn_latex.replace(\"F_x1\",str(input.F1x()))\n                StaticsSumFx.working_sym = StaticsSumFx.working_sym.replace(\"F_x1\",str(input.F1x()))\n                StaticsSumFx.working_eqn_solver = StaticsSumFx.working_eqn_solver.replace(\"F_x1\",str(input.F1x()))\n            else:\n                StaticsSumFx.working_eqn_latex = StaticsSumFx.working_eqn_latex.replace(\"F_x1\",\"\\\\boxed{F_{x_1}}\")\n        \n            if str(input.F2x()) != \"\" : \n                StaticsSumFx.working_eqn_latex = StaticsSumFx.working_eqn_latex.replace(\"F_x2\",str(input.F2x()))\n                StaticsSumFx.working_sym = StaticsSumFx.working_sym.replace(\"F_x2\",str(input.F2x()))\n                StaticsSumFx.working_eqn_solver = StaticsSumFx.working_eqn_solver.replace(\"F_x2\",str(input.F2x()))\n            else:\n                StaticsSumFx.working_eqn_latex = StaticsSumFx.working_eqn_latex.replace(\"F_x2\",\"\\\\boxed{F_{x_2}}\")\n        \n            if str(input.F3x()) != \"\" : \n                StaticsSumFx.working_eqn_latex = StaticsSumFx.working_eqn_latex.replace(\"F_x3\",str(input.F3x()))\n                StaticsSumFx.working_sym = StaticsSumFx.working_sym.replace(\"F_x3\",str(input.F3x()))\n                StaticsSumFx.working_eqn_solver = StaticsSumFx.working_eqn_solver.replace(\"F_x3\",str(input.F3x()))\n            else:\n                StaticsSumFx.working_eqn_latex = StaticsSumFx.working_eqn_latex.replace(\"F_x3\",\"\\\\boxed{F_{x_3}}\")\n        \n            if str(input.F4x()) != \"\" : \n                StaticsSumFx.working_eqn_latex = StaticsSumFx.working_eqn_latex.replace(\"F_x4\",str(input.F4x()))\n                StaticsSumFx.working_sym = StaticsSumFx.working_sym.replace(\"F_x4\",str(input.F4x()))\n                StaticsSumFx.working_eqn_solver = StaticsSumFx.working_eqn_solver.replace(\"F_x4\",str(input.F4x()))\n            else:\n                StaticsSumFx.working_eqn_latex = StaticsSumFx.working_eqn_latex.replace(\"F_x4\",\"\\\\boxed{F_{x_4}}\")\n        \n            if str(input.F5x()) != \"\" : \n                StaticsSumFx.working_eqn_latex = StaticsSumFx.working_eqn_latex.replace(\"F_x5\",str(input.F5x()))\n                StaticsSumFx.working_sym = StaticsSumFx.working_sym.replace(\"F_x5\",str(input.F5x()))\n                StaticsSumFx.working_eqn_solver = StaticsSumFx.working_eqn_solver.replace(\"F_x5\",str(input.F5x()))\n            else:\n                StaticsSumFx.working_eqn_latex = StaticsSumFx.working_eqn_latex.replace(\"F_x5\",\"\\\\boxed{F_{x_5}}\")\n                \n                \n        # Dynamic Filling of Moment equations \n        if StaticsSumM.newline_math in lookup_eqns:\n            StaticsSumM_list = [\"M_1\",\"M_2\",\"M_3\",\"M_4\",\"M_5\"]\n            StaticsSumM_list = StaticsSumM_list[:input.NumMoments()]\n            StaticsSumM.working_sym = \",\".join(StaticsSumM_list)\n            StaticsSumM.working_eqn_latex = \"$$\" + \"+\".join(StaticsSumM_list) + \"=0$$\"\n            StaticsSumM.working_eqn_solver = \"+\".join(StaticsSumM_list)\n            \n            if str(input.M1()) != \"\" : \n                StaticsSumM.working_eqn_latex = StaticsSumM.working_eqn_latex.replace(\"M_1\",str(input.M1()))\n                StaticsSumM.working_sym = StaticsSumM.working_sym.replace(\"M_1\",str(input.M1()))\n                StaticsSumM.working_eqn_solver = StaticsSumM.working_eqn_solver.replace(\"M_1\",str(input.M1()))\n            else:\n                StaticsSumM.working_eqn_latex = StaticsSumM.working_eqn_latex.replace(\"M_1\",\"\\\\boxed{M_1}\")\n        \n            if str(input.M2()) != \"\" : \n                StaticsSumM.working_eqn_latex = StaticsSumM.working_eqn_latex.replace(\"M_2\",str(input.M2()))\n                StaticsSumM.working_sym = StaticsSumM.working_sym.replace(\"M_2\",str(input.M2()))\n                StaticsSumM.working_eqn_solver = StaticsSumM.working_eqn_solver.replace(\"M_2\",str(input.M2()))\n            else:\n                StaticsSumM.working_eqn_latex = StaticsSumM.working_eqn_latex.replace(\"M_2\",\"\\\\boxed{M_2}\")\n        \n            if str(input.M3()) != \"\" : \n                StaticsSumM.working_eqn_latex = StaticsSumM.working_eqn_latex.replace(\"M_3\",str(input.M3()))\n                StaticsSumM.working_sym = StaticsSumM.working_sym.replace(\"M_3\",str(input.M3()))\n                StaticsSumM.working_eqn_solver = StaticsSumM.working_eqn_solver.replace(\"M_3\",str(input.M3()))\n            else:\n                StaticsSumM.working_eqn_latex = StaticsSumM.working_eqn_latex.replace(\"M_3\",\"\\\\boxed{M_3}\")\n        \n            if str(input.M4()) != \"\" : \n                StaticsSumM.working_eqn_latex = StaticsSumM.working_eqn_latex.replace(\"M_4\",str(input.M4()))\n                StaticsSumM.working_sym = StaticsSumM.working_sym.replace(\"M_4\",str(input.M4()))\n                StaticsSumM.working_eqn_solver = StaticsSumM.working_eqn_solver.replace(\"M_4\",str(input.M4()))\n            else:\n                StaticsSumM.working_eqn_latex = StaticsSumM.working_eqn_latex.replace(\"M_4\",\"\\\\boxed{M_4}\")\n        \n            if str(input.M5()) != \"\" : \n                StaticsSumM.working_eqn_latex = StaticsSumM.working_eqn_latex.replace(\"M_5\",str(input.M5()))\n                StaticsSumM.working_sym = StaticsSumM.working_sym.replace(\"M_5\",str(input.M5()))\n                StaticsSumM.working_eqn_solver = StaticsSumM.working_eqn_solver.replace(\"M_5\",str(input.M5()))\n            else:\n                StaticsSumM.working_eqn_latex = StaticsSumM.working_eqn_latex.replace(\"M_5\",\"\\\\boxed{M_5}\")\n          \n        \n        # Dynamic Filling of A equations \n        if AreaTube.newline_math in lookup_eqns:\n            AreaTube.working_eqn_latex = AreaTube.newline_math\n            AreaTube.working_eqn_solver = \"Eq(A_tube,pi*((r_o)**2-(r_i)**2))\"\n            AreaTube.working_sym = \"A_tube,r_o,r_i\"\n            \n            if str(input.A_tube()) != \"\" : \n                AreaTube.working_eqn_latex = AreaTube.working_eqn_latex.replace(\"A_{tube}\",str(input.A_tube()))\n                AreaTube.working_sym = AreaTube.working_sym.replace(\"A_tube\",str(input.A_tube()))\n                AreaTube.working_eqn_solver = AreaTube.working_eqn_solver.replace(\"A_tube\",str(input.A_tube()))\n            else:\n                AreaTube.working_eqn_latex = AreaTube.working_eqn_latex.replace(\"A_{tube}\",\"\\\\boxed{A_{tube}}\")\n            if str(input.Ar_o()) != \"\" : \n                AreaTube.working_eqn_latex = AreaTube.working_eqn_latex.replace(\"r_o\",str(input.Ar_o()))\n                AreaTube.working_sym = AreaTube.working_sym.replace(\"r_o\",str(input.Ar_o()))\n                AreaTube.working_eqn_solver = AreaTube.working_eqn_solver.replace(\"r_o\",str(input.Ar_o()))\n            else:\n                AreaTube.working_eqn_latex = AreaTube.working_eqn_latex.replace(\"r_o\",\"\\\\boxed{r_o}\")\n            if str(input.Ar_i()) != \"\" : \n                AreaTube.working_eqn_latex = AreaTube.working_eqn_latex.replace(\"r_i\",str(input.Ar_i()))\n                AreaTube.working_sym = AreaTube.working_sym.replace(\"r_i\",str(input.Ar_i()))\n                AreaTube.working_eqn_solver = AreaTube.working_eqn_solver.replace(\"r_i\",str(input.Ar_i()))\n            else:\n                AreaTube.working_eqn_latex = AreaTube.working_eqn_latex.replace(\"r_i\",\"\\\\boxed{r_i}\")\n        \n        # Dynamic Filling of I equations \n        if ITube.newline_math in lookup_eqns:\n            ITube.working_eqn_latex = ITube.newline_math\n            ITube.working_eqn_solver = \"Eq(I_tube,pi/4*((r_o)**4-(r_i)**4))\"\n            ITube.working_sym = \"I_tube,r_o,r_i\"\n            if str(input.I_tube()) != \"\" : \n                ITube.working_eqn_latex = ITube.working_eqn_latex.replace(\"I_{tube}\",str(input.I_tube()))\n                ITube.working_sym = ITube.working_sym.replace(\"I_tube\",str(input.I_tube()))\n                ITube.working_eqn_solver = ITube.working_eqn_solver.replace(\"I_tube\",str(input.I_tube()))\n            else:\n                ITube.working_eqn_latex = ITube.working_eqn_latex.replace(\"I_{tube}\",\"\\\\boxed{I_{tube}}\")\n            if str(input.Ir_o()) != \"\" : \n                ITube.working_eqn_latex = ITube.working_eqn_latex.replace(\"r_o\",str(input.Ir_o()))\n                ITube.working_sym = ITube.working_sym.replace(\"r_o\",str(input.Ir_o()))\n                ITube.working_eqn_solver = ITube.working_eqn_solver.replace(\"r_o\",str(input.Ir_o()))\n            else:\n                ITube.working_eqn_latex = ITube.working_eqn_latex.replace(\"r_o\",\"\\\\boxed{r_o}\")\n            if str(input.Ir_i()) != \"\" : \n                ITube.working_eqn_latex = ITube.working_eqn_latex.replace(\"r_i\",str(input.Ir_i()))        \n                ITube.working_sym = ITube.working_sym.replace(\"r_i\",str(input.Ir_i()))\n                ITube.working_eqn_solver = ITube.working_eqn_solver.replace(\"r_i\",str(input.Ir_i()))\n            else:\n                ITube.working_eqn_latex = ITube.working_eqn_latex.replace(\"r_i\",\"\\\\boxed{r_i}\")\n            \n        # Dynamic Filling of Stress equation \n        if StressEqn.newline_math in lookup_eqns:\n            StressEqn.working_eqn_latex = StressEqn.newline_math\n            StressEqn.working_eqn_solver = \"Eq(sigma,(F)/(A))\"\n            StressEqn.working_sym = \"sigma,F,A\"\n            if str(input.sigma()) != \"\" : \n                StressEqn.working_eqn_latex = StressEqn.working_eqn_latex.replace(\"\\sigma\",str(input.sigma()))\n                StressEqn.working_eqn_solver = StressEqn.working_eqn_solver.replace(\"sigma\",str(input.sigma()))\n                StressEqn.working_sym = StressEqn.working_sym.replace(\"sigma\",str(input.sigma()))\n            else:\n                StressEqn.working_eqn_latex = StressEqn.working_eqn_latex.replace(\"\\sigma\",\"\\\\boxed\\sigma\")\n            if str(input.force()) != \"\" : \n                StressEqn.working_eqn_latex = StressEqn.working_eqn_latex.replace(\"F\",str(input.force()))\n                StressEqn.working_eqn_solver = StressEqn.working_eqn_solver.replace(\"F\",str(input.force()))\n                StressEqn.working_sym = StressEqn.working_sym.replace(\"F\",str(input.force()))\n            else:\n                StressEqn.working_eqn_latex = StressEqn.working_eqn_latex.replace(\"F\",\"\\\\boxed{F}\")\n            if str(input.area()) != \"\" : \n                StressEqn.working_eqn_latex = StressEqn.working_eqn_latex.replace(\"A\",str(input.area()))\n                StressEqn.working_eqn_solver = StressEqn.working_eqn_solver.replace(\"A\",str(input.area()))\n                StressEqn.working_sym = StressEqn.working_sym.replace(\"A\",str(input.area()))\n            else:\n                StressEqn.working_eqn_latex = StressEqn.working_eqn_latex.replace(\"A\",\"\\\\boxed{A}\")\n           \n\n        # Dynamic Filling of Bending Stress equation \n        if BendingStress.newline_math in lookup_eqns:\n            BendingStress.working_eqn_latex = BendingStress.newline_math\n            BendingStress.working_eqn_solver = \"Eq(sigma_b,M*y/I)\"\n            BendingStress.working_sym = \"sigma_b,M,y,I\"\n            if str(input.bendingstress_sigma_b()) != \"\" : \n                BendingStress.working_eqn_latex = BendingStress.working_eqn_latex.replace(\"\\sigma_b\",str(input.bendingstress_sigma_b()))\n                BendingStress.working_eqn_solver = BendingStress.working_eqn_solver.replace(\"sigma_b\",str(input.bendingstress_sigma_b()))\n                BendingStress.working_sym = BendingStress.working_sym.replace(\"sigma_b\",str(input.bendingstress_sigma_b()))\n            else:\n                BendingStress.working_eqn_latex = BendingStress.working_eqn_latex.replace(\"\\sigma_b\",\"\\\\boxed{\\sigma_b}\")\n            if str(input.bendingstress_M()) != \"\" : \n                BendingStress.working_eqn_latex = BendingStress.working_eqn_latex.replace(\"M\",str(input.bendingstress_M()))\n                BendingStress.working_eqn_solver = BendingStress.working_eqn_solver.replace(\"M\",str(input.bendingstress_M()))\n                BendingStress.working_sym = BendingStress.working_sym.replace(\"M\",str(input.bendingstress_M()))\n            else:\n                BendingStress.working_eqn_latex = BendingStress.working_eqn_latex.replace(\"M\",\"\\\\boxed{M}\")\n            if str(input.bendingstress_y()) != \"\" : \n                BendingStress.working_eqn_latex = BendingStress.working_eqn_latex.replace(\"y\",str(input.bendingstress_y()))\n                BendingStress.working_eqn_solver = BendingStress.working_eqn_solver.replace(\"y\",str(input.bendingstress_y()))\n                BendingStress.working_sym = BendingStress.working_sym.replace(\"y\",str(input.bendingstress_y()))\n            else:\n                BendingStress.working_eqn_latex = BendingStress.working_eqn_latex.replace(\"y\",\"\\\\boxed{y}\")\n            if str(input.bendingstress_I()) != \"\" : \n                BendingStress.working_eqn_latex = BendingStress.working_eqn_latex.replace(\"I\",str(input.bendingstress_I()))\n                BendingStress.working_eqn_solver = BendingStress.working_eqn_solver.replace(\"I\",str(input.bendingstress_I()))\n                BendingStress.working_sym = BendingStress.working_sym.replace(\"I\",str(input.bendingstress_I()))\n            else:\n                BendingStress.working_eqn_latex = BendingStress.working_eqn_latex.replace(\"I\",\"\\\\boxed{I}\")\n            \n                \n        # Dynamic Filling of Axial Deform equation \n        if AxialDeform.newline_math in lookup_eqns:\n            AxialDeform.working_eqn_latex = AxialDeform.newline_math\n            AxialDeform.working_eqn_solver = \"Eq(delta_l,P*L/A/E)\"\n            AxialDeform.working_sym = \"delta_l,P,L,A,E\"\n            if str(input.axial_delta_l()) != \"\" : \n                AxialDeform.working_eqn_latex = AxialDeform.working_eqn_latex.replace(\"\\delta_l\",str(input.axial_delta_l()))\n                AxialDeform.working_eqn_solver = AxialDeform.working_eqn_solver.replace(\"delta_l\",str(input.axial_delta_l()))\n                AxialDeform.working_sym = AxialDeform.working_sym.replace(\"delta_l\",str(input.axial_delta_l()))\n            else:\n                AxialDeform.working_eqn_latex = AxialDeform.working_eqn_latex.replace(\"\\delta_l\",\"\\\\boxed{\\delta_l}\")\n            if str(input.axial_P()) != \"\" : \n                AxialDeform.working_eqn_latex = AxialDeform.working_eqn_latex.replace(\"P\",str(input.axial_P()))\n                AxialDeform.working_eqn_solver = AxialDeform.working_eqn_solver.replace(\"P\",str(input.axial_P()))\n                AxialDeform.working_sym = AxialDeform.working_sym.replace(\"P\",str(input.axial_P()))\n            else:\n                AxialDeform.working_eqn_latex = AxialDeform.working_eqn_latex.replace(\"P\",\"\\\\boxed{P}\")\n            if str(input.axial_L()) != \"\" : \n                AxialDeform.working_eqn_latex = AxialDeform.working_eqn_latex.replace(\"L\",str(input.axial_L()))\n                AxialDeform.working_eqn_solver = AxialDeform.working_eqn_solver.replace(\"L\",str(input.axial_L()))\n                AxialDeform.working_sym = AxialDeform.working_sym.replace(\"L\",str(input.axial_L()))\n            else:\n                AxialDeform.working_eqn_latex = AxialDeform.working_eqn_latex.replace(\"L\",\"\\\\boxed{L}\")\n            if str(input.axial_A()) != \"\" : \n                AxialDeform.working_eqn_latex = AxialDeform.working_eqn_latex.replace(\"A\",str(input.axial_A()))\n                AxialDeform.working_eqn_solver = AxialDeform.working_eqn_solver.replace(\"A\",str(input.axial_A()))\n                AxialDeform.working_sym = AxialDeform.working_sym.replace(\"A\",str(input.axial_A()))\n            else:\n                AxialDeform.working_eqn_latex = AxialDeform.working_eqn_latex.replace(\"A\",\"\\\\boxed{A}\")\n            if str(input.axial_E()) != \"\" : \n                AxialDeform.working_eqn_latex = AxialDeform.working_eqn_latex.replace(\"E\",str(input.axial_E()))\n                AxialDeform.working_eqn_solver = AxialDeform.working_eqn_solver.replace(\"E\",str(input.axial_E()))\n                AxialDeform.working_sym = AxialDeform.working_sym.replace(\"E\",str(input.axial_E()))\n            else:\n                AxialDeform.working_eqn_latex = AxialDeform.working_eqn_latex.replace(\"E\",\"\\\\boxed{E}\")\n            \n        # Dynamic Filling of Thermal Deform equation \n        if ThermalDeform.newline_math in lookup_eqns:\n            ThermalDeform.working_eqn_latex = ThermalDeform.newline_math\n            ThermalDeform.working_eqn_solver = \"Eq(delta_t,alpha*Delta_T*L)\"\n            ThermalDeform.working_sym = \"delta_t,Delta_T,alpha,L\"\n            if str(input.thermal_delta_t()) != \"\" : \n                ThermalDeform.working_eqn_latex = ThermalDeform.working_eqn_latex.replace(\"\\delta_t\",str(input.thermal_delta_t()))\n                ThermalDeform.working_eqn_solver = ThermalDeform.working_eqn_solver.replace(\"delta_t\",str(input.thermal_delta_t()))\n                ThermalDeform.working_sym = ThermalDeform.working_sym.replace(\"delta_t\",str(input.thermal_delta_t()))\n            else:\n                ThermalDeform.working_eqn_latex = ThermalDeform.working_eqn_latex.replace(\"\\delta_t\",\"\\\\boxed{\\delta_t}\")\n            if str(input.thermal_alpha()) != \"\" : \n                ThermalDeform.working_eqn_latex = ThermalDeform.working_eqn_latex.replace(\"\\\\alpha\",str(input.thermal_alpha()))\n                ThermalDeform.working_eqn_solver = ThermalDeform.working_eqn_solver.replace(\"alpha\",str(input.thermal_alpha()))\n                ThermalDeform.working_sym = ThermalDeform.working_sym.replace(\"alpha\",str(input.thermal_alpha()))\n            else:\n                ThermalDeform.working_eqn_latex = ThermalDeform.working_eqn_latex.replace(\"\\\\alpha\",\"\\\\boxed{\\\\alpha}\")\n            if str(input.thermal_Delta_T()) != \"\" : \n                ThermalDeform.working_eqn_latex = ThermalDeform.working_eqn_latex.replace(\"\\Delta T\",str(input.thermal_Delta_T()))\n                ThermalDeform.working_eqn_solver = ThermalDeform.working_eqn_solver.replace(\"Delta_T\",str(input.thermal_Delta_T()))\n                ThermalDeform.working_sym = ThermalDeform.working_sym.replace(\"Delta_T\",str(input.thermal_Delta_T()))\n            else:\n                ThermalDeform.working_eqn_latex = ThermalDeform.working_eqn_latex.replace(\"\\Delta T\",\"\\\\boxed{\\Delta T}\")\n            if str(input.thermal_L()) != \"\" : \n                ThermalDeform.working_eqn_latex = ThermalDeform.working_eqn_latex.replace(\"L\",str(input.thermal_L()))\n                ThermalDeform.working_eqn_solver = ThermalDeform.working_eqn_solver.replace(\"L\",str(input.thermal_L()))\n                ThermalDeform.working_sym = ThermalDeform.working_sym.replace(\"L\",str(input.thermal_L()))\n            else:\n                ThermalDeform.working_eqn_latex = ThermalDeform.working_eqn_latex.replace(\"L\",\"\\\\boxed L\")\n        \n        \n        # Dynamic Filling of Compatability equation 1 \n        if Compatability1.newline_math in lookup_eqns:\n            Compatability1_list__LHS = [\"a_1\",\"a_2\",\"a_3\",\"a_4\",\"a_5\"]\n            Compatability1_list__RHS = [\"b_1\",\"b_2\",\"b_3\",\"b_4\",\"b_5\"]\n            Compatability1_list_LHS = Compatability1_list__LHS[:input.Compatability1_NumLHS()]\n            Compatability1_list_RHS = Compatability1_list__RHS[:input.Compatability1_NumRHS()]\n            Compatability1_list = Compatability1_list_LHS + Compatability1_list_RHS\n            Compatability1.working_sym = \",\".join(Compatability1_list)\n            Compatability1.working_eqn_latex = \"$$\" + \"+\".join(Compatability1_list_LHS) + \"=\" + \"+\".join(Compatability1_list_RHS)+\"$$\"\n            Compatability1.working_eqn_solver = \"Eq(\"+ \"+\".join(Compatability1_list_LHS) + \",\" + \"+\".join(Compatability1_list_RHS)+\")\"\n            \n            if str(input.a_1()) != \"\" : \n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"a_1\",str(input.a_1()))\n                Compatability1.working_sym = Compatability1.working_sym.replace(\"a_1\",str(input.a_1()))\n                Compatability1.working_eqn_solver = Compatability1.working_eqn_solver.replace(\"a_1\",str(input.a_1()))\n            else:\n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"a_1\",\"\\\\boxed{a_1}\")\n            \n            if str(input.a_2()) != \"\" : \n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"a_2\",str(input.a_2()))\n                Compatability1.working_sym = Compatability1.working_sym.replace(\"a_2\",str(input.a_2()))\n                Compatability1.working_eqn_solver = Compatability1.working_eqn_solver.replace(\"a_2\",str(input.a_2()))\n            else:\n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"a_2\",\"\\\\boxed{a_2}\")\n            \n            if str(input.a_3()) != \"\" : \n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"a_3\",str(input.a_3()))\n                Compatability1.working_sym = Compatability1.working_sym.replace(\"a_3\",str(input.a_3()))\n                Compatability1.working_eqn_solver = Compatability1.working_eqn_solver.replace(\"a_3\",str(input.a_3()))\n            else:\n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"a_3\",\"\\\\boxed{a_3}\")\n            \n            if str(input.a_4()) != \"\" : \n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"a_4\",str(input.a_4()))\n                Compatability1.working_sym = Compatability1.working_sym.replace(\"a_4\",str(input.a_4()))\n                Compatability1.working_eqn_solver = Compatability1.working_eqn_solver.replace(\"a_4\",str(input.a_4()))\n            else:\n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"a_4\",\"\\\\boxed{a_4}\")\n            \n            if str(input.a_5()) != \"\" : \n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"a_5\",str(input.a_5()))\n                Compatability1.working_sym = Compatability1.working_sym.replace(\"a_5\",str(input.a_5()))\n                Compatability1.working_eqn_solver = Compatability1.working_eqn_solver.replace(\"a_5\",str(input.a_5()))\n            else:\n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"a_5\",\"\\\\boxed{a_5}\")\n                    \n            if str(input.b_1()) != \"\" : \n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"b_1\",str(input.b_1()))\n                Compatability1.working_sym = Compatability1.working_sym.replace(\"b_1\",str(input.b_1()))\n                Compatability1.working_eqn_solver = Compatability1.working_eqn_solver.replace(\"b_1\",str(input.b_1()))\n            else:\n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"b_1\",\"\\\\boxed{b_1}\")\n            \n            if str(input.b_2()) != \"\" : \n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"b_2\",str(input.b_2()))\n                Compatability1.working_sym = Compatability1.working_sym.replace(\"b_2\",str(input.b_2()))\n                Compatability1.working_eqn_solver = Compatability1.working_eqn_solver.replace(\"b_2\",str(input.b_2()))\n            else:\n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"b_2\",\"\\\\boxed{b_2}\")\n            \n            if str(input.b_3()) != \"\" : \n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"b_3\",str(input.b_3()))\n                Compatability1.working_sym = Compatability1.working_sym.replace(\"b_3\",str(input.b_3()))\n                Compatability1.working_eqn_solver = Compatability1.working_eqn_solver.replace(\"b_3\",str(input.b_3()))\n            else:\n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"b_3\",\"\\\\boxed{b_3}\")\n            \n            if str(input.b_4()) != \"\" : \n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"b_4\",str(input.b_4()))\n                Compatability1.working_sym = Compatability1.working_sym.replace(\"b_4\",str(input.b_4()))\n                Compatability1.working_eqn_solver = Compatability1.working_eqn_solver.replace(\"b_4\",str(input.b_4()))\n            else:\n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"b_4\",\"\\\\boxed{b_4}\")\n            \n            if str(input.b_5()) != \"\" : \n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"b_5\",str(input.b_5()))\n                Compatability1.working_sym = Compatability1.working_sym.replace(\"b_5\",str(input.b_5()))\n                Compatability1.working_eqn_solver = Compatability1.working_eqn_solver.replace(\"b_5\",str(input.b_5()))\n            else:\n                Compatability1.working_eqn_latex = Compatability1.working_eqn_latex.replace(\"b_5\",\"\\\\boxed{b_5}\")\n\n# Dynamic Filling of Compatability equation 2\n        if Compatability2.newline_math in lookup_eqns:\n            Compatability2_list__LHS = [\"c_1\",\"c_2\",\"c_3\",\"c_4\",\"c_5\"]\n            Compatability2_list__RHS = [\"d_1\",\"d_2\",\"d_3\",\"d_4\",\"d_5\"]\n            Compatability2_list_LHS = Compatability2_list__LHS[:input.Compatability2_NumLHS()]\n            Compatability2_list_RHS = Compatability2_list__RHS[:input.Compatability2_NumRHS()]\n            Compatability2_list = Compatability2_list_LHS + Compatability2_list_RHS\n            Compatability2.working_sym = \",\".join(Compatability2_list)\n            Compatability2.working_eqn_latex = \"$$\" + \"+\".join(Compatability2_list_LHS) + \"=\" + \"+\".join(Compatability2_list_RHS)+\"$$\"\n            Compatability2.working_eqn_solver = \"Eq(\"+ \"+\".join(Compatability2_list_LHS) + \",\" + \"+\".join(Compatability2_list_RHS)+\")\"\n            \n            if str(input.c_1()) != \"\" : \n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"c_1\",str(input.c_1()))\n                Compatability2.working_sym = Compatability2.working_sym.replace(\"c_1\",str(input.c_1()))\n                Compatability2.working_eqn_solver = Compatability2.working_eqn_solver.replace(\"c_1\",str(input.c_1()))\n            else:\n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"c_1\",\"\\\\boxed{c_1}\")\n            \n            if str(input.c_2()) != \"\" : \n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"c_2\",str(input.c_2()))\n                Compatability2.working_sym = Compatability2.working_sym.replace(\"c_2\",str(input.c_2()))\n                Compatability2.working_eqn_solver = Compatability2.working_eqn_solver.replace(\"c_2\",str(input.c_2()))\n            else:\n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"c_2\",\"\\\\boxed{c_2}\")\n            \n            if str(input.c_3()) != \"\" : \n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"c_3\",str(input.c_3()))\n                Compatability2.working_sym = Compatability2.working_sym.replace(\"c_3\",str(input.c_3()))\n                Compatability2.working_eqn_solver = Compatability2.working_eqn_solver.replace(\"c_3\",str(input.c_3()))\n            else:\n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"c_3\",\"\\\\boxed{c_3}\")\n            \n            if str(input.c_4()) != \"\" : \n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"c_4\",str(input.c_4()))\n                Compatability2.working_sym = Compatability2.working_sym.replace(\"c_4\",str(input.c_4()))\n                Compatability2.working_eqn_solver = Compatability2.working_eqn_solver.replace(\"c_4\",str(input.c_4()))\n            else:\n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"c_4\",\"\\\\boxed{c_4}\")\n            \n            if str(input.c_5()) != \"\" : \n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"c_5\",str(input.c_5()))\n                Compatability2.working_sym = Compatability2.working_sym.replace(\"c_5\",str(input.c_5()))\n                Compatability2.working_eqn_solver = Compatability2.working_eqn_solver.replace(\"c_5\",str(input.c_5()))\n            else:\n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"c_5\",\"\\\\boxed{c_5}\")\n                    \n            if str(input.d_1()) != \"\" : \n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"d_1\",str(input.d_1()))\n                Compatability2.working_sym = Compatability2.working_sym.replace(\"d_1\",str(input.d_1()))\n                Compatability2.working_eqn_solver = Compatability2.working_eqn_solver.replace(\"d_1\",str(input.d_1()))\n            else:\n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"d_1\",\"\\\\boxed{d_1}\")\n            \n            if str(input.d_2()) != \"\" : \n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"d_2\",str(input.d_2()))\n                Compatability2.working_sym = Compatability2.working_sym.replace(\"d_2\",str(input.d_2()))\n                Compatability2.working_eqn_solver = Compatability2.working_eqn_solver.replace(\"d_2\",str(input.d_2()))\n            else:\n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"d_2\",\"\\\\boxed{d_2}\")\n            \n            if str(input.d_3()) != \"\" : \n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"d_3\",str(input.d_3()))\n                Compatability2.working_sym = Compatability2.working_sym.replace(\"d_3\",str(input.d_3()))\n                Compatability2.working_eqn_solver = Compatability2.working_eqn_solver.replace(\"d_3\",str(input.d_3()))\n            else:\n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"d_3\",\"\\\\boxed{d_3}\")\n            \n            if str(input.d_4()) != \"\" : \n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"d_4\",str(input.d_4()))\n                Compatability2.working_sym = Compatability2.working_sym.replace(\"d_4\",str(input.d_4()))\n                Compatability2.working_eqn_solver = Compatability2.working_eqn_solver.replace(\"d_4\",str(input.d_4()))\n            else:\n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"d_4\",\"\\\\boxed{d_4}\")\n            \n            if str(input.d_5()) != \"\" : \n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"d_5\",str(input.d_5()))\n                Compatability2.working_sym = Compatability2.working_sym.replace(\"d_5\",str(input.d_5()))\n                Compatability2.working_eqn_solver = Compatability2.working_eqn_solver.replace(\"d_5\",str(input.d_5()))\n            else:\n                Compatability2.working_eqn_latex = Compatability2.working_eqn_latex.replace(\"d_5\",\"\\\\boxed{d_5}\")\n                \n                \n        eqnbank_working_latex = {\n        StaticsSumFx.name: StaticsSumFx.working_eqn_latex,\n        StaticsSumFy.name: StaticsSumFy.working_eqn_latex,\n        StaticsSumM.name: StaticsSumM.working_eqn_latex,\n        StressEqn.name: StressEqn.working_eqn_latex,\n        BendingStress.name: BendingStress.working_eqn_latex,\n        AxialDeform.name: AxialDeform.working_eqn_latex,\n        ThermalDeform.name: ThermalDeform.working_eqn_latex,\n        AreaTube.name: AreaTube.working_eqn_latex,\n        ITube.name: ITube.working_eqn_latex,\n        Compatability1.name: Compatability1.working_eqn_latex,\n        Compatability2.name: Compatability2.working_eqn_latex\n        }\n\n        eqnbank_working_solver = {\n        StaticsSumFx.name: StaticsSumFx.working_eqn_solver,\n        StaticsSumFy.name: StaticsSumFy.working_eqn_solver,\n        StaticsSumM.name: StaticsSumM.working_eqn_solver,\n        StressEqn.name: StressEqn.working_eqn_solver,\n        BendingStress.name: BendingStress.working_eqn_solver,\n        AxialDeform.name: AxialDeform.working_eqn_solver,\n        ThermalDeform.name: ThermalDeform.working_eqn_solver,\n        AreaTube.name: AreaTube.working_eqn_solver,\n        ITube.name: ITube.working_eqn_solver,\n        Compatability1.name: Compatability1.working_eqn_solver,\n        Compatability2.name: Compatability2.working_eqn_solver\n        }\n\n        symbank_working = {\n        StaticsSumFx.name: StaticsSumFx.working_sym,\n        StaticsSumFy.name: StaticsSumFy.working_sym,\n        StaticsSumM.name: StaticsSumM.working_sym,\n        StressEqn.name: StressEqn.working_sym,\n        BendingStress.name: BendingStress.working_sym,\n        AxialDeform.name: AxialDeform.working_sym,\n        ThermalDeform.name: ThermalDeform.working_sym,\n        AreaTube.name: AreaTube.working_sym,\n        ITube.name: ITube.working_sym,\n        Compatability1.name: Compatability1.working_sym,\n        Compatability2.name: Compatability2.working_sym\n        }\n        \n        working_eqns_latex = [eqnbank_working_latex[key] for key in eqns_keys]\n        working_SumFx_render.set(eqnbank_working_latex[\"Equilibrium Forces in X\"])\n        working_SumFy_render.set(eqnbank_working_latex[\"Equilibrium Forces in Y\"])\n        working_SumM_render.set(eqnbank_working_latex[\"Equilibrium Moments about O\"])\n        working_StressEqn_render.set(eqnbank_working_latex[\"Stress Equation\"])\n        working_BendingStress_render.set(eqnbank_working_latex[\"Bending Stress from a Moment\"])\n        working_AxialDeform_render.set(eqnbank_working_latex[\"Axial Deformation by Force\"])\n        working_ThermalDeform_render.set(eqnbank_working_latex[\"Axial Deformation by Thermal\"])\n        working_AreaTube_render.set(eqnbank_working_latex[\"Area of a Tube\"])\n        working_Itube_render.set(eqnbank_working_latex[\"Moment of Inertia of a Tube\"])\n        working_Compatability1_render.set(eqnbank_working_latex[\"Compatability Equation 1\"])\n        working_Compatability2_render.set(eqnbank_working_latex[\"Compatability Equation 2\"])\n        working_eqns_solver = [eqnbank_working_solver[key] for key in eqns_keys]\n        \n        temp_working_equations_solver = \"#\".join(working_eqns_solver)\n        temp_working_equations_solver = temp_working_equations_solver.replace(\"Eq\",\"Wrap_clash\")\n        temp_working_equations_solver = temp_working_equations_solver.replace(\"E\",\"E_clash\")\n        temp_working_equations_solver = temp_working_equations_solver.replace(\"I\",\"I_clash\")\n        temp_working_equations_solver = temp_working_equations_solver.replace(\"N\",\"N_clash\")\n        temp_working_equations_solver = temp_working_equations_solver.replace(\"Wrap_clash\",\"Eq\")\n        working_eqns_solver = temp_working_equations_solver.split(\"#\")\n        \n        #working_eqns_solver=[]\n        #for j in working_eqns_solver_pre:\n        #    temp=j.split(\",\")\n        #    temp2=temp.replace(\"I\",\"I_clash\")\n        #    temp3=temp2.replace(\"E\",\"E_clash\")\n        #    working_eqns_solver.append(temp3)\n        \n        working_syms = [symbank_working[key] for key in eqns_keys]\n        mystring_working_eqns = \"\".join(working_eqns_latex)\n        mystring_working_eqns = mystring_working_eqns.replace(\"*\",\"\\\\times\")\n        feedback_syms.set(working_syms)\n        working_equations_solver.set(working_eqns_solver)\n\n        working_syms_only=[]\n        for j in working_syms:\n            temp=j.split(\",\")\n            for k in temp:\n                try: \n                    float(eval(k))  \n                except:\n                    temp2=k.replace(\"I\",\"I_clash\")\n                    temp3=temp2.replace(\"E\",\"E_clash\")\n                    temp4=temp3.replace(\"N\",\"N_clash\")\n                    working_syms_only.append(temp4)\n        working_syms_only=list(dict.fromkeys(working_syms_only))\n        working_symbols.set(working_syms_only)\n        \n        return [\n            ui.markdown(mystring_working_eqns),\n            ui.tags.script(\n                \"if (window.MathJax) MathJax.Hub.Queue(['Typeset', MathJax.Hub]);\"\n            )\n        ]\n    \n    @output\n    @render.ui\n    def dyn_ui_nav():\n      \n        tab_Instructions = ui.nav(\n            \"Instructions\",ui.markdown(\"Please choose the equations you would like to use in this problem. As you do, tabs will load here which allow you to browse between active equations and define the necessary parameters or variables to set up your solution. As you fill in parameters and variables, the working palette will change to reflect what values you are plugging in and will give you a running update of the number of equations you have relative to the number of unknowns you have. A solve equations button will be available for when you are ready to solve and the system will provide the solution to your system of equations. &lt;br&gt; &lt;br&gt; Note: You may put in simple math into the blanks (e.g., 3*4 instead of 12) which can be helpful in specifying Moment values or performing unit conversions in place. At this time, you may not mix and match this math with variables (e.g., typing in 5x in the blank will not parse the 5 as a number and the x as a variable) &lt;br&gt; &lt;br&gt; Key issues still needing development include: support for units?, **FEEDBACK**, choosing a solution value from the solution set, parameterized problem statement values...\") \n        )\n    \n        tab_StaticsSumFy = ui.nav(\n                str(StaticsSumFy.inline_math),\n                #ui.markdown(working_SumFy_string()),\n                ui.input_numeric(\"NumForcesY\",\"How many terms do you want?\",value=NumForcesY(),min=2,max=5),\n                ui.input_text(\"F1y\",\"\\(F_{y_1}=\\)\", value=F1y(),placeholder=\"Please type in variable or value\"),\n                ui.input_text(\"F2y\",\"\\(F_{y_2}=\\)\", value=F2y(),placeholder=\"Please type in variable or value\"),\n                ui.panel_conditional(\"input.NumForcesY&gt;=3\", ui.input_text(\"F3y\",\"\\(F_{y_3}=\\)\", value=F3y(),placeholder=\"Please type in variable or value\")),\n                ui.panel_conditional(\"input.NumForcesY&gt;=4\", ui.input_text(\"F4y\",\"\\(F_{y_4}=\\)\", value=F4y(),placeholder=\"Please type in variable or value\")),\n                ui.panel_conditional(\"input.NumForcesY&gt;=5\", ui.input_text(\"F5y\",\"\\(F_{y_5}=\\)\", value=F5y(),placeholder=\"Please type in variable or value\"))\n                )\n        \n        tab_StaticsSumFx = ui.nav(\n                str(StaticsSumFx.inline_math),\n                #ui.markdown(working_SumFx_string()),\n                ui.input_numeric(\"NumForcesX\",\"How many terms do you want?\",value=NumForcesX(),min=2,max=5),\n                ui.input_text(\"F1x\",\"\\(F_{x_1}=\\)\", value=F1x(),placeholder=\"Please type in variable or value\"),\n                ui.input_text(\"F2x\",\"\\(F_{x_2}=\\)\", value=F2x(),placeholder=\"Please type in variable or value\"),\n                ui.panel_conditional(\"input.NumForcesX&gt;=3\", ui.input_text(\"F3x\",\"\\(F_{x_3}=\\)\", value=F3x(),placeholder=\"Please type in variable or value\")),\n                ui.panel_conditional(\"input.NumForcesX&gt;=4\", ui.input_text(\"F4x\",\"\\(F_{x_4}=\\)\", value=F4x(),placeholder=\"Please type in variable or value\")),\n                ui.panel_conditional(\"input.NumForcesX&gt;=5\", ui.input_text(\"F5x\",\"\\(F_{x_5}=\\)\", value=F5x(),placeholder=\"Please type in variable or value\"))\n                )\n        \n        tab_StaticsSumM = ui.nav(\n                str(StaticsSumM.inline_math),\n                #ui.markdown(working_SumM_string()),\n                ui.input_numeric(\"NumMoments\",\"How many terms do you want?\",value=NumMoments(),min=2,max=5),\n                ui.input_text(\"M1\",\"\\(M_1=\\)\", value=M1(),placeholder=\"Please type in variables, values, or numeric math (e.g., (3*4))\"),\n                ui.input_text(\"M2\",\"\\(M_2=\\)\", value=M2(),placeholder=\"Please type in variables, values, or numeric math (e.g., (3*4))\"),\n                ui.panel_conditional(\"input.NumMoments&gt;=3\", ui.input_text(\"M3\",\"\\(M_3=\\)\", value=M3(),placeholder=\"Please type in variable, values, or numeric math (e.g., (3*4))\")),\n                ui.panel_conditional(\"input.NumMoments&gt;=4\", ui.input_text(\"M4\",\"\\(M_4=\\)\", value=M4(),placeholder=\"Please type in variable , values, or numeric math (e.g., (3*4))\")),\n                ui.panel_conditional(\"input.NumMoments&gt;=5\", ui.input_text(\"M5\",\"\\(M_5=\\)\", value=M5(),placeholder=\"Please type in variable , values, or numeric math (e.g., (3*4))\"))\n                )\n        \n        tab_StressEqn = ui.nav(\n                str(StressEqn.inline_math),\n                #ui.markdown(working_StressEqn_string()),\n                ui.input_text(\"sigma\",\"\\(\\sigma\\)\", value=axial_stress_sigma(),placeholder=\"Please type in variables or values\"),\n                ui.input_text(\"force\",\"\\(F\\)\", value=axial_stress_force(),placeholder=\"Please type in variables or values\"),\n                ui.input_text(\"area\",\"\\(A\\)\", value=axial_stress_area(),placeholder=\"Please type in variables or values\"),\n                )\n        \n        tab_BendingStress = ui.nav(\n                str(BendingStress.inline_math),\n                #ui.markdown(working_BendingStress_string()),\n                ui.input_text(\"bendingstress_sigma_b\",\"\\(\\sigma_b\\)\", value=bending_stress_sigma(), placeholder=\"Please type in variables or values\"),\n                ui.input_text(\"bendingstress_M\",\"\\(M\\)\", value=bending_stress_M(), placeholder=\"Please type in variables or values\"),\n                ui.input_text(\"bendingstress_y\",\"\\(y\\)\", value=bending_stress_y(), placeholder=\"Please type in variables or values\"),\n                ui.input_text(\"bendingstress_I\",\"\\(I\\)\", value= bending_stress_I(), placeholder=\"Please type in variables or values\"),\n                )\n        \n        tab_AxialDeform = ui.nav(\n                str(AxialDeform.inline_math),\n                #ui.markdown(working_AxialDeform_string()),\n                ui.input_text(\"axial_delta_l\",\"\\(\\delta_l\\)\", value=axial_delta_l(), placeholder=\"Please type in variables or values\"),\n                ui.input_text(\"axial_P\",\"\\(P\\)\", value=axial_P(), placeholder=\"Please type in variables or values\"),\n                ui.input_text(\"axial_L\",\"\\(L\\)\", value=axial_L(), placeholder=\"Please type in variables or values\"),\n                ui.input_text(\"axial_A\",\"\\(A\\)\", value=axial_A(), placeholder=\"Please type in variables or values\"),\n                ui.input_text(\"axial_E\",\"\\(E\\)\", value=axial_E(), placeholder=\"Please type in variables or values\"),\n                )\n        \n        tab_ThermalDeform = ui.nav(\n                str(ThermalDeform.inline_math),\n                #ui.markdown(working_ThermalDeform_string()),\n                ui.input_text(\"thermal_delta_t\",\"\\(\\delta_t\\)\", value=thermal_delta_t(), placeholder=\"Please type in variables or values\"),\n                ui.input_text(\"thermal_alpha\",\"\\(\\\\alpha\\)\", value=thermal_alpha(), placeholder=\"Please type in variables or values\"),\n                ui.input_text(\"thermal_Delta_T\",\"\\(\\Delta T\\)\", value=thermal_Delta_T(), placeholder=\"Please type in variables or values\"),\n                ui.input_text(\"thermal_L\",\"\\(L\\)\", value=thermal_L(), placeholder=\"Please type in variables or values\"),\n                )\n        \n        tab_AreaTube = ui.nav(\n                str(AreaTube.inline_math),\n                #ui.markdown(working_AreaTube_string()),\n                ui.input_text(\"A_tube\",\"\\(A_{tube}=\\)\", value=area_tube_A_tube(), placeholder=\"Please type in variables or values\"),\n                ui.input_text(\"Ar_o\",\"\\(r_o=\\)\", value=area_tube_Ar_o(), placeholder=\"Please type in variables or values\"),\n                ui.input_text(\"Ar_i\",\"\\(r_i\\)\", value=area_tube_Ar_i(), placeholder=\"Please type in variables or values\")\n                )\n        \n        tab_ITube = ui.nav(\n                str(ITube.inline_math),\n                #ui.markdown(working_Itube_string()),\n                ui.input_text(\"I_tube\",\"\\(I_{tube}=\\)\", value=I_tube_I_tube(), placeholder=\"Please type in variables or values\"),\n                ui.input_text(\"Ir_o\",\"\\(r_o=\\)\", value=I_tube_Ir_o(), placeholder=\"Please type in variables or values\"),\n                ui.input_text(\"Ir_i\",\"\\(r_i\\)\", value=i_tube_Ir_i(), placeholder=\"Please type in variables or values\"),\n                )\n        \n        tab_Compatability1 = ui.nav(\n                str(Compatability1.inline_math),\n                #ui.markdown(working_Compatability1_string()),\n                ui.input_numeric(\"Compatability1_NumLHS\",\"How many 'a' terms do you want?\",value=Compatability1_NumLHS(),min=1,max=5),\n                ui.input_numeric(\"Compatability1_NumRHS\",\"How many 'b' terms do you want?\",value=Compatability1_NumRHS(),min=1,max=5),\n                ui.input_text(\"a_1\",\"\\(a_1=\\)\", value=Compatability1_a_1(),placeholder=\"Please type in variable or value\"),\n                ui.panel_conditional(\"input.Compatability1_NumLHS&gt;=2\",ui.input_text(\"a_2\",\"\\(a_2=\\)\", value=Compatability1_a_2(),placeholder=\"Please type in variable or value\")),\n                ui.panel_conditional(\"input.Compatability1_NumLHS&gt;=3\", ui.input_text(\"a_3\",\"\\(a_3=\\)\", value=Compatability1_a_3(),placeholder=\"Please type in variable or value\")),\n                ui.panel_conditional(\"input.Compatability1_NumLHS&gt;=4\", ui.input_text(\"a_4\",\"\\(a_4=\\)\", value=Compatability1_a_4(),placeholder=\"Please type in variable or value\")),\n                ui.panel_conditional(\"input.Compatability1_NumLHS&gt;=5\", ui.input_text(\"a_5\",\"\\(a_5=\\)\", value=Compatability1_a_5(),placeholder=\"Please type in variable or value\")),\n                ui.input_text(\"b_1\",\"\\(b_1=\\)\", value=Compatability1_b_1(),placeholder=\"Please type in variable or value\"),\n                ui.panel_conditional(\"input.Compatability1_NumRHS&gt;=2\",ui.input_text(\"b_2\",\"\\(b_2=\\)\", value=Compatability1_b_2(),placeholder=\"Please type in variable or value\")),\n                ui.panel_conditional(\"input.Compatability1_NumRHS&gt;=3\",ui.input_text(\"b_3\",\"\\(b_3=\\)\", value=Compatability1_b_3(),placeholder=\"Please type in variable or value\")),\n                ui.panel_conditional(\"input.Compatability1_NumRHS&gt;=4\",ui.input_text(\"b_4\",\"\\(b_4=\\)\", value=Compatability1_b_4(),placeholder=\"Please type in variable or value\")),\n                ui.panel_conditional(\"input.Compatability1_NumRHS&gt;=5\",ui.input_text(\"b_5\",\"\\(b_5=\\)\", value=Compatability1_b_5(),placeholder=\"Please type in variable or value\")),\n                )\n        \n        tab_Compatability2 = ui.nav(\n                str(Compatability2.inline_math),\n                #ui.markdown(working_Compatability2_string()),\n                ui.input_numeric(\"Compatability2_NumLHS\",\"How many 'c' terms do you want?\",value=Compatability2_NumLHS(),min=1,max=5),\n                ui.input_numeric(\"Compatability2_NumRHS\",\"How many 'd' terms do you want?\",value=Compatability2_NumRHS(),min=1,max=5),\n                ui.input_text(\"c_1\",\"\\(c_1=\\)\", value=Compatability2_c_1(),placeholder=\"Please type in variable or value\"),\n                ui.panel_conditional(\"input.Compatability2_NumLHS&gt;=2\",ui.input_text(\"c_2\",\"\\(c_2=\\)\", value=Compatability2_c_2(),placeholder=\"Please type in variable or value\")),\n                ui.panel_conditional(\"input.Compatability2_NumLHS&gt;=3\", ui.input_text(\"c_3\",\"\\(c_3=\\)\", value=Compatability2_c_3(),placeholder=\"Please type in variable or value\")),\n                ui.panel_conditional(\"input.Compatability2_NumLHS&gt;=4\", ui.input_text(\"c_4\",\"\\(c_4=\\)\", value=Compatability2_c_4(),placeholder=\"Please type in variable or value\")),\n                ui.panel_conditional(\"input.Compatability2_NumLHS&gt;=5\", ui.input_text(\"c_5\",\"\\(c_5=\\)\", value=Compatability2_c_5(),placeholder=\"Please type in variable or value\")),\n                ui.input_text(\"d_1\",\"\\(d_1=\\)\", value=Compatability2_d_1(),placeholder=\"Please type in variable or value\"),\n                ui.panel_conditional(\"input.Compatability2_NumRHS&gt;=2\",ui.input_text(\"d_2\",\"\\(d_2=\\)\", value=Compatability2_d_2(),placeholder=\"Please type in variable or value\")),\n                ui.panel_conditional(\"input.Compatability2_NumRHS&gt;=3\",ui.input_text(\"d_3\",\"\\(d_3=\\)\", value=Compatability2_d_3(),placeholder=\"Please type in variable or value\")),\n                ui.panel_conditional(\"input.Compatability2_NumRHS&gt;=4\",ui.input_text(\"d_4\",\"\\(d_4=\\)\", value=Compatability2_d_4(),placeholder=\"Please type in variable or value\")),\n                ui.panel_conditional(\"input.Compatability2_NumRHS&gt;=5\",ui.input_text(\"d_5\",\"\\(d_5=\\)\", value=Compatability2_d_5(),placeholder=\"Please type in variable or value\")),\n                )\n\n        tab_bank = {\n                StaticsSumFx.name: tab_StaticsSumFx,\n                StaticsSumFy.name: tab_StaticsSumFy,\n                StaticsSumM.name: tab_StaticsSumM,\n                StressEqn.name: tab_StressEqn,\n                BendingStress.name: tab_BendingStress,\n                AxialDeform.name: tab_AxialDeform,\n                ThermalDeform.name: tab_ThermalDeform,\n                AreaTube.name: tab_AreaTube,\n                ITube.name: tab_ITube,\n                Compatability1.name: tab_Compatability1,\n                Compatability2.name: tab_Compatability2,\n                }\n        eqns_keys = input.selected_eqns()\n        tabs = [tab_bank[key] for key in eqns_keys]\n        tabs.insert(0,tab_Instructions)\n        equations = ui.navset_tab_card(*tabs,id=\"mytab\",selected=active_eqn_tab())                    \n    \n        return [equations,\n               ui.tags.script(\n                \"if (window.MathJax) MathJax.Hub.Queue(['Typeset', MathJax.Hub]);\"\n        ),]\n\n    @output\n    @render.ui\n    def ui_equation_bookkeeping():\n        req(working_equations_solver())\n        num_working_equations=len(working_equations_solver())\n        num_working_symbols=len(working_symbols())\n        string_working_symbols= \"\\\\\\\\(\"+\"\\\\\\\\),\\\\\\\\(\".join(working_symbols())+\"\\\\\\\\)\"\n        string_working_symbols=string_working_symbols.replace(\"N_clash\",\"N\")\n        string_working_symbols=string_working_symbols.replace(\"I_clash\",\"I\")\n        string_working_symbols=string_working_symbols.replace(\"E_clash\",\"E\")\n        string_working_symbols=string_working_symbols.replace(\"delta\",\"\\delta\")\n        string_working_symbols=string_working_symbols.replace(\"Delta\",\"\\Delta\")\n        string_working_symbols=string_working_symbols.replace(\"sigma\",\"\\sigma\")\n        return [ui.markdown(f\"Your equation-solver set up currently has **{num_working_equations} equations** and **{num_working_symbols} unknowns**. &lt;br&gt;  Your current unknowns are {string_working_symbols}\"), \n                ui.input_action_button(\n                    \"solveEquations\", \"Solve Equations\", class_=\"btn-success\", width=\"240px\", style='margin-bottom:10px'),\n                ui.tags.script(\n                \"if (window.MathJax) MathJax.Hub.Queue(['Typeset', MathJax.Hub]);\"\n                )]\n        \n    @output\n    @render.ui\n    @reactive.event(input.solveEquations)\n    def ui_solutions():\n        for j in working_symbols():\n            j=Symbol(j)\n        print(working_equations_solver())\n        print(working_symbols())\n        my_solver_equations=[]\n        for m in working_equations_solver():\n            m=parse_expr(m)\n        solve_eqns = solve(working_equations_solver(),working_symbols(),dict=True)\n        answers=[]\n        for k in working_symbols():\n            try: \n                temp=solve_eqns[0][parse_expr(k)]\n                temp2=\"$$\"+k+\"=\"+f'{temp:.2f}'+\"$$\"\n                answers.append(temp2)\n            except:\n                pass\n        mystring_answers=\"\".join(answers)\n        mystring_answers=mystring_answers.replace(\"pi\",\"\\pi\")\n        mystring_answers=mystring_answers.replace(\"delta\",\"\\delta\")\n        mystring_answers=mystring_answers.replace(\"Delta\",\"\\Delta\")\n        mystring_answers=mystring_answers.replace(\"sigma\",\"\\sigma\")\n        mystring_answers=mystring_answers.replace(\"E_clash\",\"E\")\n        mystring_answers=mystring_answers.replace(\"I_clash\",\"I\")\n        mystring_answers=mystring_answers.replace(\"N_clash\",\"N\")\n        #feedback_solns.set(mystring_answers)\n        return [ui.markdown(f\"Your solution is {mystring_answers}\"),\n                ui.input_text(\"answer\",\"Answer:\",placeholder=\"Please type in your answer\"),\n                ui.input_action_button(\"feedback\", \"Check answer and show feedback\"),\n                ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n                ui.tags.script(\n                \"if (window.MathJax) MathJax.Hub.Queue(['Typeset', MathJax.Hub]);\"\n                )]\n\n    #@reactive.Effect\n    #def _():\n\n     #   active_eqn_tab.set(input.mytab())\n    \n    \n    @reactive.Effect\n    def _():\n\n        input.selected_eqns()\n        active_eqn_tab.set(input.mytab())\n        \n        \n        #working_SumFx_render():\n        #working_SumFy_render()\n        #working_SumM_render()\n        #working_StressEqn_render()\n        #working_BendingStress_render()\n        #working_AxialDeform_render()\n        #working_ThermalDeform_render()\n        #working_AreaTube_render()\n        #working_Itube_render()\n        #working_Compatability1_render()\n        #working_Compatability2_render()\n                \n        with reactive.isolate():\n            if \"Equilibrium Forces in Y\" in input.selected_eqns(): \n                NumForcesY.set(input.NumForcesY())\n                F1y.set(input.F1y())\n                F2y.set(input.F2y())\n                F3y.set(input.F3y())\n                F4y.set(input.F4y())\n                F5y.set(input.F5y())\n                working_SumFy_string.set(str(working_SumFy_render()))\n            else:\n                 pass             \n    \n            if \"Equilibrium Forces in X\" in input.selected_eqns(): \n                NumForcesX.set(input.NumForcesX())\n                F1x.set(input.F1x())\n                F2x.set(input.F2x())\n                F3x.set(input.F3x())\n                F4x.set(input.F4x())\n                F5x.set(input.F5x())\n                working_SumFx_string.set(str(working_SumFx_render()))\n            else:\n                 pass\n                              \n            if \"Equilibrium Moments about O\" in input.selected_eqns(): \n                NumMoments.set(input.NumMoments())\n                M1.set(input.M1())\n                M2.set(input.M2())\n                M3.set(input.M3())\n                M4.set(input.M4())\n                M5.set(input.M5())\n                working_SumM_string.set(str(working_SumM_render()))\n            else:\n                 pass\n                \n            if \"Stress Equation\" in input.selected_eqns(): \n                axial_stress_sigma.set(input.sigma())\n                axial_stress_force.set(input.force())\n                axial_stress_area.set(input.area())\n                working_StressEqn_string.set(str(working_StressEqn_render()))\n            else:\n                 pass\n            \n            if \"Axial Deformation by Force\" in input.selected_eqns(): \n                axial_delta_l.set(input.axial_delta_l())\n                axial_P.set(input.axial_P())\n                axial_L.set(input.axial_L())\n                axial_A.set(input.axial_A())\n                axial_E.set(input.axial_E())\n                working_AxialDeform_string.set(str(working_AxialDeform_render()))\n            else:\n                 pass\n            \n            if \"Axial Deformation by Thermal\" in input.selected_eqns(): \n                thermal_delta_t.set(input.thermal_delta_t())\n                thermal_alpha.set(input.thermal_alpha())\n                thermal_Delta_T.set(input.thermal_Delta_T())\n                thermal_L.set(input.thermal_L())\n                working_ThermalDeform_string.set(str(working_ThermalDeform_render()))\n            else:\n                 pass\n    \n            if \"Area of a Tube\" in input.selected_eqns(): \n                area_tube_A_tube.set(input.A_tube())\n                area_tube_Ar_o.set(input.Ar_o())\n                area_tube_Ar_i.set(input.Ar_i())\n                working_AreaTube_string.set(str(working_AreaTube_render()))\n            else:\n                 pass\n    \n            if \"Moment of Inertia of a Tube\" in input.selected_eqns():           \n                I_tube_I_tube.set(input.I_tube())\n                I_tube_Ir_o.set(input.Ir_o())\n                i_tube_Ir_i.set(input.Ir_i())\n                working_Itube_string.set(str(working_Itube_render()))\n            else:\n                 pass\n    \n            if \"Bending Stress from a Moment\" in input.selected_eqns(): \n                bending_stress_sigma.set(input.bendingstress_sigma_b())\n                bending_stress_M.set(input.bendingstress_M())\n                bending_stress_y.set(input.bendingstress_y())\n                bending_stress_I.set(input.bendingstress_I())\n                working_BendingStress_string.set(str(working_BendingStress_render()))\n            else:\n                 pass\n    \n            if \"Compatability Equation 1\" in input.selected_eqns(): \n                Compatability1_NumLHS.set(input.Compatability1_NumLHS())\n                Compatability1_NumRHS.set(input.Compatability1_NumRHS())\n                Compatability1_a_1.set(input.a_1())\n                Compatability1_a_2.set(input.a_2())\n                Compatability1_a_3.set(input.a_3())\n                Compatability1_a_4.set(input.a_4())\n                Compatability1_a_5.set(input.a_5())\n                Compatability1_b_1.set(input.b_1())\n                Compatability1_b_2.set(input.b_2())\n                Compatability1_b_3.set(input.b_3())\n                Compatability1_b_4.set(input.b_4())\n                Compatability1_b_5.set(input.b_5())\n                working_Compatability1_string.set(str(working_Compatability1_render()))\n            else:\n                 pass\n    \n            if \"Compatability Equation 2\" in input.selected_eqns(): \n                Compatability2_NumLHS.set(input.Compatability2_NumLHS())\n                Compatability2_NumRHS.set(input.Compatability2_NumRHS())\n                Compatability2_c_1.set(input.c_1())\n                Compatability2_c_2.set(input.c_2())\n                Compatability2_c_3.set(input.c_3())\n                Compatability2_c_4.set(input.c_4())\n                Compatability2_c_5.set(input.c_5())\n                Compatability2_d_1.set(input.d_1())\n                Compatability2_d_2.set(input.d_2())\n                Compatability2_d_3.set(input.d_3())\n                Compatability2_d_4.set(input.d_4())\n                Compatability2_d_5.set(input.d_5())\n                working_Compatability2_string.set(str(working_Compatability2_render()))\n            else:\n                 pass\n\n                \n    @reactive.Effect\n    @reactive.event(input.feedback)\n    def _():\n        inst_eqns=[eqnbank_newline[key] for key in [\"Equilibrium Forces in Y\", \"Equilibrium Moments about O\",\"Stress Equation\", \"Area of a Tube\",\"Moment of Inertia of a Tube\", \"Bending Stress from a Moment\",\"Compatability Equation 1\"]]\n        inst_soln=\"6520\"\n        inst_unknowns=[\"N\",\"M_o\",\"\\sigma_b\", \"\\sigma_l\",\"A_{tube}\",\"I_{tube}\",\"\\sigma_{max}\"]\n        attempt_equations=feedback_equations()\n        attempt_soln=input.answer()\n        attempt_unknowns=feedback_syms()\n        missing_inst_eqns=set(inst_eqns).difference(attempt_equations)\n        extra_student_eqns=set(attempt_equations).difference(inst_eqns)\n        \n        if inst_soln==attempt_soln:\n          feedback_message=ui.markdown(\"Congratulations! You are correct, great work.\")\n        else:\n          feedback_message=ui.markdown(f\"This feedback is the list method -- checking your selected equations and associated parameters with instructor provided equations and unknowns. In this check, the instructor used these equations which you did not use {missing_inst_eqns} and you used these equations that the instructor did not use {extra_student_eqns}. This may help you think through any errors in your logic or could just be an indicator that you are approaching the problem differently which could still be correct. Further, looking at the unknown variables in each solution, you used these unknowns in your system of equations {attempt_unknowns} and the instructor used the following unknowns {inst_unknowns}. Again, this may help you think through possible errors in your logic or could just be an indicator that you used a different naming convention and/or are approaching the problem differently which could still be correct.\")\n        \n        m = ui.modal(\n            feedback_message, ui.tags.script(\n                \"if (window.MathJax) MathJax.Hub.Queue(['Typeset', MathJax.Hub]);\"\n                ),\n            title=\"Feedback on your solution\",\n            easy_close=True,\n            footer=None,\n        )\n        ui.modal_show(m)\n        \n        \n    @session.download(\n    filename=lambda: f\"Problem_Log.csv\"\n    )\n    async def download():\n        # This version uses a function to generate the filename. It also yields data\n        # multiple times.\n          await asyncio.sleep(0.25)\n          yield f\"{working_equations_solver()}\\n\"\n          yield f\"{working_equations_latex_render()}\\n\"\n\napp = App(app_ui, server)",
    "crumbs": [
      "Interactive Interface Demo",
      "Interactive Problem Interface"
    ]
  },
  {
    "objectID": "problem2_23dynamicsubmit.html",
    "href": "problem2_23dynamicsubmit.html",
    "title": "Problem 2.23",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 2.23"
    ]
  },
  {
    "objectID": "problem2_23dynamicsubmit.html#problem-image",
    "href": "problem2_23dynamicsubmit.html#problem-image",
    "title": "Problem 2.23",
    "section": "",
    "text": "Figure 1: A square bar of length is pinned at one end and rests on a circular rod.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"168\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A square bar of length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in. is pinned at one end and rests on a circular rod of diameter d = {d()} in. A force F = {F()} lb is applied at the free end. What is the average shear stress in the circular rod? \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(50, 150, 1)/10)\n        L2.set(round(L1() * 1.4, 2))\n        d.set(random.randrange(4, 9, 1)/10)\n        F.set(random.randrange(30, 100, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        M = F()*(L1()+L2())\n        R = M/L1()\n        A = math.pi*(d()/2)**2\n        instr= R/(2*A)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 2.23"
    ]
  },
  {
    "objectID": "problem2_39dynamicsubmit.html",
    "href": "problem2_39dynamicsubmit.html",
    "title": "Problem 2.39",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 2.39"
    ]
  },
  {
    "objectID": "problem2_39dynamicsubmit.html#problem-image",
    "href": "problem2_39dynamicsubmit.html#problem-image",
    "title": "Problem 2.39",
    "section": "",
    "text": "Figure 1: A link mechanism is connected with diameter pins.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"180\"\nF=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\n\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)  \n  \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A link mechanism is connected with pins of diameter d = {d()} in. A force F = {F()} lb is applied to the mechanism as shown. The mechanism has width w = {w()} in. and thickness t = {t()} in. What is the bearing stress in member BC at joint B due to the pin at B? \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(200, 900, 10))\n        d.set(random.randrange(20, 150, 10)/100)\n        t.set(random.randrange(2, 10, 1)/10)\n        w.set(round(d()*2, 2))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Fb=((18+8)*F())/18\n        instr= Fb/(d()*t())/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 2.39"
    ]
  },
  {
    "objectID": "problem2_40dynamicsubmit.html",
    "href": "problem2_40dynamicsubmit.html",
    "title": "Problem 2.40",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 2.40"
    ]
  },
  {
    "objectID": "problem2_40dynamicsubmit.html#problem-image",
    "href": "problem2_40dynamicsubmit.html#problem-image",
    "title": "Problem 2.40",
    "section": "",
    "text": "Figure 1: A steel connector plate is hung from a brass rod.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"169\"\nd=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nFbrass = 70\nFsteel = 75\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kips\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A steel connector plate is hung from a brass rod of diameter d = {d()} in. The plate has dimensions t = {t()} in. and w = {w()} in. Find the minimum load that will cause the connector or rod to fail. Assume the tensile and compressive failure stress for brass is 70 ksi and for steel is 75 ksi. Assume the shear failure stress for each material is one half of the tensile-compressive failure stress. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(8, 20, 1)/10)\n        t.set(random.randrange(3, 7, 1)/10)\n        w.set(round(d() * 2, 2))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.  \n      \n        instr= (Fsteel/2)*(2*.866*(w()-d())/2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 2.40"
    ]
  },
  {
    "objectID": "problem4_5dynamicsubmit.html",
    "href": "problem4_5dynamicsubmit.html",
    "title": "Problem 4.5",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 4.5"
    ]
  },
  {
    "objectID": "problem4_5dynamicsubmit.html#problem-image",
    "href": "problem4_5dynamicsubmit.html#problem-image",
    "title": "Problem 4.5",
    "section": "",
    "text": "Figure 1: A single force pulls on three cylindrical rods that are fixed to a wall.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"188\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nEsteel = 29000\nEaluminum = 10000\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches/inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A single force F = {F()} kips pulls on three cylindrical rods, each of length L = {L()} in., Diameter d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in., and d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in. What is the strain in the steel cylinder? Assume E&lt;sub&gt;steel&lt;/sub&gt; = 29,000 ksi and E&lt;sub&gt;aluminum&lt;/sub&gt; = 10,000 ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(20, 300, 1)/10)\n        L.set(random.randrange(50, 200, 1)/10)\n        d1.set(random.randrange(10, 50, 1)/10)\n        d2.set(round(d1()/2, 2))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr=(F()/(((d2()/2)**2)*math.pi))/Esteel\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 4.5"
    ]
  },
  {
    "objectID": "problem4_6dynamicsubmit.html",
    "href": "problem4_6dynamicsubmit.html",
    "title": "Problem 4.6",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 4.6"
    ]
  },
  {
    "objectID": "problem4_6dynamicsubmit.html#problem-image",
    "href": "problem4_6dynamicsubmit.html#problem-image",
    "title": "Problem 4.6",
    "section": "",
    "text": "Figure 1: A polymer test specimen is pulled from the top and bottom.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"194\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\ndL=reactive.Value(\"__\")\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A polymer test specimen is subjected to an axial load of F = {F()} kips. The central portion of the specimen has an initial length L = {L()} in., w = {w()} in., and t = {t()} in. If the length increases by dL = {dL()} in., determine the elastic modulus of the material. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(100, 500, 1)/10)\n        L.set(random.randrange(50, 150, 1)/10)\n        w.set(round(L()*0.375, 2))\n        t.set(random.randrange(10, 50, 1)/100)\n        dL.set(random.randrange(3, 9, 1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (F()*L())/(dL()*(w()*t()))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 4.6"
    ]
  },
  {
    "objectID": "problem4_10dynamicsubmit.html",
    "href": "problem4_10dynamicsubmit.html",
    "title": "Problem 4.10",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 4.10"
    ]
  },
  {
    "objectID": "problem4_10dynamicsubmit.html#problem-image",
    "href": "problem4_10dynamicsubmit.html#problem-image",
    "title": "Problem 4.10",
    "section": "",
    "text": "Figure 1: A circular road is placed in tension with an axial load.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"206\"\nP=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\n\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A circular rod of an unknown metallic alloy is placed in tension with a P = {P()} kip axial load. The length of the rod is L = {L()} in. and the diameter is d = {d()} in. After applying the load, the rod length increases by 0.0035 in and the diameter decreases by 0.00014 in. The Young's modulus is E = {E()} x 10&lt;sup&gt;6&lt;/sup&gt;. What is the Poisson's ratio of the alloy?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        P.set(random.randrange(20, 200, 1)/10)\n        L.set(random.randrange(10, 20, 1))\n        E.set(random.randrange(20, 40, 1)/100)\n        d.set(round((.00014*L())/(.0035*E()), 2))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n       \n        instr= -(-.00014/d())/(.0035/L())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 4.10"
    ]
  },
  {
    "objectID": "problem4_11dynamicsubmit.html",
    "href": "problem4_11dynamicsubmit.html",
    "title": "Problem 4.11",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 4.11"
    ]
  },
  {
    "objectID": "problem4_11dynamicsubmit.html#problem-image",
    "href": "problem4_11dynamicsubmit.html#problem-image",
    "title": "Problem 4.11",
    "section": "",
    "text": "Figure 1: A circular rod is inserted into a space slightly wider than the rod.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"213\"\nr1=reactive.Value(\"__\")\nr2=reactive.Value(\"__\")\nE=15000\nv=0.33\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"An aluminum circular rod of radius r&lt;sub&gt;1&lt;/sub&gt; = {r1()} in is inserted into space that is slightly wider than the rod, where r&lt;sub&gt;2&lt;/sub&gt; = {r2()} in. What load P is needed so that the rod expands and fills the space in the radial direction? Assume E = 15,000 ksi and v = 0.33. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        r1.set(random.randrange(10, 50, 1)/10)\n        r2.set((r1() + random.randrange(2, 200, 1)/1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Ex = (r1() - r2())/r1()\n        sigmay = (Ex*E)/(-v)\n        instr= sigmay*math.pi*r1()**2\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 4.11"
    ]
  },
  {
    "objectID": "problem4_12dynamicsubmit.html",
    "href": "problem4_12dynamicsubmit.html",
    "title": "Problem 4.12",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 4.12"
    ]
  },
  {
    "objectID": "problem4_12dynamicsubmit.html#problem-image",
    "href": "problem4_12dynamicsubmit.html#problem-image",
    "title": "Problem 4.12",
    "section": "",
    "text": "Figure 1: A rectangular rod is pulled in tension in the x-direction.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"216\"\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A rectangular bar is pulled in tension by a load P in the x-direction. The bar deflects by d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in and d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in, in the x- and y-direction, respectively. The length in the x-direction is 5 in, and the length in the y direction is 1 in. What is the Poisson's Ratio of the material? The z-direction deflection is not known. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d1.set(random.randrange(20, 50, 1)/1000)\n        d2.set(random.randrange(10, 20, 1)/10000)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= -(-d2()/1)/(d1()/5)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 4.12"
    ]
  },
  {
    "objectID": "problem4_23dynamicsubmit.html",
    "href": "problem4_23dynamicsubmit.html",
    "title": "Problem 4.23",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 4.23"
    ]
  },
  {
    "objectID": "problem4_23dynamicsubmit.html#problem-image",
    "href": "problem4_23dynamicsubmit.html#problem-image",
    "title": "Problem 4.23",
    "section": "",
    "text": "Figure 1: A block is pulled in by two forces.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"204\"\nL=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nFx=reactive.Value(\"__\")\nFy=reactive.Value(\"__\")\nE=29000\nv=0.29\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A square steel plate of side length L = {L()} in. and thickness t = {t()} in. is uniformly pulled by two forces F&lt;sub&gt;x&lt;/sub&gt; = {Fx()} kips and F&lt;sub&gt;y&lt;/sub&gt; = {Fy()} kips as shown. If E = 29,000 ksi and Poisson's ratio v = 0.29, determine the change in thickness of the plate. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50, 150, 1)/10)\n        t.set(random.randrange(2, 10, 1)/10)\n        Fx.set(random.randrange(100, 500, 1)/10)\n        Fy.set(random.randrange(100, 500, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigmax = Fx()/(L()*t())\n        sigmay = Fy()/(L()*t())\n        instr= t()*(-v/E)*(sigmax+sigmay)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 4.23"
    ]
  },
  {
    "objectID": "problem4_24dynamicsubmit.html",
    "href": "problem4_24dynamicsubmit.html",
    "title": "Problem 4.24",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 4.24"
    ]
  },
  {
    "objectID": "problem4_24dynamicsubmit.html#problem-image",
    "href": "problem4_24dynamicsubmit.html#problem-image",
    "title": "Problem 4.24",
    "section": "",
    "text": "Figure 1: A strain gauge is placed on a test sample and a vertical load is applied to the test sample.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"205\"\nP1=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\nv=reactive.Value(\"__\")\nSG=reactive.Value(\"__\")\n\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in percent\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A strain gauge is placed on a polymer test sample with an elastic modulus E =  {E()} x 10&lt;sup&gt;6&lt;/sup&gt; psi and a Poisson's ratio of v = {v()}. When a P&lt;sub&gt;1&lt;/sub&gt; = {P1()} kip vertical load is applied to the test sample, the strain gauge reads a strain of SG = {SG()} x 10&lt;sup&gt;-6&lt;/sup&gt; in the x-direction. What is the relative error of the strain gauge compared to the theoretical strain of the test sample? Note: relative error is defined to be the difference between the measured value and the theoretical value divided by the theoretical value \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        P1.set(random.randrange(20, 200, 1)/10)\n        E.set(random.randrange(5, 20, 1))\n        v.set(random.randrange(20, 40, 1)/100)\n        SG.set(round((v()*P1()*1000)/(12*E()),2)-(random.randrange(3, 20, 1)/10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigmaz = (-P1()*1000)/(4*3)\n        Ex = ((-v()*(sigmaz))/(E()*10**6))\n        instr=  ((Ex - SG()*10**-6)/Ex)*100\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 4.24"
    ]
  },
  {
    "objectID": "problem4_25dynamicsubmit.html",
    "href": "problem4_25dynamicsubmit.html",
    "title": "Problem 4.25",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 4.25"
    ]
  },
  {
    "objectID": "problem4_25dynamicsubmit.html#problem-image",
    "href": "problem4_25dynamicsubmit.html#problem-image",
    "title": "Problem 4.25",
    "section": "",
    "text": "Figure 1: A block is pulled in all three directions.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"208\"\nPx=reactive.Value(\"__\")\nPy=reactive.Value(\"__\")\nPz=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\nv=reactive.Value(\"__\")\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in percent\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A block with sides is pulled in all three directions (P&lt;sub&gt;x&lt;/sub&gt; = {Px()} kN, P&lt;sub&gt;y&lt;/sub&gt; = {Py()} kN, P&lt;sub&gt;z&lt;/sub&gt; = {Pz()} kN). What is the percent change in volume after all three loads are applied? Assume E = {E()} MPa and v = {v()}. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        Px.set(random.randrange(1, 20, 1))\n        Py.set(random.randrange(1, 20, 1))\n        Pz.set(random.randrange(1, 20, 1))\n        E.set(random.randrange(1000, 2000, 100))\n        v.set(random.randrange(20, 40, 1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigmax = (Px()/(5*2))*10\n        sigmay = (Py()/(6*2))*10\n        sigmaz = (Pz()/(5*6))*10\n        Ex = (sigmax - v()*(sigmay+sigmaz))/(E())\n        Ey = (sigmay - v()*(sigmaz+sigmax))/(E())\n        Ez = (sigmaz - v()*(sigmax+sigmay))/(E())\n        Lx = 6 + 6*Ex\n        Ly = 5 + 5*Ey\n        Lz = 2 + 2*Ez\n        instr= (((Lx*Ly*Lz)-60)/60)*100\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 4.25"
    ]
  },
  {
    "objectID": "problem5_11dynamicsubmit.html",
    "href": "problem5_11dynamicsubmit.html",
    "title": "Problem 5.11",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.11"
    ]
  },
  {
    "objectID": "problem5_11dynamicsubmit.html#problem-image",
    "href": "problem5_11dynamicsubmit.html#problem-image",
    "title": "Problem 5.11",
    "section": "",
    "text": "Figure 1: A series of solid, steel, circular bars are loaded with forces.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\nproblem_ID=\"183\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\nF4=reactive.Value(\"__\")\nE=210\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A series of solid, steel, circular bars are loaded with forces as shown, where F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN, F&lt;sub&gt;3&lt;/sub&gt; = {F3()} kN, and F&lt;sub&gt;4&lt;/sub&gt; = {F4()} kN. What is the total change in length of the system? Assume E = 210 GPa for steel.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(10, 100, 1)/10)\n        F2.set(random.randrange(10, 100, 1)/10)\n        F3.set(random.randrange(10, 100, 1)/10)\n        F4.set(random.randrange(10, 100, 1)/10)\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= ((F1()*3)/(E*math.pi*0.5**2)+((F1()+F2())*3)/(E*math.pi*1**2)+((F1()+F2()+F3())*4)/(E*math.pi*0.25**2)+((F1()+F2()+F3()+F4())*2)/(E*math.pi*0.5**2))*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.11"
    ]
  },
  {
    "objectID": "problem5_12dynamicsubmit.html",
    "href": "problem5_12dynamicsubmit.html",
    "title": "Problem 5.12",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.12"
    ]
  },
  {
    "objectID": "problem5_12dynamicsubmit.html#problem-image",
    "href": "problem5_12dynamicsubmit.html#problem-image",
    "title": "Problem 5.12",
    "section": "",
    "text": "Figure 1: Two forces are applied to the system of cylinders.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"184\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nL3=reactive.Value(\"__\")\nEsteel = 210\nEaluminum = 70\n\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of meters\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two forces, F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN, are applied to the system of cylinders as shown. If L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m, L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m, and L&lt;sub&gt;3&lt;/sub&gt; = {L3()} m, what is the total change in length of the system? Assume E&lt;sub&gt;steel&lt;/sub&gt; = {Esteel} GPa and E&lt;sub&gt;aluminum&lt;/sub&gt; = {Ealuminum} GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(100, 300, 1)/10)\n        F2.set(round(F1()/1.5, 2))\n        L1.set(random.randrange(20, 80, 1)/10)\n        L2.set(round(L1()*0.6, 2))\n        L3.set(round(L1()*0.8, 2))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n       \n        instr= (F2()*L2())/(math.pi*0.3**2*Esteel*10**9) + ((F2()-F1())*L1())/(math.pi*0.5**2*Ealuminum*10**9)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.12"
    ]
  },
  {
    "objectID": "problem5_13dynamicsubmit.html",
    "href": "problem5_13dynamicsubmit.html",
    "title": "Problem 5.13",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.13"
    ]
  },
  {
    "objectID": "problem5_13dynamicsubmit.html#problem-image",
    "href": "problem5_13dynamicsubmit.html#problem-image",
    "title": "Problem 5.13",
    "section": "",
    "text": "Figure 1: Two forces are applied to the system of cylinders.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"185\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nEbrass = 100\nEaluminum = 70\n\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two forces, F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN, are applied to the system of cylinders as shown. If L&lt;sub&gt;1&lt;/sub&gt; = {L1()} mm and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} mm, what is the total change in length of the system. Assume E&lt;sub&gt;brass&lt;/sub&gt; = {Ebrass} GPa and E&lt;sub&gt;aluminum&lt;/sub&gt; = {Ealuminum} GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(10, 100, 1)/10)\n        F2.set(round(F1()*2, 2))\n        L1.set(random.randrange(50, 150, 1))\n        L2.set(round(L1()*1.5, 2))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (((F2()-F1())*L1())/(math.pi*.002**2*Ebrass*10**6)) + (F2()*L2())/(math.pi*.003**2*Ealuminum*10**6)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.13"
    ]
  },
  {
    "objectID": "problem5_14dynamicsubmit.html",
    "href": "problem5_14dynamicsubmit.html",
    "title": "Problem 5.14",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.14"
    ]
  },
  {
    "objectID": "problem5_14dynamicsubmit.html#problem-image",
    "href": "problem5_14dynamicsubmit.html#problem-image",
    "title": "Problem 5.14",
    "section": "",
    "text": "Figure 1: A series of solid circular steel bars are loaded with three loads.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"186\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nL3=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A series of solid circular steel bars are loaded as shown, where F&lt;sub&gt;1&lt;/sub&gt; = {F1()} N, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} N, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} N. If lengths L&lt;sub&gt;1&lt;/sub&gt; = L&lt;sub&gt;2&lt;/sub&gt; = {L1()} cm and L&lt;sub&gt;3&lt;/sub&gt; = {L3()} cm, determine the total change in length of the system. Assume E&lt;sub&gt;steel&lt;/sub&gt; = 210 GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(20, 100, 1))\n        F2.set(random.randrange(20, 100, 1))\n        F3.set(random.randrange(20, 100, 1))\n        L1.set(random.randrange(20, 60, 1))\n        L2.set(L1())\n        L3.set(round(L1()*1.25, 2))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        R = F2()+F3()-F1()\n        FBC = F1()-R\n        FCD = F1()-R-F2()\n        dAB = R*L1()/100/(210*10**9*0.004**2*math.pi)\n        dBC = FBC*L2()/100/(210*10**9*0.003**2*math.pi)\n        dCD = FCD*L3()/100/(210*10**9*0.005**2*math.pi)\n        instr= abs((dAB+dBC+dCD)*10**3)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.14"
    ]
  },
  {
    "objectID": "problem5_15dynamicsubmit.html",
    "href": "problem5_15dynamicsubmit.html",
    "title": "Problem 5.15",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.15"
    ]
  },
  {
    "objectID": "problem5_15dynamicsubmit.html#problem-image",
    "href": "problem5_15dynamicsubmit.html#problem-image",
    "title": "Problem 5.15",
    "section": "",
    "text": "Figure 1: A crate is attached to a cable made from steel and aluminum.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"187\"\nW=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nA1=reactive.Value(\"__\")\nA2=reactive.Value(\"__\")\nEsteel = 29000\nEaluminum = 10000\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A crate weight W = {W()} lb is attached to a cable constructed from steel of length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. and Area A&lt;sub&gt;1&lt;/sub&gt; = {A1()} in.&lt;sup&gt;2&lt;/sup&gt; and aluminum of length L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in. and area A&lt;sub&gt;2&lt;/sub&gt; = {A2()} in.&lt;sup&gt;2&lt;/sup&gt;. What is the total deflection of the crate after it is attached to the wire? Assume E&lt;sub&gt;steel&lt;/sub&gt; = {Esteel} ksi and E&lt;sub&gt;aluminum&lt;/sub&gt; = {Ealuminum} ksi. Neglect the weight of the wires.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W.set(random.randrange(50, 250, 1))\n        L1.set(random.randrange(10, 30, 1))\n        L2.set(round(L1()*2, 2))\n        A1.set(random.randrange(1, 5, 1)/100)\n        A2.set(random.randrange(1, 5, 1)/100)\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        \n        instr=(W()*L1()/(A1()*Esteel) + (W()*L2()/(A2()*Ealuminum)))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.15"
    ]
  },
  {
    "objectID": "problem5_27dynamicsubmit.html",
    "href": "problem5_27dynamicsubmit.html",
    "title": "Problem 5.27",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.27"
    ]
  },
  {
    "objectID": "problem5_27dynamicsubmit.html#problem-image",
    "href": "problem5_27dynamicsubmit.html#problem-image",
    "title": "Problem 5.27",
    "section": "",
    "text": "Figure 1: A bar is attached to two wires, one steel and one aluminum.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"191\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nA=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEsteel = 29000\nEaluminum = 10000\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A bar is attached to two wires, one steel and one aluminum. If the lengths of the wires L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in., find the distance x that load F = {F()} kips must be placed at so that the bar remains horizontal after the load is applied. Both wires have the same cross-section area A = {A()} in.&lt;sup&gt;2&lt;/sup&gt;. Assume E&lt;sub&gt;steel&lt;/sub&gt; = 29,000 ksi, E&lt;sub&gt;aluminum&lt;/sub&gt; = 10,000 ksi and that the bar is of length {L()} in.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(50, 150, 1)/10)\n        L2.set(round(L1()*2, 2))\n        F.set(random.randrange(30, 150, 1)/10)\n        A.set(random.randrange(2, 25, 1)/100)\n        L.set(random.randrange(10, 20, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        PsPa = (L1()*Esteel*A())/(L2()*Ealuminum*A())\n        Ps = (F()/(PsPa+1))*PsPa\n        instr=(Ps*L())/F()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.27"
    ]
  },
  {
    "objectID": "problem5_34dynamicsubmit.html",
    "href": "problem5_34dynamicsubmit.html",
    "title": "Problem 5.34",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.34"
    ]
  },
  {
    "objectID": "problem5_34dynamicsubmit.html#problem-image",
    "href": "problem5_34dynamicsubmit.html#problem-image",
    "title": "Problem 5.34",
    "section": "",
    "text": "Figure 1: A copper circular rod is inserted into an aluminum tube as shown.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"192\"\nr=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\ndL=reactive.Value(\"__\")\nEcopper = 110\nEaluminum = 70\n\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A copper circular rod of radius r = {r()} cm is inserted into an aluminum tube with inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} cm and outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} cm as shown. Load P is applied to the rigid top plate. If length L = {L()} cm, what load P will cause the plate to deflect dL = {dL()} mm downward? Assume E&lt;sub&gt;copper&lt;/sub&gt; = 110 GPa and E&lt;sub&gt;aluminum&lt;/sub&gt; = 70 GPa\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        r.set(random.randrange(20, 60, 1)/10)\n        ri.set(round(r()*1.25, 2))\n        ro.set(round(r()*1.5, 2))\n        L.set(random.randrange(150, 300, 1)/10)\n        dL.set(random.randrange(10, 50, 1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr=((dL()*Ecopper*r()**2*math.pi)/L()) + ((dL()*Ealuminum*(ro()-ri())**2*math.pi)/L())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.34"
    ]
  },
  {
    "objectID": "problem5_35dynamicsubmit.html",
    "href": "problem5_35dynamicsubmit.html",
    "title": "Problem 5.35",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.35"
    ]
  },
  {
    "objectID": "problem5_35dynamicsubmit.html#problem-image",
    "href": "problem5_35dynamicsubmit.html#problem-image",
    "title": "Problem 5.35",
    "section": "",
    "text": "Figure 1: Two blocks with square cross sections are stacked and loaded at the top.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"193\"\nF=reactive.Value(\"__\")\nw1=reactive.Value(\"__\")\nw2=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEsteel = 29000\nEaluminum = 10000\n\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two blocks with square cross-sections are stacked as shown, with the top block inserted into the bottom block and subjected to load F = {F()} kips. The top block is aluminum (E = 10,000 ksi) with side length w&lt;sub&gt;1&lt;/sub&gt; = {w1()} in.  and the bottom block is steel (E = 29,000 ksi) with side length w&lt;sub&gt;2&lt;/sub&gt; = {w2()} in. If length L = {L()} in., what is the total change in length of the aluminum block? Ignore the weight of the blocks. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(20, 100, 1)/10)\n        w1.set(random.randrange(15, 50, 1)/10)\n        w2.set(round(w1()*1.5))\n        L.set(random.randrange(50, 200, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr=F()*L()*((1/((w1()**2)*Ealuminum)) + (1/((w2()**2)*Esteel)))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.35"
    ]
  },
  {
    "objectID": "problem5_36dynamicsubmit.html",
    "href": "problem5_36dynamicsubmit.html",
    "title": "Problem 5.36",
    "section": "",
    "text": "Problem Image\n{fig-alt=” Two square members are placed between two fixed walls. The wood piece is on the left and the plastic piece is on the right. Point B is at the intersection of the wood and plastic members. The members are each length L. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.36"
    ]
  },
  {
    "objectID": "problem5_36dynamicsubmit.html#problem-image",
    "href": "problem5_36dynamicsubmit.html#problem-image",
    "title": "Problem 5.36",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"246\"\nd=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEplastic=reactive.Value(\"__\")\nEwood=1750\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of lb\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two square members are attached to two fixed walls as shown. Force F is applied at point B and point B is displaced d =  {d()} in. to the right. If L = {L()} in., E&lt;sub&gt;wood&lt;/sub&gt; = 1,750 ksi, and E&lt;sub&gt;plastic&lt;/sub&gt; = {Eplastic()} ksi, determine the applied force F. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(2, 8, 1)/1000)\n        L.set(random.randrange(4, 15, 1))\n        Eplastic.set(random.randrange(350, 900, 10))\n       \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (d()*1*Ewood*1000)/5 - (-d()*4*Eplastic()*1000)/L() \n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.36"
    ]
  },
  {
    "objectID": "problem5_37dynamicsubmit.html",
    "href": "problem5_37dynamicsubmit.html",
    "title": "Problem 5.37",
    "section": "",
    "text": "Problem Image\n{fig-alt=” Two aluminum circular rods are placed between two fixed walls. Member 1 is on the left and member 2 is on the right. Member 2 has diameter d[1] and length L[1]. Member 2 has diameter d[2] and length L[2] “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.37"
    ]
  },
  {
    "objectID": "problem5_37dynamicsubmit.html#problem-image",
    "href": "problem5_37dynamicsubmit.html#problem-image",
    "title": "Problem 5.37",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"247\"\nF=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nEwood=70\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two aluminum circular rods are attached to two fixed walls as shown. Assume E = 70 MPa for both cylinders, F = {F()} kN, d&lt;sub&gt;1&lt;/sub&gt; = {d1()} mm, d&lt;sub&gt;2&lt;/sub&gt;  = {d2()} mm, L&lt;sub&gt;1&lt;/sub&gt;  = {L1()} mm, and L&lt;sub&gt;2&lt;/sub&gt;  = {L2()} mm. Determine the normal stress in member 1.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(20, 100, 1))\n        d1.set(random.randrange(15, 50, 1))\n        d2.set(round(d1()*1.5, 2))\n        L1.set(random.randrange(200, 800, 10))\n        L2.set(round(L1()*(2/3), 2))\n       \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        LHS = (L1()/100)/(math.pi*(d1()/200)**2) + (L2()/100)/(math.pi*(d2()/200)**2)\n        RHS = (F()*L2()/100)/(math.pi*(d2()/200)**2)\n        instr= (RHS/LHS)/(math.pi*(d1()/200)**2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.37"
    ]
  },
  {
    "objectID": "problem5_38dynamicsubmit.html",
    "href": "problem5_38dynamicsubmit.html",
    "title": "Problem 5.38",
    "section": "",
    "text": "Problem Image\n{fig-alt=” A pressure load is applied to a short column made of wood and concrete. Concerete is the center of the column and it is surrounded by wood. The side of the column is 3 * b, with the width of the wood, concrete, and wood each being b. The other side of the column is h[1] + h[2] + h[1], with the length of the wood being h[1] and the length of the concrete being h[2]. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.38"
    ]
  },
  {
    "objectID": "problem5_38dynamicsubmit.html#problem-image",
    "href": "problem5_38dynamicsubmit.html#problem-image",
    "title": "Problem 5.38",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"248\"\nw=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nh1=reactive.Value(\"__\")\nh2=reactive.Value(\"__\")\nEconcrete=25\nEwood=12\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A distributed load w = {w()} N/cm&lt;sup&gt;2&lt;/sup&gt; is applied to a short column made from wood and concrete. Assume E&lt;sub&gt;concrete &lt;/sub&gt;= 25 GPa, E&lt;sub&gt;wood&lt;/sub&gt; = 12 GPa, b = {b()} cm, h&lt;sub&gt;1&lt;/sub&gt; = {h1()} cm, and h&lt;sub&gt;2&lt;/sub&gt; = {h2()} cm. What load is carried by the concrete center?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(50, 750, 10))\n        b.set(random.randrange(20, 100, 1)/10)\n        h1.set(b()*1)\n        h2.set(b()*2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (2.0833*h2()*w()*(2*h1()+h2())*3*b())/(6*h1()+4.0833*h2())/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.38"
    ]
  },
  {
    "objectID": "problem5_39dynamicsubmit.html",
    "href": "problem5_39dynamicsubmit.html",
    "title": "Problem 5.39",
    "section": "",
    "text": "Problem Image\n{fig-alt=” A concrete post with 6 steel rebar rods embedded in the concrete supports a load, F. The post has diamete d[c] and the rebar rods have diamete d[s]. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.39"
    ]
  },
  {
    "objectID": "problem5_39dynamicsubmit.html#problem-image",
    "href": "problem5_39dynamicsubmit.html#problem-image",
    "title": "Problem 5.39",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"250\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\ndc=reactive.Value(\"__\")\nds=reactive.Value(\"__\")\nEconcrete=25\nEsteel=200\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A concrete post of length L = {L()}  m and diameter d&lt;sub&gt;c&lt;/sub&gt; = {dc()} mm supports a load F = {F()} kN. The concrete is reinforced with 6 steel rods of diameter d&lt;sub&gt;s&lt;/sub&gt; = {ds()} mm. Assume Econcrete = 25 GPa and Esteel = 200 GPa. Determine the stress in the concrete.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10, 50, 1)/10)\n        dc.set(random.randrange(100, 500, 10))\n        ds.set(round(dc()/12,2))\n        F.set(random.randrange(100, 500, 10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        As = (math.pi*6*(ds()/20)**2)\n        Ac = (math.pi*(dc()/20)**2) - As\n        Cside = Ac*Econcrete\n        Sside = As*Esteel\n        LHS = F()*Cside\n        RHS = Cside+Sside\n        instr= ((LHS/RHS)/(Ac/100**2))/10**3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.39"
    ]
  },
  {
    "objectID": "problem5_50dynamicsubmit.html",
    "href": "problem5_50dynamicsubmit.html",
    "title": "Problem 5.50",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.50"
    ]
  },
  {
    "objectID": "problem5_50dynamicsubmit.html#problem-image",
    "href": "problem5_50dynamicsubmit.html#problem-image",
    "title": "Problem 5.50",
    "section": "",
    "text": "Figure 1: A solid circular bar is between two fixed walls.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"222\"\nstress=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nE=29000\nalpha=6.5*10**-6\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The axial stress in a solid circular bar between two fixed walls is {stress()} ksi. Find the temperature change necessary to relieve the stress. Assume L = {L()} in., E = 29,000 ksi, and alpha = 6.5 x 10&lt;sup&gt;-6&lt;/sup&gt; / °F. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        stress.set(random.randrange(10, 150, 5))\n        L.set(random.randrange(15, 75, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= stress()/(alpha*E)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.50"
    ]
  },
  {
    "objectID": "problem5_51dynamicsubmit.html",
    "href": "problem5_51dynamicsubmit.html",
    "title": "Problem 5.51",
    "section": "",
    "text": "Problem Image\n{fig-alt=” A weight is placed on a tall brass bar. The brass bar has a circular cross section of diameter d. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.51"
    ]
  },
  {
    "objectID": "problem5_51dynamicsubmit.html#problem-image",
    "href": "problem5_51dynamicsubmit.html#problem-image",
    "title": "Problem 5.51",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"223\"\nW=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nTC=reactive.Value(\"__\")\nE=100*10**9\nalpha=10*10**-6\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The W = {W()} kg weight is placed on a L = {L()} m tall brass bar with a cross section of d = {d()} cm. If the bar undergoes a temperature change of {TC()} °C, what is the total deformation of the bar? Assume the Young's Modulus and thermal coefficient of expansion is 100 GPa and 10 x 10&lt;sup&gt;-6&lt;/sup&gt; / °C, respectively. Also, assume no buckling. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W.set(random.randrange(500, 2000, 100))\n        L.set(random.randrange(10, 50, 1)/10)\n        d.set(random.randrange(15, 40, 1)/10)\n        TC.set(random.randrange(20, 150, 5))\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        deltaT = L()*alpha*TC()\n        deltaM = (W()*9.81*L())/(E*math.pi*(d()/2)**2)\n        instr= deltaT - deltaM\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.51"
    ]
  },
  {
    "objectID": "problem5_52dynamicsubmit.html",
    "href": "problem5_52dynamicsubmit.html",
    "title": "Problem 5.52",
    "section": "",
    "text": "Problem Image\n{fig-alt=” Two cylindrical rods are connected and heated until they expand to close the gap to the wall on the right hand side. The left hand side is fixed. Rod A is attached to the wall on the left hand side. Rod B is attached to Rod A. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.52"
    ]
  },
  {
    "objectID": "problem5_52dynamicsubmit.html#problem-image",
    "href": "problem5_52dynamicsubmit.html#problem-image",
    "title": "Problem 5.52",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"224\"\nd=reactive.Value(\"__\")\nrA=reactive.Value(\"__\")\nrB=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nalphaA=6*10**-6\nalphaB=10*10**-6\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of °F\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two cylindrical rods are heated until they expand, just closing the gap of d = {d()} in. The coefficient of thermal expansion, α, for material A and B is 6 x 10&lt;sup&gt;-6&lt;/sup&gt;/°F and 10 x 10&lt;sup&gt;-6&lt;/sup&gt;/°F, respectively. The radius of A r&lt;sub&gt;A&lt;/sub&gt; = {rA()} in and the length is L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. The radius of B is r&lt;sub&gt;B&lt;/sub&gt; = {rB()} in and the length is L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in. What is the change in temperature.  \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(1, 20, 1)/100)\n        rA.set(random.randrange(5, 20, 1)/10)\n        rB.set(round(rA()*1.6, 2))\n        L1.set(random.randrange(5, 20, 1))\n        L2.set(round(L1()*0.6, 2))\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= d()/(alphaA*L1()+alphaB*L2())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.52"
    ]
  },
  {
    "objectID": "problem5_53dynamicsubmit.html",
    "href": "problem5_53dynamicsubmit.html",
    "title": "Problem 5.53",
    "section": "",
    "text": "Problem Image\n{fig-alt=” Three cylindrical rods are rigidly connected togehter with a load applied to the free end. The left hand side is connected to the wall and is attached to rod A. Rod B is attached to rod A on the left and rod C on the right. The load is applied to the free end of rod C. The diameter of rod A is 3 cm, the diameter of rod B is 1 cm, and the diameter of rod C is 2 cm.”}",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.53"
    ]
  },
  {
    "objectID": "problem5_53dynamicsubmit.html#problem-image",
    "href": "problem5_53dynamicsubmit.html#problem-image",
    "title": "Problem 5.53",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"225\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nL3=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\ndT=reactive.Value(\"__\")\nalphaA=10*10**-6\nalphaB=5*10**-6\nalphaC=7*10**-6\nEA=40*10**9\nEB=120*10**9\nEC=80*10**9\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Three cylindrical rods of lengths L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m, L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m, and L&lt;sub&gt;3&lt;/sub&gt; = {L3()} m are connected together. A force F = {F()} kN is applied to the free end and all three rods are heated by {dT()} °C. The coefficient of thermal expansion, α, and elastic modulus, E, for each material are α&lt;sub&gt;A&lt;/sub&gt; = 10 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C, α&lt;sub&gt;B&lt;/sub&gt; = 5 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C, α&lt;sub&gt;C&lt;/sub&gt; = 7 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C, E&lt;sub&gt;A&lt;/sub&gt; = 40 GPa, E&lt;sub&gt;B&lt;/sub&gt; = 120 GPa, and E&lt;sub&gt;C&lt;/sub&gt; = 80 GPa. What is the total deflection of the right rod tip?  \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(10, 40, 1)/10)\n        L2.set(round(L1()*0.8))\n        L3.set(round(L1()*(2/3)))\n        F.set(random.randrange(5, 50, 1))\n        dT.set(random.randrange(100, 300, 10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        deltaL = (F()*L1()/100)/(EA*math.pi*.015**2) + (F()*L2()/100)/(EB*math.pi*.005**2) + (F()*L3()/100)/(EC*math.pi*.01**2)\n        deltaT = alphaA*dT()*L1()/100 + alphaB*dT()*L2()/100 + alphaC*dT()*L3()/100 \n        instr= deltaL + deltaT\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.53"
    ]
  },
  {
    "objectID": "problem5_54dynamicsubmit.html",
    "href": "problem5_54dynamicsubmit.html",
    "title": "Problem 5.54",
    "section": "",
    "text": "Problem Image\n{fig-alt=” A long square brass bar is placed between two fixed walls. The bar has length L. The cross section is square with sides h. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.54"
    ]
  },
  {
    "objectID": "problem5_54dynamicsubmit.html#problem-image",
    "href": "problem5_54dynamicsubmit.html#problem-image",
    "title": "Problem 5.54",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"226\"\nT1=reactive.Value(\"__\")\nT2=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nalpha=20*10**-6\nE=100*10**9\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A long square brass bar is placed between two fixed walls and heated from {T1()} °C to {T2()} °C. If L = {L()} mm, h = {h()} mm, E = 100 GPa, and α = 20 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C, determine the stress in the bar.  \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T1.set(random.randrange(5, 20, 1))\n        T2.set(round(T1() + random.randrange(20, 50, 1), 2))\n        L.set(random.randrange(250, 750, 10))\n        h.set(random.randrange(10, 30, 1))\n       \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (E*alpha*(T2()-T1()))/10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.54"
    ]
  },
  {
    "objectID": "problem5_55dynamicsubmit.html",
    "href": "problem5_55dynamicsubmit.html",
    "title": "Problem 5.55",
    "section": "",
    "text": "Problem Image\n{fig-alt=” Two bars are pinned at joint B between two walls. Joint AB is on the left hand side and joint BC is on the right hand side. Both bars are length L and thickness t and height h. The diameter of the bolt holding them together is d. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.55"
    ]
  },
  {
    "objectID": "problem5_55dynamicsubmit.html#problem-image",
    "href": "problem5_55dynamicsubmit.html#problem-image",
    "title": "Problem 5.55",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"249\"\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\ndT=reactive.Value(\"__\")\nE=200\nv=0.32\na=11.7*10**-6\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Bars AB and BC are pinned at joint B. Both bars are made from the same material with E = 200 GPa, v = 0.32, and a = 11.7 x 10&lt;sup&gt;-6&lt;/sup&gt; /°C. Dimensions L = {L()}  mm, t = {t()} mm, h = {h()} mm, and d = {d()} mm. If both bars are heated by {dT()} °C, determine the shear stress generated in the pin at B.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(300, 900, 10))\n        t.set(random.randrange(30, 80, 1))\n        h.set(t()/2)\n        d.set(round(t()/3,2))\n        dT.set(random.randrange(10, 40, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        deltaM = a*dT()*(t()/1000)*(h()/1000)*E*10**9\n        instr= (deltaM/(math.pi*(d()/2000)**2))/10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 5.55"
    ]
  },
  {
    "objectID": "problem6_1dynamicsubmit.html",
    "href": "problem6_1dynamicsubmit.html",
    "title": "Problem 6.1",
    "section": "",
    "text": "Problem Image\n{fig-alt=” A bar is fixed to a wall at one end. The bar has diameter d. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.1"
    ]
  },
  {
    "objectID": "problem6_1dynamicsubmit.html#problem-image",
    "href": "problem6_1dynamicsubmit.html#problem-image",
    "title": "Problem 6.1",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"265\"\nT=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN-m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"What torque is required to create a maximum shear stress of τ = {T()} MPa in a solid circular bar of diameter d  = {d()} mm? .\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T.set(random.randrange(20, 50, 1))\n        d.set(random.randrange(50, 200, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        J = (math.pi/2)*(d()/2000)**4\n        instr= (T()*1000*J)/(d()/2000)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.1"
    ]
  },
  {
    "objectID": "problem6_2dynamicsubmit.html",
    "href": "problem6_2dynamicsubmit.html",
    "title": "Problem 6.2",
    "section": "",
    "text": "Problem Image\n{fig-alt=” A hand crank is attached to the wall. Member AB is attached the wall and member CD is where the force is applied. AB and CD are length L and BC has length y. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.2"
    ]
  },
  {
    "objectID": "problem6_2dynamicsubmit.html#problem-image",
    "href": "problem6_2dynamicsubmit.html#problem-image",
    "title": "Problem 6.2",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"267\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\ny=reactive.Value(\"__\")\nd=(reactive.Value(\"__\"))\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A force F = {F()} lb is applied to a hand crank that is stuck and will not turn. If L = {L()} in. and y = {y()} in., determine the maximum shear stress due to torsion in the crank rod between A and B. Assume the crank has diameter d = {d()} in. .\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(100, 750, 10))\n        L.set(random.randrange(100, 200, 1)/10)\n        y.set(round(L()/2, 2))\n        d.set(random.randrange(3, 15, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        T = F()*y()\n        J = (math.pi/2)*(d()/2)**4\n        instr= ((T*d()/2)/J)/10**3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.2"
    ]
  },
  {
    "objectID": "problem6_3dynamicsubmit.html",
    "href": "problem6_3dynamicsubmit.html",
    "title": "Problem 6.3",
    "section": "",
    "text": "Problem Image\n{fig-alt=” A torque is applied two part circular rod, with one end attached to the wall. The part attached to the wall has diameter d[1] and length 40 in. T[1] is applied at the intersection of the rods. The second rod has diameter d[2] and length 30 in. T[2] is applied at the free end. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.3"
    ]
  },
  {
    "objectID": "problem6_3dynamicsubmit.html#problem-image",
    "href": "problem6_3dynamicsubmit.html#problem-image",
    "title": "Problem 6.3",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"273\"\nT1=reactive.Value(\"__\")\nT2=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two torques are applied to a two part circular rod as shown. If T&lt;sub&gt;1&lt;/sub&gt; = {T1()} kip-in., T&lt;sub&gt;2&lt;/sub&gt; = {T2()} kip-in., d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in., and d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in., what is the magnitude of the maximum shear stress?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T1.set(random.randrange(5, 50, 1))\n        T2.set(T1()*random.randrange(3, 5, 1)/10)\n        d1.set(random.randrange(40, 80, 1)/10)\n        d2.set(round(d1()*0.8, 2))\n        \n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        F1 = -T1()+T2()\n        F2 = T2()\n        J1 = (math.pi/2)*(d1()/2)**4\n        J2 = (math.pi/2)*(d2()/2)**4\n        instr= (-1*F1*(d1()/2)/J1)*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.3"
    ]
  },
  {
    "objectID": "problem6_4dynamicsubmit.html",
    "href": "problem6_4dynamicsubmit.html",
    "title": "Problem 6.4",
    "section": "",
    "text": "Problem Image\n{fig-alt=” Three belt pullets are connected to a solid shaft. The shaft is dixed at points A and E. F[1] is applied at the first pulley, or point B. F[2] is applied at the second pulley or point C. F[3] is applied at the third pulley or point D. The shaft has diameter d. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.4"
    ]
  },
  {
    "objectID": "problem6_4dynamicsubmit.html#problem-image",
    "href": "problem6_4dynamicsubmit.html#problem-image",
    "title": "Problem 6.4",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"276\"\nd=reactive.Value(\"__\")\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Three belt pulleys are connected to a solid circular shaft of diameter d = {d()} in. that rotates freely at joints A and E. The pulleys are subjected to forces F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kips, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kips, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} kips. What is the maximum shear stress in the shaft between pulleys B and C?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(20, 40, 1)/10)\n        F1.set(random.randrange(20, 200, 2)/10)\n        F2.set(F1()/2)\n        F3.set(round(F1()*0.9, 2))\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        T = 6*F1()\n        instr= (T*(d()/2))/((math.pi/2)*(d()/2)**4)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.4"
    ]
  },
  {
    "objectID": "problem6_5dynamicsubmit.html",
    "href": "problem6_5dynamicsubmit.html",
    "title": "Problem 6.5",
    "section": "",
    "text": "Problem Image\n{fig-alt=” Two torques are applied to a hollow piped attached to the wall. The pipe has inner radius r[i] and outer radius r[o]. The torque T[B] is applied at a distance L from the wall. The torque T[C] is applied at a distance L from T[B] at the free end. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.5"
    ]
  },
  {
    "objectID": "problem6_5dynamicsubmit.html#problem-image",
    "href": "problem6_5dynamicsubmit.html#problem-image",
    "title": "Problem 6.5",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"278\"\nro=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\nTB=reactive.Value(\"__\")\nTC=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two torques ,T&lt;sub&gt;B&lt;/sub&gt; = {TB()} kip-ft and T&lt;sub&gt;C&lt;/sub&gt; = {TC()} kip-ft, are applied to the hollow pipe as shown. If L = {L()} ft., r&lt;sub&gt;o&lt;/sub&gt; = {ro()} in., and r&lt;sub&gt;i&lt;/sub&gt; = {ri()} in., determine the maximum shear stress in the pipe.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        TB.set(random.randrange(500, 5000, 100))\n        TC.set(TB()/2)\n        L.set(random.randrange(10, 90, 1)/10)\n        ro.set(random.randrange(15, 60, 1)/10)\n        ri.set(round(ro()*0.8))\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Tmax = TB()-TC()\n        J = (math.pi/2)*(ro()**4 - ri()**4)\n        instr= (Tmax*ro())/J\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.5"
    ]
  },
  {
    "objectID": "problem6_11dynamicsubmit.html",
    "href": "problem6_11dynamicsubmit.html",
    "title": "Problem 6.11",
    "section": "",
    "text": "Problem Image\n{fig-alt=” A hollow copper rod is fixed to a wall at one end and a torque is applied. The rod has an outer diameter of d[o] and inner diameter of d[i] and length L. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.11"
    ]
  },
  {
    "objectID": "problem6_11dynamicsubmit.html#problem-image",
    "href": "problem6_11dynamicsubmit.html#problem-image",
    "title": "Problem 6.11",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"266\"\nL=reactive.Value(\"__\")\ndo=reactive.Value(\"__\")\ndi=reactive.Value(\"__\")\nangle=(reactive.Value(\"__\"))\nE = 110\nv = 0.33\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN-m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A hollow copper rod (E = 110 GPa, v = 0.33) is subjected to torque T as shown. If length L = {L()} m, outer diameter d&lt;sub&gt;o&lt;/sub&gt; = {do()} mm, and inner diameter d&lt;sub&gt;i&lt;/sub&gt; = {di()} mm, determine torque T if the rod twists {angle()}° .\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(5, 30, 1)/10)\n        do.set(random.randrange(50, 200, 1))\n        di.set(round(do()/2, 2))\n        angle.set(random.randrange(1, 10, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        G = E*10**9/(2*(1+v))\n        J = (math.pi/2)*((do()/2000)**4 -(di()/2000)**4 )\n        instr= ((math.radians(angle())*G*J)/L())/10**3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.11"
    ]
  },
  {
    "objectID": "problem6_12dynamicsubmit.html",
    "href": "problem6_12dynamicsubmit.html",
    "title": "Problem 6.12",
    "section": "",
    "text": "Problem Image\n{fig-alt=” A bar is attached to a wall. The bar has an inner diameter of 1 in and outer diameter of 2 in. Torque, T[1] is applied halfway down the bar. The bar length is 10 in total. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.12"
    ]
  },
  {
    "objectID": "problem6_12dynamicsubmit.html#problem-image",
    "href": "problem6_12dynamicsubmit.html#problem-image",
    "title": "Problem 6.12",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"268\"\nT1=reactive.Value(\"__\")\nangle=reactive.Value(\"__\")\nG=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ft-lb\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A bar with a shear modulus G = {G()} x 10&lt;sup&gt;6&lt;/sup&gt; psi is subjected to torques T&lt;sub&gt;1&lt;/sub&gt; = {T1()} lb-ft at its center and T&lt;sub&gt;2&lt;/sub&gt; at its free end. The inner diamter is 1 in and the outer diameter is 2 in and the total length of the bar is 10 in. If the rotation of the rod at its free end is Θ =  {angle()} ° clockwise, what is the magnitude of torque T&lt;sub&gt;2&lt;/sub&gt;?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        G.set(random.randrange(90, 130, 1)/10)\n        T1.set(random.randrange(1000, 5000, 100))\n        angle.set(random.randrange(10, 50, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        ro = 2/2\n        ri = 1/2\n        J = math.pi/2*(ro**4-ri**4)\n        L1 = 10/2\n        L2 = 10/2\n        instr= abs((angle()*math.pi/180**G()*10**6*J-T1()*12*L1)/L2/12)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.12"
    ]
  },
  {
    "objectID": "problem6_13dynamicsubmit.html",
    "href": "problem6_13dynamicsubmit.html",
    "title": "Problem 6.13",
    "section": "",
    "text": "Problem Image\n{fig-alt=” A system of cylinders are attached to the wall at one end. The first torque is applied at the connection of the cylidner attached to the wall made of steel with the cylinder made of aluminum. The second torque is applied at the connection between the cylinder made of aluminum and the second cylinder made of steel. The third torque is applied at the free end. The first cyliner has length 10 cm and diamter 5 cm. The second cyliner has length 15 cm and diamter 3 cm. The third cyliner has length 8 cm and diamter 4 cm. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.13"
    ]
  },
  {
    "objectID": "problem6_13dynamicsubmit.html#problem-image",
    "href": "problem6_13dynamicsubmit.html#problem-image",
    "title": "Problem 6.13",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"269\"\nT1=reactive.Value(\"__\")\nT2=reactive.Value(\"__\")\nT3=reactive.Value(\"__\")\nEs=77\nEa=27\nvs=0.3\nva=0.33\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of degrees\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Three moments are applied to the system of cylinders as shown. Assume T&lt;sub&gt;1&lt;/sub&gt; = {T1()} kN-m, T&lt;sub&gt;2&lt;/sub&gt; = {T2()} kN-m, and T&lt;sub&gt;3&lt;/sub&gt; = {T3()} kN-m. If E&lt;sub&gt;steel&lt;/sub&gt; = 77 GPa and E&lt;sub&gt;aluminum&lt;/sub&gt; = 27 GPa, determine the total angle of twist at the free end.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T1.set(random.randrange(20, 100, 1)/10)\n        T2.set(T1()+random.randrange(20, 100, 1)/10)\n        T3.set(round(T2()*random.randrange(5, 8, 1)/10, 2))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        F1 = T1()+T2()-T3()\n        F2 = T2()-T3()\n        F3 = -T3()\n        J1 = (math.pi/2)*((5/200)**4)\n        J2 = (math.pi/2)*((3/200)**4)\n        J3 = (math.pi/2)*((4/200)**4)\n        Gs = Es/(2*(1+vs))\n        Ga = Ea/(2*(1+va))\n        instr= ((T1()*1000*.1)/(J1*Gs*10**9) + (T2()*1000*.15)/(J2*Ga*10**9) + (T3()*1000*.08)/(J3*Gs*10**9))*180/math.pi\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.13"
    ]
  },
  {
    "objectID": "problem6_14dynamicsubmit.html",
    "href": "problem6_14dynamicsubmit.html",
    "title": "Problem 6.14",
    "section": "",
    "text": "Problem Image\n{fig-alt=” A circular rod is attached to a wall. The rod has length L and an inner radius r[i] and outer radius r[o]. The torque is apllied at the free end. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.14"
    ]
  },
  {
    "objectID": "problem6_14dynamicsubmit.html#problem-image",
    "href": "problem6_14dynamicsubmit.html#problem-image",
    "title": "Problem 6.14",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"270\"\nL=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\nT=reactive.Value(\"__\")\nG=reactive.Value(\"__\")\nstress=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of cm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A circular rod of length L = {L()} mm, outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} mm, and unknown inner radius r&lt;sub&gt;i&lt;/sub&gt; has a shear modulus G = {G()} GPa. The rod is subjected to torque T = {T()} kN-m at the free end. If the angle of twist must not exceed 2° and the shear stress must not exceed {stress()} MPa, what is the minimum required inner radius?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(250, 500, 10))\n        ro.set(random.randrange(30, 75, 1))\n        G.set(random.randrange(60, 100, 1))\n        T.set(random.randrange(10, 100, 1)/10)\n        stress.set(random.randrange(75, 150, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        r1= ((ro()/10)**4-(2*T()*1000*ro()/1000/(math.pi*stress()*10**6)))**0.25\n        r2 = ((ro()/1000)**4-(2*T()*1000*L()/1000/(math.pi*G()*10**9*2*math.pi/180)))**0.25*100\n        if r1&gt;r2:\n            instr = r2\n        else:\n            instr = r1\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.14"
    ]
  },
  {
    "objectID": "problem6_15dynamicsubmit.html",
    "href": "problem6_15dynamicsubmit.html",
    "title": "Problem 6.15",
    "section": "",
    "text": "Problem Image\n{fig-alt=” A hollow circualr rod is attached to a wall and subjected to a torque at the free end. The rod has inner diameter 8 cm and outer diameter 10 cm. The rod is length, L. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.15"
    ]
  },
  {
    "objectID": "problem6_15dynamicsubmit.html#problem-image",
    "href": "problem6_15dynamicsubmit.html#problem-image",
    "title": "Problem 6.15",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"274\"\nT=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\nG=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of degrees\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A hollow circular rod is attached to a wall and subjected to a torque T = {T()} kN-m at the free end.The rod has inner diameter 8 cm and outer diameter 10 cm.  Determine the angle of twist at x = {x()} mm. Assume G = {G()} GPa and L = {L()} mm.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T.set(random.randrange(20, 200, 1)/10)\n        G.set(random.randrange(30, 60, 1))\n        L.set(random.randrange(300, 800, 10))\n        x.set(L()*random.randrange(2,7,1)/10)\n        \n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        J = (math.pi/2)*((10/200)**4 - (8/200)**4)\n        angle = (T()*1000*x()/1000)/(G()*10**9*J)\n        instr= math.degrees(angle)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.15"
    ]
  },
  {
    "objectID": "problem6_27dynamicsubmit.html",
    "href": "problem6_27dynamicsubmit.html",
    "title": "Problem 6.27",
    "section": "",
    "text": "Problem Image\n{fig-alt=” A steel rod is attached between two walls. The load is applied to a perpendicular rod at a distance L from the steel rod. The steel rod has diameter d, the distance between the AB is 40 cm, and the distance between BC is 30 cm. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.27"
    ]
  },
  {
    "objectID": "problem6_27dynamicsubmit.html#problem-image",
    "href": "problem6_27dynamicsubmit.html#problem-image",
    "title": "Problem 6.27",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"287\"\nL=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nG = 75\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A steel rod of diameter d = {d()} mm is attached to walls A and C as shown. Two forces F = {F()} kN are applied at distance L = {L()} mm. If the shear modulus of the rod G = 75 GPa, determine the maximum shear stress in the rod.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(20, 60, 1))\n        F.set(random.randrange(2, 20, 1))\n        L.set(random.randrange(80, 120, 1))\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        TB = 2*F()*L()\n        J = (math.pi/2)*(d()/2000)**4\n        TA = 0.3/(0.7*TB)\n        TC = TB-TA\n        instr= ((TC*(d()/2000))/J)/10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.27"
    ]
  },
  {
    "objectID": "problem6_28dynamicsubmit.html",
    "href": "problem6_28dynamicsubmit.html",
    "title": "Problem 6.28",
    "section": "",
    "text": "Problem Image\n{fig-alt=” A composite circular rod is made from two different plastics. A torque is applied at the midpoint. One end is fixed to the wall. The length of each half of rod is L. The inner material is material 1 and the outer material is material 2. The inner radius is 2 cm and the outer radius is 3 cm. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.28"
    ]
  },
  {
    "objectID": "problem6_28dynamicsubmit.html#problem-image",
    "href": "problem6_28dynamicsubmit.html#problem-image",
    "title": "Problem 6.28",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"288\"\nT=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nG1=reactive.Value(\"__\")\nG2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A composite circular rod is made from two different plastics. A torque of T = {T()} kN-m is applied at the midpoint. The right end is free. What is the maximum stress in either material? Assume length L = {L()} cm and the shear modulus of the two materials are G&lt;sub&gt;1&lt;/sub&gt; = {G1()} GPa and G&lt;sub&gt;2&lt;/sub&gt; = {G2()} GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T.set(random.randrange(10, 200, 1)/10)\n        L.set(random.randrange(10, 50, 1))\n        G1.set(random.randrange(20, 50, 2)/10)\n        G2.set(G1()/2)\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        J1 = (math.pi/2)*(2/100)**4\n        J2 = (math.pi/2)*((3/100)**4-(2/100)**4)\n        RHS = G1()*10**9*J1+G2()*10**9*J2\n        LHS = T()*G2()*10**9*J2\n        T2 = LHS/RHS\n        T1 = T()-T2\n        instr= ((T1*(2/100))/J1)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.28"
    ]
  },
  {
    "objectID": "problem6_30dynamicsubmit.html",
    "href": "problem6_30dynamicsubmit.html",
    "title": "Problem 6.30",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.30"
    ]
  },
  {
    "objectID": "problem6_30dynamicsubmit.html#problem-image",
    "href": "problem6_30dynamicsubmit.html#problem-image",
    "title": "Problem 6.30",
    "section": "",
    "text": "Figure 1: A shaft made of two different materials is fixed between two walls.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"292\"\nT=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nGn = 11.4e6\nGa = 4e6\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A shaft is fixed between two walls. One portion is made from nickel (G&lt;sub&gt;nickel&lt;/sub&gt; = 11.4 x 10&lt;sup&gt;6&lt;/sup&gt; psi) with a diameter of d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in. The other portion is aluminum (G&lt;sub&gt;aluminum&lt;/sub&gt; = 4 x 10&lt;sup&gt;6&lt;/sup&gt; psi) with a diameter of d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in. A torque T = {T()} lb-ft is applied at the point where the two materials meet. If lengths L&lt;sub&gt;1&lt;/sub&gt; = {L1()} ft and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} ft, what is the maximum shear stress in the shaft?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d1.set(random.randrange(10, 60, 1)/10)\n        d2.set(round(d1()*2, 2))\n        T.set(random.randrange(500, 2000, 100))\n        L1.set(random.randrange(4, 20, 2))\n        L2.set(L1()/2)\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Jn = (math.pi/2)*(d1()/2)**4\n        Ja = (math.pi/2)*(d2()/2)**4\n        RHS = (12*L2()*Gn*Jn)/(12*L1()*Ga*Ja)\n        Ta = (12*T())/(RHS+1)\n        instr= (Ta*d2()/2)/Ja\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.30"
    ]
  },
  {
    "objectID": "problem6_31dynamicsubmit.html",
    "href": "problem6_31dynamicsubmit.html",
    "title": "Problem 6.31",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.31"
    ]
  },
  {
    "objectID": "problem6_31dynamicsubmit.html#problem-image",
    "href": "problem6_31dynamicsubmit.html#problem-image",
    "title": "Problem 6.31",
    "section": "",
    "text": "Figure 1: Two steel circular rods are firmly welded together and attached between two walls.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"293\"\nT=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nG = 80\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two steel (G = 80 GPa) circular rods are firmly welded together and attached between two walls. Assume d&lt;sub&gt;1&lt;/sub&gt; = {d1()} mm, d&lt;sub&gt;2&lt;/sub&gt; = {d2()} mm, and L  = {L()} mm. A torque T = {T()} N-m is applied at the welded joint as shown. What is the highest stress in either rod?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d1.set(random.randrange(20, 50, 1))\n        d2.set(round(d1()*.8, 2))\n        L.set(random.randrange(100, 800, 10))\n        T.set(random.randrange(10, 300, 5))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        J1 = (math.pi/2)*(d1()/2000)**4\n        J2 = (math.pi/2)*(d2()/2000)**4\n        RHS = J1/J2\n        Tb = (T()/(RHS+1))\n        Ta = T() - Tb\n        instr= ((Tb*d1()/2000)/J1)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 6.31"
    ]
  },
  {
    "objectID": "problem7_1dynamicsubmit.html",
    "href": "problem7_1dynamicsubmit.html",
    "title": "Problem 7.1",
    "section": "",
    "text": "Problem Image\n{fig-alt=” A beam is subjected to a distributed load, w between A and B. A force, F, is applied at C. The distance between A and B is 6ft and the distance between B and C is 2 ft. Section a-a is 3 ft from A. “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 7.1"
    ]
  },
  {
    "objectID": "problem7_1dynamicsubmit.html#problem-image",
    "href": "problem7_1dynamicsubmit.html#problem-image",
    "title": "Problem 7.1",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"305\"\nw = reactive.Value(\"__\")\nF = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your internal shear force answer in units of lb\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your moment answer in units of lb-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A beam is subjected to the loading shown, where w = {w()} lb/ft and F = {F()} lb. Determine the internal shear force and bending moment at section a-a.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(5, 150, 5))\n        F.set(random.randrange(300, 750, 10))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        Ay = (F()*2 - w()*6*3) / -6\n        instr1 = Ay - w()*3\n        instr2 = Ay*3 - w()*3*1.5\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.001)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.001)\n        \n        if correct1 and correct2:\n            check = \"Both answers are correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct' if correct2 else 'incorrect'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check} For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 7.1"
    ]
  },
  {
    "objectID": "problem7_2dynamicsubmit.html",
    "href": "problem7_2dynamicsubmit.html",
    "title": "Problem 7.2",
    "section": "",
    "text": "Problem Image",
    "crumbs": [
      "List of Working Problems",
      "Problem 7.2"
    ]
  },
  {
    "objectID": "problem7_2dynamicsubmit.html#problem-image",
    "href": "problem7_2dynamicsubmit.html#problem-image",
    "title": "Problem 7.2",
    "section": "",
    "text": "Figure 1: A beam is subjected to a triangular load as shown.\n\n\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"306\"\nw=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN-m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is subjected to the loading shown, where w = {w()} kN/m and L = {L()} m. What is the internal bending moment at section a-a at x = {x()} m?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(20, 200, 1)/20)\n        L.set(random.randrange(20, 50, 2)/10)\n        x.set(L()/2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= w()*L()*x()-w()*L()**2-w()*x()**3/(6*L())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.001):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}. For reference in debugging this, the calculated instructor answer is {instr}\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 7.2"
    ]
  },
  {
    "objectID": "problem7_3dynamicsubmit.html",
    "href": "problem7_3dynamicsubmit.html",
    "title": "Problem 7.3",
    "section": "",
    "text": "Problem Image\n{fig-alt=” unsure how to describe “}",
    "crumbs": [
      "List of Working Problems",
      "Problem 7.3"
    ]
  },
  {
    "objectID": "problem7_3dynamicsubmit.html#problem-image",
    "href": "problem7_3dynamicsubmit.html#problem-image",
    "title": "Problem 7.3",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"309\"\nF1 = reactive.Value(\"__\")\nF2 = reactive.Value(\"__\")\nF3 = reactive.Value(\"__\")\nΘ = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your internal shear force answer in units of lb\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your moment answer in units of lb-in\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"Three loads are applied to the structure as shown, where F&lt;sub&gt;1&lt;/sub&gt; = {F1()} lb., F&lt;sub&gt;2&lt;/sub&gt; = {F2()} lb., and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} lb applied at an angle Θ = {Θ()} °. Determine the internal shear force and bending moment at section aa.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(10, 30, 1))\n        F2.set(random.randrange(10, 30, 1))\n        F3.set(random.randrange(10, 30, 1))\n        Θ.set(random.randrange(45, 55, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = -F3() + F3()*math.sin(math.radians(Θ()))\n        instr2 = 2*F1() - 2*F2() - 4*F3()*math.sin(math.radians(Θ()))\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.001)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.001)\n        \n        if correct1 and correct2:\n            check = \"Both answers are correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct' if correct2 else 'incorrect'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check} For reference in debugging this, the calculated instructor answers are {instr1} and {instr2}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "List of Working Problems",
      "Problem 7.3"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "1  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Summary</span>"
    ]
  }
]