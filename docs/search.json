[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Problem Set for Strength of Materials",
    "section": "",
    "text": "Welcome to the Problem Set for Strength of Materials",
    "crumbs": [
      "Welcome to the Problem Set for Strength of Materials"
    ]
  },
  {
    "objectID": "index.html#how-to-use-this-resource",
    "href": "index.html#how-to-use-this-resource",
    "title": "Problem Set for Strength of Materials",
    "section": "How to Use This Resource",
    "text": "How to Use This Resource\nNote: This version of the problem set is a review copy for in-class piloting. This is not the final, published version of the problem set.\nThe navigation bar of this site will allow you to browse to the specific problems you want to view and solve. The Problem Submission App enables you to create your own unique problem used to solve homework problems. Once your problem is generated, you will be able to submit an answer to the problem and receive instantaneous right/wrong feedback before attempting another solution. At the end of your work, you can download a file log of your submissions to share with your instructor. The problem generation process is based on the ID number you use and so if you attempt the problem from a different computer or at a different time, the variables generated for you will be stable across these runs. However, the log downloader is specific to your current session and so attempting the problem across devices does not save attempt across devices\nAdditionally, there are versions of the problems with fixed variables that do not use the Problem Submission App. These are available to you also in the sidebar should you want a more traditional textbook listing of problems.\nIf you have any questions or issues while using this system, you are encouraged to contact your instructor and they will help work through the issues with the developers.",
    "crumbs": [
      "Welcome to the Problem Set for Strength of Materials"
    ]
  },
  {
    "objectID": "index.html#copyright-information",
    "href": "index.html#copyright-information",
    "title": "Problem Set for Strength of Materials",
    "section": "Copyright Information",
    "text": "Copyright Information\n¬©2024. James Lord and Jacob Grohs, eds., Problem Set for Strength of Materials is licensed under a Creative Commons Attribution NonCommercial ShareAlike 4.0 International License, except where otherwise noted.¬†\nYou are free to copy, share, adapt, remix, transform, and build on the material for any purpose as long as you follow the terms of the license: https://creativecommons.org/licenses/by-nc-sa/4.0.¬†\nYou must:¬†\n\nAttribute‚ÄîYou must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.\nShareAlike ‚Äî If you remix, transform, or build upon the material, you must distribute your contributions under the same licenseas the original.\n\nYou may not:¬†\n\nNonCommercial ‚Äî You may not use the material for commercial purposes.\nAdditional restrictions‚ÄîYou may not add any legal terms or technological measures that legally restrict others from doing anything the license permits.",
    "crumbs": [
      "Welcome to the Problem Set for Strength of Materials"
    ]
  },
  {
    "objectID": "index.html#acknowledgments",
    "href": "index.html#acknowledgments",
    "title": "Problem Set for Strength of Materials",
    "section": "ACKNOWLEDGMENTS",
    "text": "ACKNOWLEDGMENTS\nThe team gratefully acknowledges the generosity of Kurt Gramoll. Many of the problems were adapted from Kurt Gramoll‚Äôs collection in the Apple Store and Google Play and released with permission under a CC BY NC SA 4.0 license.\nProblem Set Editor and Content Coordinator\nJames K. Lord, Associate Collegiate Professor, Virginia Tech\nAuthors of Problems\nKurt Gramoll, Emeritus Professor, University of Oklahoma\nJames K. Lord, Mechanical Engineering, Virginia Tech\nChris Galitz, Mechanical Engineering, Virginia Tech\nFrances Davis, Department of Engineering, Brightpoint Community College\nSneha Davison. Mechanical Engineering, Virginia Tech\nRichard Kent, Department of Mechanical & Aerospace Engineering, University of Virginia\nNina Lord, Department of Engineering, North Virginia Community College\nAmy Richardson, Dept of Engineering, North Virginia Community College / Engineering Education, Virginia Tech\nJoao Soares, Department of Mechanical and Nuclear Engineering, Virginia Commonwealth University\nSevak Tahmasian, Mechanical Engineering, Virginia Tech\nFigure Design of Problems\nKindred Grey, Graphic Design and Production Specialist, University Libraries, Virginia Tech\nSoftware Editor\nJacob Grohs, Associate Professor, Engineering Education, Virginia Tech\nReview, Problem Redevelopment, and Programming\nJames K. Lord, Associate Collegiate Professor, Mechanical Engineering, Virginia Tech\nOlivia Ryan, Doctoral Student, Engineering Education, Virginia Tech\nBenjamin E. Chaback, Doctoral Student, Engineering Education, Virginia Tech\nLayout and Design\nKindred Grey, Graphic Design and Production Specialist, University Libraries, Virginia Tech\nProject Coordination and Management\nAnita Walz, Associate Professor, University Libraries, Virginia Tech\nFUNDING\nThis project was made possible in part through funding from an Open Course Grant from VIVA (The Virtual Library of Virginia) and the Open Education Initiative of the University Libraries at Virginia Tech.\nSuggested citation:¬† James Lord and Jacob Grohs, eds.¬†(2024). Problem Set for Strength of Materials. Blacksburg: Virginia Tech Publishing. https://engineeringmechanicsoer.github.io/StrengthOfMaterialsExercises. Licensed with CC BY NC-SA 4.0 https://creativecommons.org/licenses/by-nc-sa/4.0.\nPublisher: This work is published by the Department of Mechanical Engineering and Department of Engineering Education at Virginia Tech in association with the Open Education Initiative and Virginia Tech Publishing.\nVirginia Tech Department of Mechanical Engineering\n445 Goodwin Hall, 635 Prices Fork Road\nBlacksburg,, VA 24061 USA\nhttps://me.vt.edu¬†\nDepartment of Engineering Education at Virginia Tech\n345 Goodwin Hall, 635 Prices Fork Rd,\n¬†Blacksburg,¬† VA 24061 USA\nhttps://enge.vt.edu¬†\nOpen Education Initiative\nUniversity Libraries at Virginia Tech¬†\n560 Drillfield Drive Blacksburg, VA 24061 USA¬†\nopeneducation@vt.edu¬†\nVirginia Tech Publishing\nUniversity Libraries at Virginia Tech¬†\n560 Drillfield Drive Blacksburg, VA 24061 USA¬†\nhttps://publishing.vt.edu ¬† | ¬† publishing@vt.edu",
    "crumbs": [
      "Welcome to the Problem Set for Strength of Materials"
    ]
  },
  {
    "objectID": "problem2_1dynamicsubmit.html",
    "href": "problem2_1dynamicsubmit.html",
    "title": "Problem 2.1 - Average Normal Stress",
    "section": "",
    "text": "Figure 1: A series of solid circular bars are loaded with three loads\n\n\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"138\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\nd1=8\nd2=6\nd3=10\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n    \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A series of solid circular bars are loaded with three loads as shown, F&lt;sub&gt;1&lt;/sub&gt; = {F1()} N, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} N, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} N. What is the largest absolute normal stress, ùúé, in any bar?\")]\n     \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(50, 70, 1))\n        F2.set(random.randrange(10, 30, 1))\n        F3.set(F1()-F2())\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        \n        # Calculate the instructor's answer and determine if the user's answer is correct.\n        instr= (F1()/(math.pi*(d2/(1000*2))**2))/10**6\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.1 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_2dynamicsubmit.html",
    "href": "problem2_2dynamicsubmit.html",
    "title": "Problem 2.2 - Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"139\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nFA=reactive.Value(\"__\")\nFB=reactive.Value(\"__\")\nE = 30*10**6\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two cylinders are stacked on top of one another and two forces are applied at the top surface and at the joint between the cylinders as shown. If L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in., L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in., F&lt;sub&gt;A&lt;/sub&gt; = {FA()} lb, and F&lt;sub&gt;B&lt;/sub&gt; = {FB()} lb, determine the average normal stress in cylinder B. Enter a positive answer for tensile stress or a negative answer for compressive stress. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        FA.set(random.randrange(300, 700, 10))\n        FB.set(random.randrange(100, 300, 10))\n        L1.set(random.randrange(2, 7, 1))\n        L2.set(round(L1() * 1.3,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        instr = -(FA()+FB())/(math.pi*1.5**2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.2 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_3dynamicsubmit.html",
    "href": "problem2_3dynamicsubmit.html",
    "title": "Problem 2.3 - Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"144\"\nF=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A plastic cylindrical peg is constrained by a metal cap as shown. An axial load of F = {F()} lb is applied to the peg. If d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in and d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in, determine the largest normal stress in the peg. Assume the axial load is evenly distributed across the peg and that the metal cap is fixed and does not move.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(20, 80, 5))\n        d1.set(random.randrange(3, 8, 1)/10)\n        d2.set(round(d1() * 1.6, 2))\n        \n \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= F()/(math.pi*((d1()/2)**2))\n        #check=math.isclose(float(input.answer()),instr,rel_tol=0.001)\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.3 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_4dynamicsubmit.html",
    "href": "problem2_4dynamicsubmit.html",
    "title": "Problem 2.4 - Average Normal Stress",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"146\"\nW=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nangle1=math.radians(45)\nangle2=math.radians(30)\nangle3=math.radians(75)\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A crate weighing {W()} kN is suspended by a set of cables. The diameter of each cable is {d()}  mm. What is the maximum stress in any cable, that is the highest average normal stress, excluding the cable attached to the crate.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W.set(random.randrange(30, 90, 1))\n        d.set(random.randrange(20, 60, 1))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        R1 = W()/(((math.cos(angle1)/math.cos(angle2))*math.sin(angle2))+math.sin(angle1))\n        instr = (R1*10**3/(math.pi*((d()/(1000*2))**2)))/10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.4 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_21dynamicsubmit.html",
    "href": "problem2_21dynamicsubmit.html",
    "title": "Problem 2.21 - Average Shear Stress",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"164\"\nœÑfail=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kips\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A double lap joint is glued together using glue with a shear stress failure strength of {œÑfail()} psi. If dimensions L = {L()} in. and t = {t()} in., what is the maximum load P that the joint can withstand? Assume the load is evenly distributed across the joint on both sides.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        œÑfail.set(random.randrange(7000, 9000, 100))\n        L.set(random.randrange(40, 100, 1)/10)\n        t.set(random.randrange(40, 100, 1)/10)\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        A = L()*t()*2\n        instr= (œÑfail()*A)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.21 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_22dynamicsubmit.html",
    "href": "problem2_22dynamicsubmit.html",
    "title": "Problem 2.22 - Average Shear Stress",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"165\"\nF=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A bracket is attached to a wall with two circular rivets of diameter d = {d()} mm. A load F = {F()} kN is applied in the center of the bracket. Assuming the load is split evenly between the two rivits, determine the shear stress in each rivet. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(30, 100, 1))\n        d.set(random.randrange(10, 40, 1))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.  \n      \n        A = math.pi*(d()/(1000*2))**2\n        instr= ((F()/2)/A)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.22 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_23dynamicsubmit.html",
    "href": "problem2_23dynamicsubmit.html",
    "title": "Problem 2.23 - Average Shear Stress",
    "section": "",
    "text": "Figure 1: A square bar of length is pinned at one end and rests on a circular rod.\n\n\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"168\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A square bar of length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in. is pinned at one end and rests on a circular rod of diameter d = {d()} in. A force F = {F()} lb is applied at the free end. What is the average shear stress in the circular rod? \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(50, 150, 1)/10)\n        L2.set(round(L1() * 1.4, 1))\n        d.set(random.randrange(4, 9, 1)/10)\n        F.set(random.randrange(30, 100, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        M = F()*(L1()+L2())\n        R = M/L1()\n        A = math.pi*(d()/2)**2\n        instr= R/(2*A)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.23 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_38dynamicsubmit.html",
    "href": "problem2_38dynamicsubmit.html",
    "title": "Problem 2.38 - Bearing Stress",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"166\"\nW=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n    \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A crate of weight {W()} = lb hangs from a solid circular metal rod of diameter {d1()} = in.. The cable is wrapped around a support collar of diameter {d2()} = in. and thickness {t()} = in. to evenly distribute the cable load. What is the bearing stress on the support collar due to the rod? \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W.set(random.randrange(4000, 9000, 100))\n        d1.set(random.randrange(5, 30, 1)/10)\n        d2.set(d1()*3)\n        t.set(d1()*2)\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        \n        instr= W()/(d1()*t()*1000)\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.38 - Bearing Stress"
    ]
  },
  {
    "objectID": "problem2_39dynamicsubmit.html",
    "href": "problem2_39dynamicsubmit.html",
    "title": "Problem 2.39 - Bearing Stress",
    "section": "",
    "text": "Figure 1: A link mechanism is connected with pins.\n\n\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"180\"\nF=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\n\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)  \n  \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A link mechanism is connected with pins of diameter d = {d()} in. A force F = {F()} lb is applied to the mechanism as shown. The mechanism has width w = {w()} in. and thickness t = {t()} in. What is the bearing stress in member BC at joint B due to the pin at B? \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(200, 900, 10))\n        d.set(random.randrange(20, 150, 10)/100)\n        t.set(random.randrange(2, 10, 1)/10)\n        w.set(round(d()*2, 2))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Fb=((18+8)*F())/18\n        instr= Fb/(d()*t())/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.39 - Bearing Stress"
    ]
  },
  {
    "objectID": "problem2_41dynamicsubmit.html",
    "href": "problem2_41dynamicsubmit.html",
    "title": "Problem 2.41 - Bearing Stress",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"169\"\nd=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kips\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A steel connector plate is hung from a brass rod of diameter d = {d()} in. The plate has dimensions t = {t()} in. and w = {w()} in. Considering only bearing stress, find the minimum load (P) that will cause the connector or rod to fail. Assume the failure bearing stress for brass is 70 ksi and for steel is 75 ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(8, 20, 1)/10)\n        t.set(random.randrange(3, 7, 1)/10)\n        w.set((d()*2))        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= 70*t()*d()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.41 - Bearing Stress"
    ]
  },
  {
    "objectID": "problem2_47dynamicsubmit.html",
    "href": "problem2_47dynamicsubmit.html",
    "title": "Problem 2.47 - Stress on an Inclined Plane",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"153\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nŒò=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two slanted brackets are glued together as shown. If F = {F()} lb, L = {L()} in., and Œò = {Œò()} ¬∞, determine the shear stress parallel to the inclined plane. Assume loads are inline and there is no rotation.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(200, 800, 10))\n        L.set(random.randrange(20, 80, 1)/10)\n        Œò.set(random.randrange(15, 30, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        instr= (F()*math.cos(math.radians(Œò()))/(L()*2))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.47 - Stress on an Inclined Plane"
    ]
  },
  {
    "objectID": "problem2_48dynamicsubmit.html",
    "href": "problem2_48dynamicsubmit.html",
    "title": "Problem 2.48 - Stress on an Inclined Plane",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"156\"\nF=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nŒò=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A 2 inch thick board is cut and then glued back together along a line that is Œò = {Œò()} ¬∞ off the vertical as shown. If height h = {h()} in. and F = {F()} lb, determine the normal stress along the cut line.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(2000, 6000, 100))\n        h.set(random.randrange(50, 150, 1)/10)\n        Œò.set(random.randrange(10, 20, 1))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        \n        instr= (F()/(2*h()))*(math.cos(math.radians(Œò()))**2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 2 Problems",
      "Problem 2.48 - Stress on an Inclined Plane"
    ]
  },
  {
    "objectID": "problem3_2dynamicsubmit.html",
    "href": "problem3_2dynamicsubmit.html",
    "title": "Problem 3.2 - Normal Strain",
    "section": "",
    "text": "Figure 1: A rectangular prism is subjected to a tension test.\n\n\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"650\"\nL=reactive.Value(\"__\")\nLp=reactive.Value(\"__\")\n\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm/mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"During a tension test of a rectangular prism, the original gage length L = {L()} mm is increased to L' = {Lp()} mm. determine the normal strain, Œµ, in the prism.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(100, 400, 1))\n        Lp.set(L()+random.randrange(100, 300, 1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (Lp()-L())/L()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 3 Problems",
      "Problem 3.2 - Normal Strain"
    ]
  },
  {
    "objectID": "problem3_7dynamicsubmit.html",
    "href": "problem3_7dynamicsubmit.html",
    "title": "Problem 3.7 - Shear Strain",
    "section": "",
    "text": "[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"652\"\nL=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\n\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of radians\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A square plate is deformed due to shear with the new shape shown. If length L = {L()} mm and x = {x()} mm, determine the shear strain at corner A.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(200, 500, 10))\n        x.set(random.randrange(20, 50, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= math.atan(x()/L())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 3 Problems",
      "Problem 3.7 - Shear Strain"
    ]
  },
  {
    "objectID": "problem4_5dynamicsubmit.html",
    "href": "problem4_5dynamicsubmit.html",
    "title": "Problem 4.5 - Hooke‚Äôs Law",
    "section": "",
    "text": "Figure 1: A single force pulls on three cylindrical rods that are fixed to a wall.\n\n\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"188\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nEsteel = 29000\nEaluminum = 10000\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches/inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A single force F = {F()} kips pulls on three cylindrical rods, each of length L = {L()} in. The aluminum rods have a diameter d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in., and the steel rods have a diameter d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in. What is the strain in the steel cylinder? Assume E&lt;sub&gt;steel&lt;/sub&gt; = 29,000 ksi and E&lt;sub&gt;aluminum&lt;/sub&gt; = 10,000 ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(20, 300, 1)/10)\n        L.set(random.randrange(50, 200, 1)/10)\n        d1.set(random.randrange(10, 50, 1)/10)\n        d2.set(round(d1()/2, 2))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr=(F()/(((d2()/2)**2)*math.pi))/Esteel\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.5 - Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_6dynamicsubmit.html",
    "href": "problem4_6dynamicsubmit.html",
    "title": "Problem 4.6 - Hooke‚Äôs Law",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"194\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\ndL=reactive.Value(\"__\")\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A polymer test specimen is subjected to an axial load of F = {F()} kips. The central portion of the specimen has an initial length L = {L()} in., w = {w()} in., and t = {t()} in. If the length increases by dL = {dL()} in., determine the elastic modulus of the material. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(100, 500, 1)/10)\n        L.set(random.randrange(50, 150, 1)/10)\n        w.set(round(L()*0.375, 2))\n        t.set(random.randrange(10, 50, 1)/100)\n        dL.set(random.randrange(3, 9, 1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (F()*L())/(dL()*(w()*t()))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.6 - Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_10dynamicsubmit.html",
    "href": "problem4_10dynamicsubmit.html",
    "title": "Problem 4.10 - Poisson‚Äôs Ratio",
    "section": "",
    "text": "Figure 1: A circular road is placed in tension with an axial load.\n\n\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"206\"\nP=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A circular rod of an unknown metallic alloy is placed in tension with a P = {P()} kip axial load. The length of the rod is L = {L()} in. and the diameter is d = {d()} in. After applying the load, the rod length increases by 0.0035 in and the diameter decreases by 0.00014 in. What is the Poisson's ratio of the alloy?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        P.set(random.randrange(20, 200, 1)/10)\n        L.set(random.randrange(10, 20, 1))\n        E.set(random.randrange(20, 40, 1)/100)\n        d.set(round((.00014*L())/(.0035*E()), 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n       \n        instr= -(-.00014/d())/(.0035/L())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.10 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_11dynamicsubmit.html",
    "href": "problem4_11dynamicsubmit.html",
    "title": "Problem 4.11 - Poisson‚Äôs Ratio",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"213\"\nr1=reactive.Value(\"__\")\nr2=reactive.Value(\"__\")\nE=15000\nv=0.33\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"An aluminum circular rod of radius r&lt;sub&gt;1&lt;/sub&gt; = {r1()} in is inserted into space that is slightly wider than the rod, where r&lt;sub&gt;2&lt;/sub&gt; = {r2()} in. What load P is needed so that the rod expands and fills the space in the radial direction? Assume E = 15,000 ksi and v = 0.33. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        r1.set(random.randrange(10, 50, 1)/10)\n        r2.set((r1() + random.randrange(1, 10, 1)/1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Ex = (r1() - r2())/r1()\n        sigmay = (Ex*E)/(-v)\n        instr= sigmay*math.pi*r1()**2\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.11 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_12dynamicsubmit.html",
    "href": "problem4_12dynamicsubmit.html",
    "title": "Problem 4.12 - Poisson‚Äôs Ratio",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"216\"\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A rectangular bar is pulled in tension by a load P in the x-direction. The bar deflects by Œ¥&lt;sub&gt;1&lt;/sub&gt; = {d1()} in and Œ¥&lt;sub&gt;2&lt;/sub&gt; = - {d2()} in, in the x- and y-direction, respectively. The length in the x-direction is 5 in, and the length in the y direction is 1 in. What is the Poisson's ratio of the material? The z-direction deflection is not known. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d1.set(random.randrange(20, 50, 1)/1000)\n        d2.set(random.randrange(10, 20, 1)/10000)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= -(-d2()/1)/(d1()/5)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.12 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_18dynamicsubmit.html",
    "href": "problem4_18dynamicsubmit.html",
    "title": "Problem 4.18 - Thermal Strain",
    "section": "",
    "text": "[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"658\"\nL=reactive.Value(\"__\")\nTi=reactive.Value(\"__\")\nTf=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of m/m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A copper pipe (Œ± = 17x10&lt;sup&gt;-6&lt;/sup&gt; /¬∞C) of length L = {L()} m is cooled from {Ti()}¬∞C to to {Tf()}¬∞C. Determine the longitudinal strain in the cooled pipe.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50, 100, 1)/10)\n        Ti.set(random.randrange(30, 50, 1))\n        Tf.set(Ti()-random.randrange(10, 25, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= 17*10**-6*(Tf()-Ti())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.18 - Thermal Strain"
    ]
  },
  {
    "objectID": "problem4_19dynamicsubmit.html",
    "href": "problem4_19dynamicsubmit.html",
    "title": "Problem 4.19 - Thermal Strain",
    "section": "",
    "text": "[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"659\"\nL=reactive.Value(\"__\")\nTi=reactive.Value(\"__\")\nTf=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in.\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Upon plant startup, a steel steam pipe (Œ± = 6.5 x 10&lt;sup&gt;-6&lt;/sup&gt; /¬∞F) of length L = {L()} ft is raised in temperature from an ambiant temperature of {Ti()}¬∞F to {Tf()}¬∞F. Determine the change in length of the pipe.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50, 200, 5))\n        Ti.set(random.randrange(50, 75, 1))\n        Tf.set(random.randrange(300, 500, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= 6.5*10**-6*(Tf()-Ti())*L()*12\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.19 - Thermal Strain"
    ]
  },
  {
    "objectID": "problem4_23dynamicsubmit.html",
    "href": "problem4_23dynamicsubmit.html",
    "title": "Problem 4.23 - Multiaxial Hooke‚Äôs Law",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"204\"\nL=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nFx=reactive.Value(\"__\")\nFy=reactive.Value(\"__\")\nE=29000\nv=0.29\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A square steel plate of side length L = {L()} in. and thickness t = {t()} in. is uniformly pulled by two forces F&lt;sub&gt;x&lt;/sub&gt; = {Fx()} kips and F&lt;sub&gt;y&lt;/sub&gt; = {Fy()} kips as shown. If E = 29,000 ksi and Poisson's ratio v = 0.29, determine the change in thickness of the plate. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50, 150, 1)/10)\n        t.set(random.randrange(2, 10, 1)/10)\n        Fx.set(random.randrange(100, 500, 1)/10)\n        Fy.set(random.randrange(100, 500, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigmax = Fx()/(L()*t())\n        sigmay = Fy()/(L()*t())\n        instr= t()*(-v/E)*(sigmax+sigmay)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.23 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_24dynamicsubmit.html",
    "href": "problem4_24dynamicsubmit.html",
    "title": "Problem 4.24 - Multiaxial Hooke‚Äôs Law",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"205\"\nP1=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\nv=reactive.Value(\"__\")\nSG=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in percent\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A strain gauge is placed on a polymer test sample with an elastic modulus E =  {E()} x 10&lt;sup&gt;6&lt;/sup&gt; psi and a Poisson's ratio of v = {v()}. When a P&lt;sub&gt;1&lt;/sub&gt; = {P1()} kip vertical load is applied to the test sample, the strain gauge reads a strain of Œµ = {SG()} x 10&lt;sup&gt;-6&lt;/sup&gt; in the x-direction. What is the relative error of the strain gauge compared to the theoretical strain of the test sample? Note: relative error is defined to be the difference between the measured value and the theoretical value divided by the theoretical value.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        P1.set(random.randrange(20, 200, 1)/10)\n        E.set(random.randrange(5, 20, 1))\n        v.set(random.randrange(20, 40, 1)/100)\n        SG.set(round((v()*P1()*1000)/(12*E()),1)-(random.randrange(3, 20, 1)/10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigmaz = (-P1()*1000)/(4*3)\n        Ex = ((-v()*(sigmaz))/(E()*10**6))\n        instr=  ((Ex - SG()*10**-6)/Ex)*100\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.24 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_25dynamicsubmit.html",
    "href": "problem4_25dynamicsubmit.html",
    "title": "Problem 4.25 - Multiaxial Hooke‚Äôs Law",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"208\"\nPx=reactive.Value(\"__\")\nPy=reactive.Value(\"__\")\nPz=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\nv=reactive.Value(\"__\")\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in percent\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A block is pulled in all three directions (P&lt;sub&gt;x&lt;/sub&gt; = {Px()} kN, P&lt;sub&gt;y&lt;/sub&gt; = {Py()} kN, P&lt;sub&gt;z&lt;/sub&gt; = {Pz()} kN). What is the percent change in volume after all three loads are applied? Assume E = {E()} MPa and v = {v()}. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        Px.set(random.randrange(1, 20, 1))\n        Py.set(random.randrange(1, 20, 1))\n        Pz.set(random.randrange(1, 20, 1))\n        E.set(random.randrange(1000, 2000, 100))\n        v.set(random.randrange(20, 40, 1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigmax = (Px()/(5*2))*10\n        sigmay = (Py()/(6*2))*10\n        sigmaz = (Pz()/(5*6))*10\n        Ex = (sigmax - v()*(sigmay+sigmaz))/(E())\n        Ey = (sigmay - v()*(sigmaz+sigmax))/(E())\n        Ez = (sigmaz - v()*(sigmax+sigmay))/(E())\n        Lx = 6 + 6*Ex\n        Ly = 5 + 5*Ey\n        Lz = 2 + 2*Ez\n        instr= (((Lx*Ly*Lz)-60)/60)*100\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.25 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_35dynamicsubmit.html",
    "href": "problem4_35dynamicsubmit.html",
    "title": "Problem 4.35 - Allowable Stress/Safety Factor",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"157\"\nF=reactive.Value(\"__\")\nFS=reactive.Value(\"__\")\nœÉfail=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of centimeters\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A small truss is constructed with solid square wood members and subjected to a load of F = {F()} kN. Determine the minimum dimension, a, of the member so that the truss will have a factor of safety of {FS()}. All members have the same cross-section. The wood has a failure stress of œÉ&lt;sub&gt;fail&lt;/sub&gt; = {œÉfail()} MPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(15, 50, 1))\n        FS.set(random.randrange(15, 40, 1)/10)\n        œÉfail.set(random.randrange(40, 60, 1))\n        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n    \n        dl = FS()*F()\n        A = (dl/(œÉfail()*10**3))*100*100\n        instr= math.sqrt(A)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 4 Problems",
      "Problem 4.35 - Allowable Stress/Safety Factor"
    ]
  },
  {
    "objectID": "problem5_6dynamicsubmit.html",
    "href": "problem5_6dynamicsubmit.html",
    "title": "Problem 5.6 - Stress Concentrations",
    "section": "",
    "text": "[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"664\"\nt=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A flat bar of thickness t = {t()} mm contains a hole as shown. The bar is subjected to a tensile load P = {P()} kN. Determine the maximum tensile stress in the bar.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        t.set(random.randrange(10, 25, 1))\n        P.set(random.randrange(10, 100, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigma_norm = P()/(t()*(43-22))*1000\n        instr= 2.15*(sigma_norm)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.1):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.6 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_8dynamicsubmit.html",
    "href": "problem5_8dynamicsubmit.html",
    "title": "Problem 5.8 - Stress Concentrations",
    "section": "",
    "text": "Figure 1: A bar narrows in width.\n\n\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"666\"\nt=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A flat bar of thickness t = {t()} in. narrows with fillets as shown. If a load P = {P()} lb is applied, determine the maximum stress in the bar.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        t.set(random.randrange(10, 100, 5)/100)\n        P.set(random.randrange(1000, 5000, 100))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigma_norm = P()/(t()*(1.5))\n        instr= 1.95*(sigma_norm)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.1):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.8 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_10dynamicsubmit.html",
    "href": "problem5_10dynamicsubmit.html",
    "title": "Problem 5.10 - Stress Concentrations",
    "section": "",
    "text": "Figure 1: A linkage is subjected to a loading as shown.\n\n\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"668\"\nt=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The linkage of thickness t = {t()} in. shown is subjected to load P = {P()} kips. Determine the maximum stress in the linkage.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        t.set(random.randrange(25, 75, 5)/100)\n        P.set(random.randrange(20,45,1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigma1 = 1.82*P()/(2*t())\n        sigma2 = 2.28*P()/(2.5*t())\n        instr = max(sigma1,sigma2)\n        \n        if math.isclose(float(input.answer()), instr, rel_tol=0.1):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n            \n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.10 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_11dynamicsubmit.html",
    "href": "problem5_11dynamicsubmit.html",
    "title": "Problem 5.11 - Axial Deformation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\nproblem_ID=\"183\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\nF4=reactive.Value(\"__\")\nE=210\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A series of solid, steel, circular bars are loaded with forces as shown, where F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN, F&lt;sub&gt;3&lt;/sub&gt; = {F3()} kN, and F&lt;sub&gt;4&lt;/sub&gt; = {F4()} kN. What is the total change in length of the system? Assume E = 210 GPa for steel.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(10, 100, 1)/10)\n        F2.set(random.randrange(10, 100, 1)/10)\n        F3.set(random.randrange(10, 100, 1)/10)\n        F4.set(random.randrange(10, 100, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= ((F1()*3)/(E*math.pi*0.5**2)+((F1()+F2())*3)/(E*math.pi*1**2)+((F1()+F2()+F3())*4)/(E*math.pi*0.25**2)+((F1()+F2()+F3()+F4())*2)/(E*math.pi*0.5**2))/10\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.11 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_12dynamicsubmit.html",
    "href": "problem5_12dynamicsubmit.html",
    "title": "Problem 5.12 - Axial Deformation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"184\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nL3=reactive.Value(\"__\")\nEsteel = 210\nEaluminum = 70\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of micrometers\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two forces, F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN, are applied to the system of cylinders as shown. If L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m, L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m, and L&lt;sub&gt;3&lt;/sub&gt; = {L3()} m, what is the total change in length of the system? Assume E&lt;sub&gt;steel&lt;/sub&gt; = {Esteel} GPa and E&lt;sub&gt;aluminum&lt;/sub&gt; = {Ealuminum} GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(100, 300, 1)/10)\n        F2.set(round(F1()/1.5, 2))\n        L1.set(random.randrange(20, 80, 1)/10)\n        L2.set(round(L1()*0.6, 2))\n        L3.set(round(L1()*0.8, 2))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n       \n        instr= ((F2()*10**3*L2())/(math.pi*0.3**2*Esteel*10**9) + ((F2()-F1())*1000*L1())/(math.pi*0.5**2*Ealuminum*10**9))*1000000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.12 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_13dynamicsubmit.html",
    "href": "problem5_13dynamicsubmit.html",
    "title": "Problem 5.13 - Axial Deformation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"185\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nEbrass = 100\nEaluminum = 70\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two forces, F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN, are applied to the system of cylinders as shown. If L&lt;sub&gt;1&lt;/sub&gt; = {L1()} mm and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} mm, what is the total change in length of the system. Assume E&lt;sub&gt;brass&lt;/sub&gt; = {Ebrass} GPa and E&lt;sub&gt;aluminum&lt;/sub&gt; = {Ealuminum} GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(10, 100, 1)/10)\n        F2.set(round(F1()*2, 2))\n        L1.set(random.randrange(50, 150, 1))\n        L2.set(round(L1()*1.5))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (((F2()-F1())*L1())/(math.pi*.002**2*Ebrass*10**6)) + (F2()*L2())/(math.pi*.003**2*Ealuminum*10**6)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.13 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_14dynamicsubmit.html",
    "href": "problem5_14dynamicsubmit.html",
    "title": "Problem 5.14 - Axial Deformation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"186\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nL3=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A series of solid circular steel bars are loaded as shown, where F&lt;sub&gt;1&lt;/sub&gt; = {F1()} N, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} N, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} N. If lengths L&lt;sub&gt;1&lt;/sub&gt; = L&lt;sub&gt;2&lt;/sub&gt; = {L1()} cm and L&lt;sub&gt;3&lt;/sub&gt; = {L3()} cm, determine the total change in length of the system. Assume E&lt;sub&gt;steel&lt;/sub&gt; = 210 GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(20, 100, 1))\n        F2.set(random.randrange(20, 100, 1))\n        F3.set(random.randrange(20, 100, 1))\n        L1.set(random.randrange(20, 60, 1))\n        L2.set(L1())\n        L3.set(round(L1()*1.25))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        R = F2()+F3()-F1()\n        FBC = F1()+R\n        dAB = R*L1()/100/(210*10**9*0.004**2*math.pi)\n        dBC = FBC*L2()/100/(210*10**9*0.003**2*math.pi)\n        dCD = F3()*L3()/100/(210*10**9*0.005**2*math.pi)\n        instr= abs((dAB+dBC+dCD)*10**3)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.14 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_15dynamicsubmit.html",
    "href": "problem5_15dynamicsubmit.html",
    "title": "Problem 5.15 - Axial Deformation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"187\"\nW=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nA1=reactive.Value(\"__\")\nA2=reactive.Value(\"__\")\nEsteel = 29000\nEaluminum = 10000\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A crate weight W = {W()} lb is attached to a cable constructed from steel of length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. and Area A&lt;sub&gt;1&lt;/sub&gt; = {A1()} in.&lt;sup&gt;2&lt;/sup&gt; and aluminum of length L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in. and area A&lt;sub&gt;2&lt;/sub&gt; = {A2()} in.&lt;sup&gt;2&lt;/sup&gt;. What is the total deflection of the crate after it is attached to the wire? Assume E&lt;sub&gt;steel&lt;/sub&gt; = {Esteel} ksi and E&lt;sub&gt;aluminum&lt;/sub&gt; = {Ealuminum} ksi. Neglect the weight of the wires.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W.set(random.randrange(50, 250, 1))\n        L1.set(random.randrange(10, 30, 1))\n        L2.set(round(L1()*2, 2))\n        A1.set(random.randrange(1, 5, 1)/100)\n        A2.set(random.randrange(1, 5, 1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        \n        instr=(W()*L1()/(A1()*Esteel*1000) + (W()*L2()/(A2()*Ealuminum*1000)))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.15 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_27dynamicsubmit.html",
    "href": "problem5_27dynamicsubmit.html",
    "title": "Problem 5.27 - Deformation in Systems of Bars",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"191\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nA=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEsteel = 29000\nEaluminum = 10000\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A bar is attached to two wires, one steel and one aluminum. If the lengths of the wires L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in., find the distance x that load F = {F()} kips must be placed at so that the bar remains horizontal after the load is applied. Both wires have the same cross-section area A = {A()} in.&lt;sup&gt;2&lt;/sup&gt;. Assume E&lt;sub&gt;steel&lt;/sub&gt; = 29,000 ksi, E&lt;sub&gt;aluminum&lt;/sub&gt; = 10,000 ksi and that the bar is of length L = {L()} in.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(50, 150, 1)/10)\n        L2.set(round(L1()*2, 2))\n        F.set(random.randrange(30, 150, 1)/10)\n        A.set(random.randrange(2, 25, 1)/100)\n        L.set(random.randrange(10, 20, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        PsPa = (L1()*Esteel*A())/(L2()*Ealuminum*A())\n        Ps = (F()/(PsPa+1))*PsPa\n        instr=(Ps*L())/F()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.27 - Deformation in Systems of Bars"
    ]
  },
  {
    "objectID": "problem5_34dynamicsubmit.html",
    "href": "problem5_34dynamicsubmit.html",
    "title": "Problem 5.34 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"192\"\nr=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\ndL=reactive.Value(\"__\")\nEcopper = 110\nEaluminum = 70\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A copper circular rod of radius r = {r()} cm is inserted into an aluminum tube with inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} cm and outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} cm as shown. Load P is applied to the rigid top plate. If length L = {L()} cm, what load P will cause the plate to deflect dL = {dL()} mm downward? Assume E&lt;sub&gt;copper&lt;/sub&gt; = 110 GPa and E&lt;sub&gt;aluminum&lt;/sub&gt; = 70 GPa\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        r.set(random.randrange(20, 60, 1)/10)\n        ri.set(round(r()*1.25, 2))\n        ro.set(round(r()*1.5, 2))\n        L.set(random.randrange(150, 300, 1)/10)\n        dL.set(random.randrange(10, 50, 1)/100)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr=(((dL()*Ecopper*r()**2*math.pi)/L()) + ((dL()*Ealuminum*(ro()**2-ri()**2)*math.pi)/L()))*10\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.34 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_35dynamicsubmit.html",
    "href": "problem5_35dynamicsubmit.html",
    "title": "Problem 5.35 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"193\"\nF=reactive.Value(\"__\")\nw1=reactive.Value(\"__\")\nw2=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEsteel = 29000\nEaluminum = 10000\n\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two blocks with square cross-sections are stacked as shown, with the top block inserted into the bottom block and subjected to load F = {F()} kips. The top block is aluminum (E = 10,000 ksi) with side length w&lt;sub&gt;1&lt;/sub&gt; = {w1()} in.  and the bottom block is steel (E = 29,000 ksi) with side length w&lt;sub&gt;2&lt;/sub&gt; = {w2()} in. If length L = {L()} in., what is the total deflection of the top surface? Ignore the weight of the blocks. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(20, 100, 1)/10)\n        w1.set(random.randrange(15, 50, 1)/10)\n        w2.set(round(w1()*1.5))\n        L.set(random.randrange(50, 200, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr=F()*L()*((1/((w1()**2)*Ealuminum)) + (1/((w2()**2)*Esteel)))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.35 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_36dynamicsubmit.html",
    "href": "problem5_36dynamicsubmit.html",
    "title": "Problem 5.36 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"246\"\nd=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEplastic=reactive.Value(\"__\")\nEwood=1750\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of lb\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two square members are attached to two fixed walls as shown. Force F is applied at point B and point B is displaced d =  {d()} in. to the right. If L = {L()} in., E&lt;sub&gt;wood&lt;/sub&gt; = 1,750 ksi, and E&lt;sub&gt;plastic&lt;/sub&gt; = {Eplastic()} ksi, determine the applied force F. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(2, 8, 1)/1000)\n        L.set(random.randrange(4, 15, 1))\n        Eplastic.set(random.randrange(350, 900, 10))\n       \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (d()*1*Ewood*1000)/L() - (-d()*4*Eplastic()*1000)/L() \n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.36 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_37dynamicsubmit.html",
    "href": "problem5_37dynamicsubmit.html",
    "title": "Problem 5.37 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"247\"\nF=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nEwood=70\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two aluminum circular rods are attached to two fixed walls as shown. Assume E = 70 MPa for both cylinders, F = {F()} kN, d&lt;sub&gt;1&lt;/sub&gt; = {d1()} mm, d&lt;sub&gt;2&lt;/sub&gt;  = {d2()} mm, L&lt;sub&gt;1&lt;/sub&gt;  = {L1()} mm, and L&lt;sub&gt;2&lt;/sub&gt;  = {L2()} mm. Determine the normal stress in member 1.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(20, 100, 1))\n        d1.set(random.randrange(15, 50, 1))\n        d2.set(round(d1()*1.5))\n        L1.set(random.randrange(200, 800, 10))\n        L2.set(round(L1()*(2/3)))\n       \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        LHS = (L1()/1000)/(math.pi*(d1()/2000)**2) + (L2()/1000)/(math.pi*(d2()/2000)**2)\n        RHS = (F()*L2())/(math.pi*(d2()/2)**2)\n        instr= (RHS/LHS)/(math.pi*(d1()/2000)**2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.37 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_38dynamicsubmit.html",
    "href": "problem5_38dynamicsubmit.html",
    "title": "Problem 5.38 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"248\"\nw=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nh1=reactive.Value(\"__\")\nh2=reactive.Value(\"__\")\nEconcrete=25\nEwood=12\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A distributed load w = {w()} N/cm&lt;sup&gt;2&lt;/sup&gt; is applied to a short column made from wood and concrete. Assume E&lt;sub&gt;concrete &lt;/sub&gt;= 25 GPa, E&lt;sub&gt;wood&lt;/sub&gt; = 12 GPa, b = {b()} cm, h&lt;sub&gt;1&lt;/sub&gt; = {h1()} cm, and h&lt;sub&gt;2&lt;/sub&gt; = {h2()} cm. What load is carried by the concrete center?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(50, 750, 10))\n        b.set(random.randrange(20, 100, 1)/10)\n        h1.set(b()*1)\n        h2.set(b()*2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (2.0833*h2()*w()*(2*h1()+h2())*3*b())/(6*h1()+4.0833*h2())/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.38 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_39dynamicsubmit.html",
    "href": "problem5_39dynamicsubmit.html",
    "title": "Problem 5.39 - Statically Indeterminate Axial Loads",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"250\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\ndc=reactive.Value(\"__\")\nds=reactive.Value(\"__\")\nEconcrete=25\nEsteel=200\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A concrete post of length L = {L()}  m and diameter d&lt;sub&gt;c&lt;/sub&gt; = {dc()} mm supports a load F = {F()} kN. The concrete is reinforced with 6 steel rods of diameter d&lt;sub&gt;s&lt;/sub&gt; = {ds()} mm. Assume E&lt;sub&gt;concrete&lt;/sub&gt; = 25 GPa and E&lt;sub&gt;steel&lt;/sub&gt; = 200 GPa. Determine the stress in the concrete.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10, 50, 1)/10)\n        dc.set(random.randrange(100, 500, 10))\n        ds.set(round(dc()/12))\n        F.set(random.randrange(100, 500, 10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        As = (math.pi*6*(ds()/20)**2)\n        Ac = (math.pi*(dc()/20)**2) - As\n        Cside = Ac*Econcrete\n        Sside = As*Esteel\n        LHS = F()*Cside\n        RHS = Cside+Sside\n        instr= ((LHS/RHS)/(Ac/100**2))/10**3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.39 - Statically Indeterminate Axial Loads"
    ]
  },
  {
    "objectID": "problem5_50dynamicsubmit.html",
    "href": "problem5_50dynamicsubmit.html",
    "title": "Problem 5.50 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"222\"\nstress=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nE=29000\nalpha=6.5*10**-6\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ¬∞F\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The axial stress in a solid circular bar between two fixed walls is {stress()} ksi. Find the temperature change necessary to relieve the stress. Assume L = {L()} in., E = 29,000 ksi, and Œ± = 6.5 x 10&lt;sup&gt;-6&lt;/sup&gt; / ¬∞F. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        stress.set(random.randrange(10, 150, 5))\n        L.set(random.randrange(15, 75, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= stress()/(alpha*E)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.50 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_51dynamicsubmit.html",
    "href": "problem5_51dynamicsubmit.html",
    "title": "Problem 5.51 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"223\"\nW=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nTC=reactive.Value(\"__\")\nE=100*10**9\nalpha=10*10**-6\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The W = {W()} kg weight is placed on a L = {L()} m tall brass bar with a cross section of d = {d()} cm. If the bar undergoes a temperature change of {TC()}¬∞C, what is the total deformation of the bar? Assume the Young's Modulus and thermal coefficient of expansion is 100 GPa and 10 x 10&lt;sup&gt;-6&lt;/sup&gt; /¬∞C, respectively. Also, assume no buckling. \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W.set(random.randrange(500, 2000, 100))\n        L.set(random.randrange(10, 50, 1)/10)\n        d.set(random.randrange(15, 40, 1)/10)\n        TC.set(random.randrange(20, 150, 5))\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        deltaT = L()*alpha*TC()\n        deltaM = (W()*9.81*L())/(E*math.pi*(d()/200)**2) #200 converts from diameter in cm to r in meters\n        instr= (deltaT - deltaM)*1000 # *1000 to get answer in mm\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.51 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_52dynamicsubmit.html",
    "href": "problem5_52dynamicsubmit.html",
    "title": "Problem 5.52 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"224\"\nd=reactive.Value(\"__\")\nrA=reactive.Value(\"__\")\nrB=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nalphaA=6*10**-6\nalphaB=10*10**-6\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ¬∞F\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two cylindrical rods are heated until they expand, just closing the gap of d = {d()} in. The coefficient of thermal expansion, Œ±, for material A and B is 6 x 10&lt;sup&gt;-6&lt;/sup&gt;/¬∞F and 10 x 10&lt;sup&gt;-6&lt;/sup&gt;/¬∞F, respectively. The radius of A r&lt;sub&gt;A&lt;/sub&gt; = {rA()} in and the length is L&lt;sub&gt;1&lt;/sub&gt; = {L1()} in. The radius of B is r&lt;sub&gt;B&lt;/sub&gt; = {rB()} in and the length is L&lt;sub&gt;2&lt;/sub&gt; = {L2()} in. What is the change in temperature.  \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(1, 20, 1)/100)\n        rA.set(random.randrange(5, 20, 1)/10)\n        rB.set(round(rA()*1.6, 2))\n        L1.set(random.randrange(5, 20, 1))\n        L2.set(round(L1()*0.6, 2))\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= d()/(alphaA*L1()+alphaB*L2())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.52 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_53dynamicsubmit.html",
    "href": "problem5_53dynamicsubmit.html",
    "title": "Problem 5.53 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"225\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nL3=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\ndT=reactive.Value(\"__\")\nalphaA=10*10**-6\nalphaB=5*10**-6\nalphaC=7*10**-6\nEA=40*10**9\nEB=120*10**9\nEC=80*10**9\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Three cylindrical rods of lengths L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m, L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m, and L&lt;sub&gt;3&lt;/sub&gt; = {L3()} m are connected together. A force F = {F()} kN is applied to the free end and all three rods are heated by {dT()} ¬∞C. The coefficient of thermal expansion, Œ±, and elastic modulus, E, for each material are Œ±&lt;sub&gt;A&lt;/sub&gt; = 10 x 10&lt;sup&gt;-6&lt;/sup&gt; /¬∞C, Œ±&lt;sub&gt;B&lt;/sub&gt; = 5 x 10&lt;sup&gt;-6&lt;/sup&gt; /¬∞C, Œ±&lt;sub&gt;C&lt;/sub&gt; = 7 x 10&lt;sup&gt;-6&lt;/sup&gt; /¬∞C, E&lt;sub&gt;A&lt;/sub&gt; = 40 GPa, E&lt;sub&gt;B&lt;/sub&gt; = 120 GPa, and E&lt;sub&gt;C&lt;/sub&gt; = 80 GPa. What is the total deflection of the right rod tip?  \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(10, 40, 1)/10)\n        L2.set(round((L1()*0.8),1))\n        L3.set(round((L1()*2/3),1))        \n        F.set(random.randrange(5, 50, 1))\n        dT.set(random.randrange(100, 300, 10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        deltaL = (F()*L1()*1000)/(EA*math.pi*.015**2) + (F()*L2()*1000)/(EB*math.pi*.005**2) + (F()*L3()*1000)/(EC*math.pi*.01**2)\n        deltaT = alphaA*dT()*L1() + alphaB*dT()*L2() + alphaC*dT()*L3() \n        instr= (deltaL + deltaT)*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.53 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_54dynamicsubmit.html",
    "href": "problem5_54dynamicsubmit.html",
    "title": "Problem 5.54 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"226\"\nT1=reactive.Value(\"__\")\nT2=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nalpha=20*10**-6\nE=100*10**9\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A square brass bar is placed between two fixed walls and heated from {T1()}¬∞C to {T2()}¬∞C. If L = {L()} mm, h = {h()} mm, E = 100 GPa, and Œ± = 20 x 10&lt;sup&gt;-6&lt;/sup&gt; /¬∞C, determine the stress in the bar.  \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T1.set(random.randrange(5, 20, 1))\n        T2.set(round(T1() + random.randrange(20, 50, 1), 2))\n        L.set(random.randrange(250, 750, 10))\n        h.set(random.randrange(10, 30, 1))\n       \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (E*alpha*(T2()-T1()))/10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.54 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_55dynamicsubmit.html",
    "href": "problem5_55dynamicsubmit.html",
    "title": "Problem 5.55 - Thermal Deformation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"249\"\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\ndT=reactive.Value(\"__\")\nE=200\nv=0.32\na=11.7*10**-6\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Bars AB and BC are pinned at joint B. Both bars are made from the same material with E = 200 GPa, v = 0.32, and a = 11.7 x 10&lt;sup&gt;-6&lt;/sup&gt; /¬∞C. Dimensions L = {L()}  mm, t = {t()} mm, h = {h()} mm, and d = {d()} mm. If both bars are heated by {dT()} ¬∞C, determine the shear stress generated in the pin at B.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(300, 900, 10))\n        t.set(random.randrange(30, 80, 1))\n        h.set(t()/2)\n        d.set(round(t()/3,2))\n        dT.set(random.randrange(10, 40, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        deltaM = a*dT()*(t()/1000)*(h()/1000)*E*10**9\n        instr= (deltaM/(math.pi*(d()/2000)**2))/10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 5 Problems",
      "Problem 5.55 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem6_1dynamicsubmit.html",
    "href": "problem6_1dynamicsubmit.html",
    "title": "Problem 6.1 - Torsional Stress",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"265\"\nT=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN-m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"What torque is required to create a maximum shear stress of œÑ = {T()} MPa in a solid circular bar of diameter d  = {d()} mm? .\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T.set(random.randrange(20, 50, 1))\n        d.set(random.randrange(50, 200, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        J = (math.pi/2)*(d()/2000)**4\n        instr= (T()*1000*J)/(d()/2000)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.1 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_2dynamicsubmit.html",
    "href": "problem6_2dynamicsubmit.html",
    "title": "Problem 6.2 - Torsional Stress",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"267\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\ny=reactive.Value(\"__\")\nd=(reactive.Value(\"__\"))\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A force F = {F()} lb is applied to a hand crank that is stuck and will not turn. If L = {L()} in. and y = {y()} in., determine the maximum shear stress due to torsion in the crank rod between A and B. Assume the crank has diameter d = {d()} in.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(100, 350, 10))\n        L.set(random.randrange(100, 200, 1)/10)\n        y.set(round(L()/2, 2))\n        d.set(random.randrange(3, 15, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        T = F()*y()\n        J = (math.pi/2)*(d()/2)**4\n        instr= ((T*d()/2)/J)/10**3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.2 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_3dynamicsubmit.html",
    "href": "problem6_3dynamicsubmit.html",
    "title": "Problem 6.3 - Torsional Stress",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"273\"\nT1=reactive.Value(\"__\")\nT2=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two torques are applied to a two part circular rod as shown. If T&lt;sub&gt;1&lt;/sub&gt; = {T1()} kip-in., T&lt;sub&gt;2&lt;/sub&gt; = {T2()} kip-in., d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in., and d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in., what is the magnitude of the maximum shear stress?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T1.set(random.randrange(5, 50, 1))\n        T2.set(T1()*random.randrange(3, 5, 1)/10)\n        d1.set(random.randrange(40, 80, 1)/10)\n        d2.set(round(d1()*0.8, 2))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        F1 = -T1()+T2()\n        F2 = T2()\n        J1 = (math.pi/2)*(d1()/2)**4\n        J2 = (math.pi/2)*(d2()/2)**4\n        tau1 = abs(F1*d1()/2/J1)*1000\n        tau2 = abs(F2*d2()/2/J2)*1000\n        if tau1&gt;=tau2:\n            instr = tau1\n        else:\n            instr = tau2\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.3 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_4dynamicsubmit.html",
    "href": "problem6_4dynamicsubmit.html",
    "title": "Problem 6.4 - Torsional Stress",
    "section": "",
    "text": "Figure 1: Three belt pullets are connected to a solid shaft.\n\n\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"276\"\nd=reactive.Value(\"__\")\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Three belt pulleys are connected to a solid circular shaft of diameter d = {d()} in. that rotates freely at joints A and E. The pulleys are subjected to forces F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kips, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kips, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} kips. What is the maximum shear stress in the shaft between pulleys B and C?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(20, 40, 1)/10)\n        F1.set(random.randrange(20, 200, 2)/10)\n        F2.set(F1()/2)\n        F3.set(round(F1()*0.9, 2))\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        T = 6*F1()\n        instr= (T*(d()/2))/((math.pi/2)*(d()/2)**4)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.4 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_5dynamicsubmit.html",
    "href": "problem6_5dynamicsubmit.html",
    "title": "Problem 6.5 - Torsional Stress",
    "section": "",
    "text": "This is a dynamic rendering of the problem with dynamic variables based on the username entered.\n [Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"278\"\nro=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\nTB=reactive.Value(\"__\")\nTC=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two torques ,T&lt;sub&gt;B&lt;/sub&gt; = {TB()} kip-ft and T&lt;sub&gt;C&lt;/sub&gt; = {TC()} kip-ft, are applied to the hollow pipe as shown. If L = {L()} ft., r&lt;sub&gt;o&lt;/sub&gt; = {ro()} in., and r&lt;sub&gt;i&lt;/sub&gt; = {ri()} in., determine the maximum shear stress in the pipe.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        TB.set(random.randrange(100, 500, 100))\n        TC.set(TB()/2)\n        L.set(random.randrange(10, 90, 1)/10)\n        ro.set(random.randrange(15, 60, 1)/10)\n        ri.set(round(ro()*0.8))\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Tmax = (TB()-TC())*12\n        J = (math.pi/2)*(ro()**4 - ri()**4)\n        instr= (Tmax*ro())/J\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.5 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_11dynamicsubmit.html",
    "href": "problem6_11dynamicsubmit.html",
    "title": "Problem 6.11 - Torsional Deformation",
    "section": "",
    "text": "Figure 1: A hollow copper rod is fixed to a wall at one end and a torque is applied\n\n\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"266\"\nL=reactive.Value(\"__\")\ndo=reactive.Value(\"__\")\ndi=reactive.Value(\"__\")\nangle=(reactive.Value(\"__\"))\nE = 110\nv = 0.33\n\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN-m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A hollow copper rod (E = 110 GPa, v = 0.33) is subjected to torque T as shown. If length L = {L()} m, outer diameter d&lt;sub&gt;o&lt;/sub&gt; = {do()} mm, and inner diameter d&lt;sub&gt;i&lt;/sub&gt; = {di()} mm, determine torque T if the rod twists {angle()}¬∞ .\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(5, 30, 1)/10)\n        do.set(random.randrange(50, 200, 1))\n        di.set(round(do()/2, 2))\n        angle.set(random.randrange(1, 10, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        G = E*10**9/(2*(1+v))\n        J = (math.pi/2)*((do()/2000)**4 -(di()/2000)**4 )\n        instr= ((math.radians(angle())*G*J)/L())/10**3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.11 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_12dynamicsubmit.html",
    "href": "problem6_12dynamicsubmit.html",
    "title": "Problem 6.12 - Torsional Deformation",
    "section": "",
    "text": "Figure 1: A bar is attached to a wall.\n\n\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"268\"\nT1=reactive.Value(\"__\")\nangle=reactive.Value(\"__\")\nG=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ft-lb\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A bar with a shear modulus G = {G()} x 10&lt;sup&gt;6&lt;/sup&gt; psi is subjected to torques T&lt;sub&gt;1&lt;/sub&gt; = {T1()} lb-ft at its center and T&lt;sub&gt;2&lt;/sub&gt; at its free end. The inner diamter is 1 in and the outer diameter is 2 in and the total length of the bar is 10 in. If the rotation of the rod at its free end is Œ∏ =  {angle()}¬∞ clockwise, what is the magnitude of torque T&lt;sub&gt;2&lt;/sub&gt;?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        G.set(random.randrange(90, 130, 1)/10)\n        T1.set(random.randrange(1000, 5000, 100))\n        angle.set(random.randrange(10, 50, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        ro = 2/2\n        ri = 1/2\n        J = math.pi/2*(ro**4-ri**4)\n        L1 = 10/2\n        L2 = 10/2\n        instr= abs((angle()*math.pi/180*G()*10**6*J+T1()*12*L1)/(L1+L2)/12)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.12 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_13dynamicsubmit.html",
    "href": "problem6_13dynamicsubmit.html",
    "title": "Problem 6.13 - Torsional Deformation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"269\"\nT1=reactive.Value(\"__\")\nT2=reactive.Value(\"__\")\nT3=reactive.Value(\"__\")\nGs=77\nGa=27\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of degrees\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Three moments are applied to the system of cylinders as shown. Assume T&lt;sub&gt;1&lt;/sub&gt; = {T1()} kN-m, T&lt;sub&gt;2&lt;/sub&gt; = {T2()} kN-m, and T&lt;sub&gt;3&lt;/sub&gt; = {T3()} kN-m. If G&lt;sub&gt;steel&lt;/sub&gt; = 77 GPa and G&lt;sub&gt;aluminum&lt;/sub&gt; = 27 GPa, determine the total angle of twist at the free end.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T1.set(random.randrange(20, 100, 1)/10)\n        T2.set(T1()+random.randrange(20, 100, 1)/10)\n        T3.set(round(T2()*random.randrange(5, 8, 1)/10, 2))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        F1 = T1()+T2()-T3()\n        F2 = T2()-T3()\n        F3 = -T3()\n        J1 = (math.pi/2)*((5/200)**4)\n        J2 = (math.pi/2)*((3/200)**4)\n        J3 = (math.pi/2)*((4/200)**4)\n        instr= ((F1*1000*.1)/(J1*Gs*10**9) + (F2*1000*.15)/(J2*Ga*10**9) + (F3*1000*.08)/(J3*Gs*10**9))*180/math.pi\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.13 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_14dynamicsubmit.html",
    "href": "problem6_14dynamicsubmit.html",
    "title": "Problem 6.14 - Torsional Deformation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"270\"\nL=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\nT=reactive.Value(\"__\")\nG=reactive.Value(\"__\")\nstress=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A circular rod of length L = {L()} mm, outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} mm, and unknown inner radius r&lt;sub&gt;i&lt;/sub&gt; has a shear modulus G = {G()} GPa. The rod is subjected to torque T = {T()} kN-m at the free end. If the angle of twist must not exceed 2¬∞ and the shear stress must not exceed {stress()} MPa, what is the minimum required inner radius?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(250, 500, 10))\n        ro.set(random.randrange(55, 75, 1))\n        G.set(random.randrange(60, 100, 1))\n        T.set(random.randrange(10, 100, 1)/10)\n        stress.set(random.randrange(75, 150, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        r1= ((ro()/1000)**4-(2*T()*1000*ro()/1000/(math.pi*stress()*10**6)))**0.25*1000\n        r2 = ((ro()/1000)**4-(2*T()*1000*L()/1000/(math.pi*G()*10**9*2*math.pi/180)))**0.25*1000\n        if r1&gt;r2:\n            instr = r2\n        else:\n            instr = r1\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.14 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_15dynamicsubmit.html",
    "href": "problem6_15dynamicsubmit.html",
    "title": "Problem 6.15 - Torsional Deformation",
    "section": "",
    "text": "Figure 1: A hollow circualr rod is attached to a wall and subjected to a torque at the free end.\n\n\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"274\"\nT=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\nG=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of degrees\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A hollow circular rod is attached to a wall and subjected to a torque T = {T()} kN-m at the free end.The rod has inner diameter 8 cm and outer diameter 10 cm.  Determine the angle of twist at x = {x()} mm. Assume G = {G()} GPa and L = {L()} mm.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T.set(random.randrange(20, 200, 1)/10)\n        G.set(random.randrange(30, 60, 1))\n        L.set(random.randrange(300, 800, 10))\n        x.set(L()*random.randrange(2,7,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        J = (math.pi/2)*((10/200)**4 - (8/200)**4)\n        angle = (T()*1000*x()/1000)/(G()*10**9*J)\n        instr= math.degrees(angle)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.15 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_22dynamicsubmit.html",
    "href": "problem6_22dynamicsubmit.html",
    "title": "Problem 6.22 - Power Transmission & Gear Assemblies",
    "section": "",
    "text": "[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"669\"\nP=reactive.Value(\"__\")\nrpm=reactive.Value(\"__\")\nT=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of N*m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The steel shaft is being turned by an electric motor providing {P()} kW of power at {rpm()} rpm. Power is extracted at B with a torque of {T()} N‚∏±m. Determine the remaining torque available for the gear at C.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        P.set(random.randrange(10, 30, 1))\n        rpm.set(random.randrange(60, 180, 5))\n        T.set(random.randrange(200, 400, 10))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        TA = P()*1000/(2*math.pi*rpm()/60)\n        instr= TA-T()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.22 - Power Transmission & Gear Assemblies"
    ]
  },
  {
    "objectID": "problem6_23dynamicsubmit.html",
    "href": "problem6_23dynamicsubmit.html",
    "title": "Problem 6.23 - Power Transmission & Gear Assemblies",
    "section": "",
    "text": "[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"670\"\nhp=reactive.Value(\"__\")\nrpm=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of lbf\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A lawnmower engine supplying {hp()} hp running at {rpm()} rpm is being used to power a homemade winch. Given the gearing shown, determine the heaviest load that can be lifted.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        hp.set(random.randrange(10, 50, 1)/10)\n        rpm.set(random.randrange(2000, 4000, 100))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        T = hp()*550/(2*math.pi*rpm()/60)*12\n        instr= T/0.5\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.23 - Power Transmission & Gear Assemblies"
    ]
  },
  {
    "objectID": "problem6_27dynamicsubmit.html",
    "href": "problem6_27dynamicsubmit.html",
    "title": "Problem 6.27 - Statically Indeterminate Torsion",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"287\"\nL=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nG = 75\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A steel rod of diameter d = {d()} mm is attached to walls A and C as shown. Two forces F = {F()} kN are applied at distance L = {L()} mm. If the shear modulus of the rod G = 75 GPa, determine the maximum shear stress in the rod.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(20, 60, 1))\n        F.set(random.randrange(2, 20, 1))\n        L.set(random.randrange(80, 120, 1))\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        TB = 2*F()*L()\n        J = (math.pi/2)*(d()/2000)**4\n        TA = 0.3/0.7*TB\n        TC = TB-TA\n        instr= ((TC*(d()/2000))/J)/10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.27 - Statically Indeterminate Torsion"
    ]
  },
  {
    "objectID": "problem6_28dynamicsubmit.html",
    "href": "problem6_28dynamicsubmit.html",
    "title": "Problem 6.28 - Statically Indeterminate Torsion",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"288\"\nT=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nG1=reactive.Value(\"__\")\nG2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A composite circular rod is made from two different plastics. A torque of T = {T()} kN-m is applied at the midpoint. The right end is free. What is the maximum stress in either material? Assume length L = {L()} cm and the shear modulus of the two materials are G&lt;sub&gt;1&lt;/sub&gt; = {G1()} GPa and G&lt;sub&gt;2&lt;/sub&gt; = {G2()} GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T.set(random.randrange(10, 200, 1)/10)\n        L.set(random.randrange(10, 50, 1))\n        G1.set(random.randrange(20, 50, 2)/10)\n        G2.set(G1()/2)\n        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        J1 = (math.pi/2)*(2/100)**4\n        J2 = (math.pi/2)*((3/100)**4-(2/100)**4)\n        RHS = G1()*10**9*J1+G2()*10**9*J2\n        LHS = T()*G2()*10**9*J2\n        T2 = LHS/RHS\n        T1 = T()-T2\n        instr= ((T1*(2/100))/J1)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.28 - Statically Indeterminate Torsion"
    ]
  },
  {
    "objectID": "problem6_29dynamicsubmit.html",
    "href": "problem6_29dynamicsubmit.html",
    "title": "Problem 6.29 - Statically Indeterminate Torsion",
    "section": "",
    "text": "Figure 1: A composite circular rod is made from aluminum and steel.\n\n\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"289\"\nT = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\nro = reactive.Value(\"__\")\nri = reactive.Value(\"__\")\nGA = 3800000\nGS = 11000000\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\n        \"**Please enter your ID number from your instructor and click to generate your problem**\"\n    ),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\n        \"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"\n    ),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\n        \"answer\", \"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"\n    ),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A composite circular rod is made from aluminum (G = 3,800 ksi) and steel (G = 11,000 ksi) as shown. A torque T = {T()} lb-ft is applied to the free end. What is the maximum stress in either material? Assume length L = {L()} in., outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} in., and inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} in.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        T.set(random.randrange(300, 2000, 100))\n        L.set(random.randrange(10, 60, 1))\n        ro.set(random.randrange(10, 60, 1) / 10)\n        ri.set(round(ro() / 1.5, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        JS = math.pi * ri() ** 4 / 2\n        JA = math.pi / 2 * (ro() ** 4 - ri() ** 4)\n        TA = T() * 12 * GA * JA / (GS * JS + GA * JA)\n        TS = T() * 12 - TA\n        instr = TS * ri() / JS / 1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(\n            f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\"\n        )\n\n        # Show feedback to the user.\n        feedback = ui.markdown(\n            f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = (\n            session.encoded_attempt()\n            if session.encoded_attempt is not None\n            else \"No attempts\"\n        )\n        yield f\"{final_encoded}\\n\\n\"\n\n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n\n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(\n                0.25\n            )  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.29 - Statically Indeterminate Torsion"
    ]
  },
  {
    "objectID": "problem6_30dynamicsubmit.html",
    "href": "problem6_30dynamicsubmit.html",
    "title": "Problem 6.30 - Statically Indeterminate Torsion",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"292\"\nT=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nGn = 11.4e6\nGa = 4e6\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A shaft is fixed between two walls. One portion is made from nickel (G&lt;sub&gt;nickel&lt;/sub&gt; = 11.4 x 10&lt;sup&gt;6&lt;/sup&gt; psi) with a diameter of d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in. The other portion is aluminum (G&lt;sub&gt;aluminum&lt;/sub&gt; = 4 x 10&lt;sup&gt;6&lt;/sup&gt; psi) with a diameter of d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in. A torque T = {T()} lb-ft is applied at the point where the two materials meet. If lengths L&lt;sub&gt;1&lt;/sub&gt; = {L1()} ft and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} ft, what is the maximum shear stress in the shaft?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d1.set(random.randrange(10, 60, 1)/10)\n        d2.set(round(d1()*2, 2))\n        T.set(random.randrange(500, 2000, 100))\n        L1.set(random.randrange(4, 20, 2))\n        L2.set(L1()/2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Jn = (math.pi/2)*(d1()/2)**4\n        Ja = (math.pi/2)*(d2()/2)**4\n        TN = T()*12*L2()*12*Gn*Jn/(L1()*12*Ga*Ja+L2()*12*Gn*Jn)\n        TA = T()*12-TN\n        tauA = TA*d2()/2/Ja\n        tauN = TN*d1()/2/Jn\n        if tauA&gt;=tauN:\n            instr = tauA\n        else:\n            instr = tauN\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.30 - Statically Indeterminate Torsion"
    ]
  },
  {
    "objectID": "problem6_31dynamicsubmit.html",
    "href": "problem6_31dynamicsubmit.html",
    "title": "Problem 6.31 - Statically Indeterminate Torsion",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"293\"\nT=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nG = 80\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two steel (G = 80 GPa) circular rods are firmly welded together and attached between two walls. Assume d&lt;sub&gt;1&lt;/sub&gt; = {d1()} mm, d&lt;sub&gt;2&lt;/sub&gt; = {d2()} mm, and L  = {L()} mm. A torque T = {T()} N-m is applied at the welded joint as shown. What is the highest stress in either rod?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d1.set(random.randrange(20, 50, 1))\n        d2.set(round(d1()*.8, 2))\n        L.set(random.randrange(100, 800, 10))\n        T.set(random.randrange(10, 300, 5))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        J1 = (math.pi/2)*(d1()/2000)**4\n        J2 = (math.pi/2)*(d2()/2000)**4\n        RHS = J1/J2\n        Tb = (T()/(RHS+1))\n        Ta = T() - Tb\n        tauA = (Ta*d1()/2000/J1)/10**6\n        tauB = (Tb*d2()/2000/J2)/10**6\n        if tauA&gt;=tauB:\n            instr = tauA\n        else:\n            instr = tauB\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6 Problems",
      "Problem 6.31 - Statically Indeterminate Torsion"
    ]
  },
  {
    "objectID": "problem7_1dynamicsubmit.html",
    "href": "problem7_1dynamicsubmit.html",
    "title": "Problem 7.1 - Internal Shear Force & Bending Moment by Equilibrium",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"305\"\nw = reactive.Value(\"__\")\nF = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your internal shear force answer in units of lb\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your moment answer in units of lb-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A beam is subjected to the loading shown, where w = {w()} lb/ft and F = {F()} lb. Determine the internal shear force and bending moment at section a-a.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(5, 150, 5))\n        F.set(random.randrange(300, 750, 10))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        Ay = (F()*2 - w()*6*3) / -6\n        instr1 = Ay - w()*3\n        instr2 = Ay*3 - w()*3*1.5\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.1 - Internal Shear Force & Bending Moment by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_2dynamicsubmit.html",
    "href": "problem7_2dynamicsubmit.html",
    "title": "Problem 7.2 - Internal Shear Force & Bending Moment by Equilibrium",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"306\"\nw=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN-m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is subjected to the loading shown, where w = {w()} kN/m and L = {L()} m. What is the internal bending moment at section a-a at x = {x()} m?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(20, 200, 1)/20)\n        L.set(random.randrange(20, 50, 2)/10)\n        x.set(L()/2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= w()*L()*x()-w()*L()**2-w()*x()**3/(6*L())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.2 - Internal Shear Force & Bending Moment by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_3dynamicsubmit.html",
    "href": "problem7_3dynamicsubmit.html",
    "title": "Problem 7.3 - Internal Shear Force & Bending Moment by Equilibrium",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"309\"\nF1 = reactive.Value(\"__\")\nF2 = reactive.Value(\"__\")\nF3 = reactive.Value(\"__\")\nŒò = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your internal shear force answer in units of lb\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your moment answer in units of lb-in\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"Three loads are applied to the structure as shown, where F&lt;sub&gt;1&lt;/sub&gt; = {F1()} lb., F&lt;sub&gt;2&lt;/sub&gt; = {F2()} lb., and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} lb applied at an angle Œò = {Œò()} ¬∞. Determine the internal shear force and bending moment at section aa.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(10, 30, 1))\n        F2.set(random.randrange(10, 30, 1))\n        F3.set(random.randrange(10, 30, 1))\n        Œò.set(random.randrange(45, 55, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = -F3() + F3()*math.sin(math.radians(Œò()))\n        instr2 = 2*F1() - 2*F2() - 4*F3()*math.sin(math.radians(Œò()))\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.3 - Internal Shear Force & Bending Moment by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_14dynamicsubmit.html",
    "href": "problem7_14dynamicsubmit.html",
    "title": "Problem 7.14 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"318\"\nw = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your internal shear force answer in units of kip\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your moment answer in units of kip-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"Plot the shear force and bending moment diagrams for the loading shown. Assume w = {w()} kip/ft and L = {L()} ft. What is the maximum absolute shear force and maximum absolute bending moment?\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(30, 200, 1)/10)\n        L.set(random.randrange(40, 100, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = 3/4*w()*L()\n        instr2 = instr1**2/(2*w())\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n            \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.14 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_15dynamicsubmit.html",
    "href": "problem7_15dynamicsubmit.html",
    "title": "Problem 7.15 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"320\"\nM=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\",\"Maximum absolute shear force in units of kip\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\",\"Maximum absolute bending moment in units of kip-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n    \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Plot the shear force and bending moment diagrams for the loading shown. Assume M = {M()} kip-ft, L&lt;sub&gt;1&lt;/sub&gt; = {L1()} ft, and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} ft. What is the maximum absolute shear force and maximum absolute bending moment? \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        M.set(random.randrange(5, 80, 1))\n        L1.set(random.randrange(30, 100, 1)/10)\n        L2.set(round(L1()*4/3,1))\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1= abs(M()/L2())\n        instr2 = M()\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n            \napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.15 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_16dynamicsubmit.html",
    "href": "problem7_16dynamicsubmit.html",
    "title": "Problem 7.16 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"322\"\nw=reactive.Value(\"__\")\nM=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\",\"Maximum absolute shear force in units of lb\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\",\"Maximum absolute bending moment in units of lb-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n    \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Plot the shear force and bending moment diagrams for the loading shown. Assume w = {w()} lb/ft, M = {M()} lb-ft, and L = {L()} ft. What is the maximum absolute shear force and maximum absolute bending moment? \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10, 100, 1))\n        M.set(random.randrange(100, 3300, 10))\n        L.set(random.randrange(5, 15, 1))\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        By = (M()+w()*L()*1.5*L())/L()\n        Ay = w()*L()-By\n        Vm1 = abs(Ay)\n        Vm2 = abs(Ay+By)\n        if Vm1&gt;=Vm2:\n            instr1 = Vm1\n        else:\n            instr1 = Vm2\n        Mm1 = abs(M())\n        Mm2 = abs(M()-((M()+w()*L()*3*L()/2)/L()-w()*L())*L())\n        if Mm1&gt;=Mm2:\n            instr2 = Mm1\n        else:\n            instr2 = Mm2\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.16 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_25dynamicsubmit.html",
    "href": "problem7_25dynamicsubmit.html",
    "title": "Problem 7.25 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"321\"\nW1=reactive.Value(\"__\")\nW2=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of lb\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A shelf is loaded with four boxes as shown. Assume W&lt;sub&gt;1&lt;/sub&gt; = {W1()} lb, W&lt;sub&gt;2&lt;/sub&gt; = {W2()} lb, and L = {L()} ft. Determine the maximum internal shear force.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        W1.set(random.randrange(5,75,1))\n        W2.set(W1()*2)\n        L.set(random.randrange(10,50,1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        R2 = (-W1()*L()/2+W2()*L()/2+W1()*1.5*L()+W2()*2.5*L())/(2*L())\n        R1 = 2*W1()+2*W2()-R2\n        V1 = -W1()\n        V2 = V1+R1\n        V3 = V2-W2()\n        V4 = V3-W1()\n        V5 = V4+R2\n        instr = max(abs(V1), abs(V2), abs(V3), abs(V4), abs(V5))\n\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.25 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_26dynamicsubmit.html",
    "href": "problem7_26dynamicsubmit.html",
    "title": "Problem 7.26 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"330\"\nw=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\",\"Maximum absolute shear force in units of kN\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\",\"Maximum absolute bending moment in units of kN-m\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n    \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Plot the shear force and bending moment diagrams for the loading shown. Assume w = {w()} kN/m, L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m, and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m. What is the maximum absolute shear force and maximum absolute bending moment? \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10, 75, 1))\n        L2.set(random.randrange(10, 50, 1)/10)\n        L1.set(round(L2()*3,1))\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1= abs((w()*(L1()+L2())-((L1()+L2())/2*w()*(L1()+L2()))/L1())-w()*L1())\n        instr2 = abs((w()*(L1()+L2())-((L1()+L2())/2*w()*(L1()+L2()))/L1())**2/(2*w()))\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.26 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_27dynamicsubmit.html",
    "href": "problem7_27dynamicsubmit.html",
    "title": "Problem 7.27 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"332\"\nw=reactive.Value(\"__\")\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is loaded as shown. Determine the distance from point A to where the internal shear force is zero. Assume w = {w()} kN/m, F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN, and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(2,10,1))\n        F1.set(w()*random.randrange(15,25,1)/10)\n        F2.set(random.randrange(5,25,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr = F1()*3/(w()*3)\n\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.27 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_28dynamicsubmit.html",
    "href": "problem7_28dynamicsubmit.html",
    "title": "Problem 7.28 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"333\"\nw1=reactive.Value(\"__\")\nw2=reactive.Value(\"__\")\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\",\"Maximum absolute shear force in units of kN\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\",\"Maximum absolute bending moment in units of kN-m\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n    \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Plot the shear force and bending moment diagrams for the loading shown. Assume w&lt;sub&gt;1&lt;/sub&gt; = {w1()} kN/m, and w&lt;sub&gt;2&lt;/sub&gt; = {w2()} kN/m. What is the maximum absolute shear force and maximum absolute bending moment? \")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w2.set(random.randrange(10, 50, 1))\n        w1.set(w2()*5)\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1= abs(0.4*w2())\n        instr2 = abs(0.4*w2()*0.4*0.5 + 0.4*w2()*0.1*0.5)\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        elif correct1:\n            check = f\" {'correct for answer 1 and incorrect for answer 2.'}\"\n        elif correct2:\n            check = f\"{'incorrect for answer 1 and correct for answer 2.'}\"\n        else:\n            check = f\"{'both incorrect.'}\"\n            \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.28 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_29dynamicsubmit.html",
    "href": "problem7_29dynamicsubmit.html",
    "title": "Problem 7.29 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"334\"\nw1=reactive.Value(\"__\")\nw2=reactive.Value(\"__\")\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\",\"Maximum absolute shear force in units of kip\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\",\"Maximum absolute bending moment in units of kip-ft\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n    \n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Plot the shear force and bending moment diagrams for the loading shown. Assume w&lt;sub&gt;1&lt;/sub&gt; = {w1()} kip/ft and w&lt;sub&gt;2&lt;/sub&gt; = {w2()} kip/ft. What is the maximum absolute shear force and maximum absolute bending moment?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w1.set(random.randrange(10, 300, 1)/10)\n        w2.set(w1()*2)\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        By = 13*(w2()-w1())/30+6.5*w1()\n        Cy = 13*w1()+13*(w2()-w1())/2-By\n     #   instr1= abs(By+Cy-9*w1()-162/(13*(w2()-w1())))\n     #   instr2 = abs(5*By-81*w1()/2-486/(13*(w2()-w1())))\n        instr1 = max(5.1854*w1(), Cy-5.1854*w1())\n        instr2 = 15.17*w1()\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 7 Problems",
      "Problem 7.29 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem8_1dynamicsubmit.html",
    "href": "problem8_1dynamicsubmit.html",
    "title": "Problem 8.1 - Centroid",
    "section": "",
    "text": "[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"675\"\nb1=reactive.Value(\"__\")\nb2=reactive.Value(\"__\")\nh1=reactive.Value(\"__\")\nh2=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"For the composite cross-section shown, determine the centroid location, measured from the base. Assume dimensions b&lt;sub&gt;1&lt;/sub&gt; = {b1()} mm, b&lt;sub&gt;2&lt;/sub&gt; = {b2()} mm, h&lt;sub&gt;1&lt;/sub&gt; = {h1()} mm, h&lt;sub&gt;2&lt;/sub&gt; = {h2()} mm, and t = {t()} mm.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b1.set(random.randrange(20,50,1))\n        b2.set(round(b1(),1)*round(random.randrange(50,70,1)/10))\n        h1.set(random.randrange(5,10,1))\n        h2.set(b2())\n        t.set(random.randrange(3,10,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        y1 = h1()+h2()/2\n        y2 = y1\n        y3 = h1()/2\n        A1 = h2()*b2()\n        A2 = -(b2()-2*t())*(h2()-2*t())\n        A3 = h1()*(2*b1()+b2())\n        instr = (y1*A1+y2*A2+y3*A3)/(A1+A2+A3)\n\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 8 Problems",
      "Problem 8.1 - Centroid"
    ]
  },
  {
    "objectID": "problem8_2dynamicsubmit.html",
    "href": "problem8_2dynamicsubmit.html",
    "title": "Problem 8.2 - Centroid",
    "section": "",
    "text": "[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"676\"\na=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"For the beam cross-section shown, determine the centroid location, measured from the top surface. Assume dimensions a = 3 in. and b = {b()} in.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b.set(random.randrange(30, 50, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        y1 = 0.4317\n        y2 = y1\n        y3 = 0.375\n        y4 = 1.25\n        y5 = 1.75+b()/3\n        y6 = y5\n        y7 = 1.75+b()/2\n        A1 = 0.4418\n        A2 = A1\n        A3 = 3*0.75\n        A4 = 4.5\n        A5 = 0.625*b()\n        A6 = A5\n        A7 = 2*b()\n        instr= (y1*A1+y2*A2+y3*A3+y4*A4+y5*A5+y6*A6+y7*A7)/(A1+A2+A3+A4+A5+A6+A7)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 8 Problems",
      "Problem 8.2 - Centroid"
    ]
  },
  {
    "objectID": "problem8_7dynamicsubmit.html",
    "href": "problem8_7dynamicsubmit.html",
    "title": "Problem 8.7 - Area Moment of Inertia",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"347\"\nb=reactive.Value(\"__\")\nc=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\na=reactive.Value(\"__\")\nd1=reactive.Value(\"__\")\nd2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\\u2074\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The cross-section shows a concrete beam with two hollow round holes. Determine the area moment of inertia about the beam's centroid. Assume lengths a = {a()} in., b = {b()} in., c = {c()} in., d = {d()} in., d&lt;sub&gt;1&lt;/sub&gt; = {d1()} in., and d&lt;sub&gt;2&lt;/sub&gt; = {d2()} in.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b.set(random.randrange(20, 60, 1)/10)\n        c.set(round(b()*3,1))\n        d.set(b()*2)\n        a.set(b()*2.5)\n        d1.set(round(b()*1.5,1))\n        d2.set(d1()*2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        A1 = (b()+c()+d())*2*a()\n        h1 = (b()+c()+d())/2\n        A2 = (d2()/2)**2*math.pi\n        h2 = d()\n        A3 = (d1()/2)**2*math.pi\n        h3 = d()+c()\n        h = (A1*h1-A2*h2-A3*h3)/(A1-A2-A3)\n        y1 = h-h1\n        y2 = h-h2\n        y3 = h-h3\n        I1 = 2*a()*(b()+c()+d())**3/12\n        I2 = (d2()/2)**4*math.pi/4\n        I3 = (d1()/2)**4*math.pi/4\n        instr = I1+A1*y1**2-(I2+A2*y2**2)-(I3+A3*y3**2)\n\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 8 Problems",
      "Problem 8.7 - Area Moment of Inertia"
    ]
  },
  {
    "objectID": "problem9_1dynamicsubmit.html",
    "href": "problem9_1dynamicsubmit.html",
    "title": "Problem 9.1 - Bending Stress",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"342\"\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Maximum bending stress in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam with a rectangular cross-section of base b = {b()} mm and h = {h()} mm is subjected to the leading shown. If w = {w()} kN/m and L = {L()} m, determine the magnitude of the largest bending stress in the beam.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b.set(random.randrange(50, 150, 5))\n        h.set(random.randrange(b()*5)/2)\n        w.set(random.randrange(10, 200, 1)/10)\n        L.set(random.randrange(20, 100, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Ay = 3*w()*L()/4\n        I = h()**3*b()/1200000000\n        y = h()/200\n        x = Ay/w()\n        M = Ay*x/2\n        instr= M*y/I\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.1 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_2dynamicsubmit.html",
    "href": "problem9_2dynamicsubmit.html",
    "title": "Problem 9.2 - Bending Stress",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"343\"\nb1=reactive.Value(\"__\")\nb2=reactive.Value(\"__\")\nh1=reactive.Value(\"__\")\nh2=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam has the cross-section shown, where b&lt;sub&gt;1&lt;/sub&gt; = {b1()} mm, b&lt;sub&gt;2&lt;/sub&gt; = {b2()} mm, h&lt;sub&gt;1&lt;/sub&gt; = {h1()} mm, and h&lt;sub&gt;2&lt;/sub&gt; = {h2()} mm. The beam is subjected to a concentrated load F = {F()} kN at its midpoint. If length L = {L()} m, determine the magnitude of the maximum bending stress in the beam.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b1.set(random.randrange(10, 20, 1))\n        b2.set((b1()*3))\n        h1.set((b1()*2))\n        h2.set(b1())\n        F.set(random.randrange(20, 300, 1)/10)\n        L.set(random.randrange(20, 100, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Ay = F()/2\n        M = Ay*L()\n        A1 = (2*h1()+h2())*(2*b1()+b2())\n        y1 = (2*h1()+h2())/2\n        A2 = h1()*b2()\n        y2 = 3*h1()/2\n        yc = (A1*y1-A2*y2)/(A1-A2)\n        I1 = ((2*b1()+b2())*(2*h1()+h2())**3)/12\n        I2 = (b2()*h1()**3)/12\n        Ic = ((I1+A1*(y1-yc)**2)-(I2+A2*(y2-yc)**2))/(10**12)\n        instr= (M*(2*h1()+h2()-yc)/Ic)/10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.2 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_3dynamicsubmit.html",
    "href": "problem9_3dynamicsubmit.html",
    "title": "Problem 9.3 - Bending Stress",
    "section": "",
    "text": "Figure 1: A diving board with a person standing on it.\n\n\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"344\"\nma=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\ng = 9.81\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A person of mass m = {ma()} kg stands on the end of a diving board with cross-section b = {b()} mm and h = {h()} mm. If lengths L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m, determine the maximum bending stress in the board. Assume g = 9.81 m/s&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        ma.set(random.randrange(55, 100, 1))\n        h.set(random.randrange(30, 60, 1))\n        b.set((h()*6))\n        L1.set(random.randrange(10, 30, 1)/10)\n        L2.set(L1()*2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Mo = float(ma())*L2()*g\n        ytop = h()/2000\n        I = ((b()/1000)*((h()/1000)**3))/12\n        instr= float(Mo)*ytop/I/10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.3 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_4dynamicsubmit.html",
    "href": "problem9_4dynamicsubmit.html",
    "title": "Problem 9.4 - Bending Stress",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"345\"\nro=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam with a hollow circular cross-section of outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} in. and inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} in. is subjected to a distributed load as shown. If w = {w()} lb/ft, L&lt;sub&gt;1&lt;/sub&gt; = {L1()} ft, and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} ft, determine the magnitude of the maximum bending stress in the beam.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        ro.set(random.randrange(40, 100, 1)/10)\n        ri.set(ro()-random.randrange(5, 10, 1)/10)\n        w.set(random.randrange(100, 800, 10))\n        L1.set(random.randrange(30, 100, 1)/10)\n        L2.set(L1()*2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        R = w()*float(L2())/2\n        M = -R*(L1()+L2()/2)+w()*L2()**2/8\n        I = math.pi*(ro()**4-ri()**4)/4\n        instr= abs(M*ro()*12/I)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.4 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_5dynamicsubmit.html",
    "href": "problem9_5dynamicsubmit.html",
    "title": "Problem 9.5 - Bending Stress",
    "section": "",
    "text": "Figure 1: The cross section of a beam.\n\n\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"346\"\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nM=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam has the cross-section shown where b = {b()} in. and h = {h()} in. If the cross-section is subjected to an internal bending moment of {M()} kip-in, determine the magnitude of the bending stress at the bottom of the cross-section.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b.set(random.randrange(20, 50, 1)/10)\n        h.set(b())\n        M.set(random.randrange(5, 100, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        y = 11*h()/9\n        I = (2*b()*h()**3/12)+(2*b()*h()*(3*h()/2-y)**2)+(b()*h()**3/18)+(b()*h()*(2*h()/3-y)**2)\n        instr= M()*y/I\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.5 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_21dynamicsubmit.html",
    "href": "problem9_21dynamicsubmit.html",
    "title": "Problem 9.21 - Beam Design",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"360\"\nw=reactive.Value(\"__\")\nsigma=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nA=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam with a rectangular cross-section is subjected to a distributed load w = {w()} kN/m as shown. The maximum allowable bending stress in the beam is {sigma()} MPa. If length L = {L()} m and the cross-sectional area of the beam is A = {A()} m&lt;sup&gt;2&lt;/sup&gt;, determine the required width (b) of the cross-section.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(20, 100, 1)/10)\n        sigma.set(random.randrange(5, 30, 1))\n        L.set(random.randrange(30, 100, 1)/10)\n        A.set(random.randrange(15, 50, 5)/1000)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        R = w()*L()/2\n        M = R*L()/2-w()*L()**2/8\n        h = 6*M/(sigma()/1000*A())/10**6\n        instr= A()/h*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.21 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_22dynamicsubmit.html",
    "href": "problem9_22dynamicsubmit.html",
    "title": "Problem 9.22 - Beam Design",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"364\"\nF = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\nsigma = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer for the first beam number\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer for the second beam number\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A wide-flange beam supports two loads F = {F()} kN as shown. If L = {L()} m and the allowable stress is œÉ = {sigma()} MPa, what is the lightest W-beam in Appendix A that could be used for the beam?\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(10, 30, 1))\n        L.set(random.randrange(20, 50, 1)/10)\n        sigma.set(random.randrange(100, 250, 10))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        M = F()*L()\n        S = M/sigma()*10**3\n\n        # Create a dataframe\n        df = pd.DataFrame()\n\n        # Define Beam Name Columns\n        df[\"I-Beam First Num\"] = [1000,1000,1000,920,920,920,760,760,760,610,610,610,530,530,530,460,460,460,410,410,410,360,360,360,310,310,310]\n\n        #Define Weight Column\n        df[\"Weight\"] = [642,443,393,725,368,313,484,257,147,415,195,125,300,182,101,193,113,60,100,60,46.1,134,79,51,158,79,38.7]\n        \n        # Define S Column\n        df[\"Sx (x10^3 mm^3)\"] = [27700,19200,15900,30000,15000,11800,17000,8870,4410,11800,5390,3210,7550,4470,2290,4200,2390,1120,1920,1060,773,2340,1270,796,2380,1160,547]\n\n        # Create Solution Dataframe\n        instr=pd.DataFrame()\n        instr[\"First Num\"] =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        instr[\"Second Num\"] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        \n        # Search for Possible Solutions\n        i = 0\n        while i &lt; 27:\n            if df.iloc[i, 2] &gt;= S:\n                instr.iloc[i, 0] = df.iloc[i, 0]\n                instr.iloc[i, 1] = df.iloc[i, 1]\n            i += 1\n        instr = instr.loc[(instr != 0).any(axis=1)]\n\n        #Find Minimum Weight\n        wmin = min(instr.iloc[:,1])\n        mask = instr['Second Num'] == wmin\n        instr = pd.DataFrame(instr[mask])\n\n        correct1 = float(input.answer1()) == instr.iloc[0,0]\n        correct2 = float(input.answer2()) == instr.iloc[0,1]\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct' if correct2 else 'incorrect'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.22 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_23dynamicsubmit.html",
    "href": "problem9_23dynamicsubmit.html",
    "title": "Problem 9.23 - Beam Design",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"365\"\nw0 = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\nsigma = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer for the first beam number\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer for the second beam number\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A wide flange beam supports the distributed load shown, where w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kN/m. If length L = {L()} m and the allowable stress is œÉ = {sigma()} MPa, what is the lightest W-beam in Appendix A that could be used for the beam?\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w0.set(random.randrange(200, 300, 1)/10)\n        L.set(random.randrange(20, 50, 1)/10)\n        sigma.set(random.randrange(100, 250, 10))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        R = w0()*L()/2\n        M = R*L()-R*L()/3\n        S = M/sigma()*10**3\n\n        # Create a dataframe\n        df = pd.DataFrame()\n\n        # Define Beam Name Columns\n        df[\"I-Beam First Num\"] = [1000,1000,1000,920,920,920,760,760,760,610,610,610,530,530,530,460,460,460,410,410,410,360,360,360,310,310,310]\n\n        #Define Weight Column\n        df[\"Weight\"] = [642,443,393,725,368,313,484,257,147,415,195,125,300,182,101,193,113,60,100,60,46.1,134,79,51,158,79,38.7]\n        \n        # Define S Column\n        df[\"Sx (x10^3 mm^3)\"] = [27700,19200,15900,30000,15000,11800,17000,8870,410,11800,5390,3210,7550,4470,2290,4200,2390,1120,1920,1060,773,2340,1270,796,2380,1160,547]\n\n        # Create Solution Dataframe\n        instr=pd.DataFrame()\n        instr[\"First Num\"] =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        instr[\"Second Num\"] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        \n        # Search for Possible Solutions\n        i = 0\n        while i &lt; 27:\n            if df.iloc[i, 2] &gt;= S:\n                instr.iloc[i, 0] = df.iloc[i, 0]\n                instr.iloc[i, 1] = df.iloc[i, 1]\n            i += 1\n        instr = instr.loc[(instr != 0).any(axis=1)]\n\n        #Find Minimum Weight\n        wmin = min(instr.iloc[:,1])\n        mask = instr['Second Num'] == wmin\n        instr = pd.DataFrame(instr[mask])\n\n        correct1 = float(input.answer1()) == instr.iloc[0,0]\n        correct2 = float(input.answer2()) == instr.iloc[0,1]\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct' if correct2 else 'incorrect'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.23 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_24dynamicsubmit.html",
    "href": "problem9_24dynamicsubmit.html",
    "title": "Problem 9.24 - Beam Design",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"366\"\nw = reactive.Value(\"__\")\nF = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\nFS = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer for the first beam number\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer for the second beam number\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A wide flange I-beam is fixed at one end into a wall, and loaded with both a distributed load w = {w()} kN/m and a point load F = {F()} kN. If length L = {L()} m and the failure stress is 250 MPa, what is the lightest W-beam from Appendix A that could be used for the beam? Use a factor of safety of {FS()}.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(5, 50, 1)/10)\n        F.set(random.randrange(10, 100, 1)/10)\n        L.set(random.randrange(50, 150, 1)/10)\n        FS.set(random.randrange(15, 30, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        M = w()*L()*L()/2+F()*L()\n        sigma_allow = 250/FS()\n        S = M/sigma_allow*10**3\n\n        # Create a dataframe\n        df = pd.DataFrame()\n\n        # Define Beam Name Columns\n        df[\"I-Beam First Num\"] = [1000,1000,1000,920,920,920,760,760,760,610,610,610,530,530,530,460,460,460,410,410,410,360,360,360,310,310,310]\n\n        #Define Weight Column\n        df[\"Weight\"] = [642,443,393,725,368,313,484,257,147,415,195,125,300,182,101,193,113,60,100,60,46.1,134,79,51,158,79,38.7]\n        \n        # Define S Column\n        df[\"Sx (x10^3 mm^3)\"] = [27700,19200,15900,30000,15000,11800,17000,8870,4410,11800,5390,3210,7550,4470,2290,4200,2390,1120,1920,1060,773,2340,1270,796,2380,1160,547]\n\n        # Create Solution Dataframe\n        instr=pd.DataFrame()\n        instr[\"First Num\"] =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        instr[\"Second Num\"] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        \n        # Search for Possible Solutions\n        i = 0\n        while i &lt; 27:\n            if df.iloc[i, 2] &gt;= S:\n                instr.iloc[i, 0] = df.iloc[i, 0]\n                instr.iloc[i, 1] = df.iloc[i, 1]\n            i += 1\n        instr = instr.loc[(instr != 0).any(axis=1)]\n\n        #Find Minimum Weight\n        wmin = min(instr.iloc[:,1])\n        mask = instr['Second Num'] == wmin\n        instr = pd.DataFrame(instr[mask])\n\n        correct1 = float(input.answer1()) == instr.iloc[0,0]\n        correct2 = float(input.answer2()) == instr.iloc[0,1]\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct' if correct2 else 'incorrect'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.24 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_25dynamicsubmit.html",
    "href": "problem9_25dynamicsubmit.html",
    "title": "Problem 9.25 - Beam Design",
    "section": "",
    "text": "Figure 1: A I beam is subjected to a distributed load and a tip load.\n\n\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"367\"\nw = reactive.Value(\"__\")\nF = reactive.Value(\"__\")\nL2 = reactive.Value(\"__\")\nL1 = reactive.Value(\"__\")\nsigma = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer for the first beam number\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer for the second beam number\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A wide flange I-beam is subjected to both a distributed load w = {w()} kN/m and a point load F = {F()} kN. If length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m, L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m, and the failure stress is {sigma()} MPa, what is the lightest W-beam from Appendix A that could be used for the beam?\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(20, 200, 1)/10)\n        F.set(random.randrange(10, 400, 1)/10)\n        L2.set(random.randrange(20, 60, 1)/10)\n        L1.set(L2()*2)\n        sigma.set(random.randrange(100, 250, 10))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        FA = (w()*L1()*L1()/2-F()*L2())/L1()\n        x = FA/w()\n        M1 = abs(FA*x*0.5)\n        M2 = abs(FA*L1()-w()*L1()*L1()/2)\n        M = max(M1,M2)\n        S = M/sigma()*10**3\n\n        # Create a dataframe\n        df = pd.DataFrame()\n\n        # Define Beam Name Columns\n        df[\"I-Beam First Num\"] = [1000,1000,1000,920,920,920,760,760,760,610,610,610,530,530,530,460,460,460,410,410,410,360,360,360,310,310,310]\n\n        #Define Weight Column\n        df[\"Weight\"] = [642,443,393,725,368,313,484,257,147,415,195,125,300,182,101,193,113,60,100,60,46.1,134,79,51,158,79,38.7]\n        \n        # Define S Column\n        df[\"Sx (x10^3 mm^3)\"] = [27700,19200,15900,30000,15000,11800,17000,8870,4410,11800,5390,3210,7550,4470,2290,4200,2390,1120,1920,1060,773,2340,1270,796,2380,1160,547]\n\n        # Create Solution Dataframe\n        instr=pd.DataFrame()\n        instr[\"First Num\"] =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        instr[\"Second Num\"] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        \n        # Search for Possible Solutions\n        i = 0\n        while i &lt; 27:\n            if df.iloc[i, 2] &gt;= S:\n                instr.iloc[i, 0] = df.iloc[i, 0]\n                instr.iloc[i, 1] = df.iloc[i, 1]\n            i += 1\n        instr = instr.loc[(instr != 0).any(axis=1)]\n\n        #Find Minimum Weight\n        wmin = min(instr.iloc[:,1])\n        mask = instr['Second Num'] == wmin\n        instr = pd.DataFrame(instr[mask])\n\n        correct1 = float(input.answer1()) == instr.iloc[0,0]\n        correct2 = float(input.answer2()) == instr.iloc[0,1]\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct' if correct2 else 'incorrect'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.25 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_31dynamicsubmit.html",
    "href": "problem9_31dynamicsubmit.html",
    "title": "Problem 9.31 - Unsymmetric Bending",
    "section": "",
    "text": "Figure 1: Two loads are applied at the free end of a cantilever beam.\n\n\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"480\"\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two loads, F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kips and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kips, are applied at the end of a cantilever beam as shown. Both loads act through the center of the rectangular cross-section of base b = {b()} in. and height h = {h()} in. If length L = {L()} ft, determine the stress at point P in the beam at the wall.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F1.set(random.randrange(5, 20, 1))\n        F2.set(random.randrange(5, 20, 1))\n        b.set(random.randrange(3, 10, 1))\n        h.set(b()*2)\n        L.set(random.randrange(4, 10, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Mx = F2()*L()*12\n        My = F1()*L()*12\n        instr = Mx*h()/2/(b()*h()**3/12) + My*b()/2/(h()*b()**3/12)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.31 - Unsymmetric Bending"
    ]
  },
  {
    "objectID": "problem9_32dynamicsubmit.html",
    "href": "problem9_32dynamicsubmit.html",
    "title": "Problem 9.32 - Unsymmetric Bending",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"483\"\nMz=reactive.Value(\"__\")\nMy=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"Two moments, M&lt;sub&gt;z&lt;/sub&gt; = {Mz()} kN-m and M&lt;sub&gt;y&lt;/sub&gt; = {My()} kN-m, act on a beam with the rectangular cross-section shown. If base b = {b()} mm and height h = {h()} mm, determine the bending stress at point A. Recall the convention that tensile stresses are positive and compressive stresses are negative.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        Mz.set(random.randrange(10, 200, 1)/10)\n        My.set(random.randrange(10, 200, 1)/10)\n        b.set(random.randrange(100, 300, 20))\n        h.set(b() * 0.75)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Iy = h()*b()**3/12\n        Iz = b()*h()**3/12\n        instr= -(My()*b()/2/Iy+Mz()*h()/2/Iz)*10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.32 - Unsymmetric Bending"
    ]
  },
  {
    "objectID": "problem9_33dynamicsubmit.html",
    "href": "problem9_33dynamicsubmit.html",
    "title": "Problem 9.33 - Unsymmetric Bending",
    "section": "",
    "text": "{width=‚Äú300‚Äù.} [Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"484\"\nF=reactive.Value(\"__\")\ntheta=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A W14 x 34 steel beam supports a load F = {F()} kips at its center. The beam is on a sloped roof so the load acts at an angle Œò = {theta()}¬∞ as shown. If length L = {L()} ft, determine the stress at point A. Recall the convention that tensile stresses are positive and compressive stresses are negative.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(50, 200, 1)/10)\n        theta.set(random.randrange(10, 30, 1))\n        L.set(random.randrange(3, 10, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Iy = 23.3\n        Iz = 340\n        M = F()/2*L()*12\n        Mz = M*math.cos(theta()*math.pi/180)\n        My = M*math.sin(theta()*math.pi/180)\n        z = 3.375\n        y = 7\n        instr= -My*z/Iy-Mz*y/Iz\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.33 - Unsymmetric Bending"
    ]
  },
  {
    "objectID": "problem9_34dynamicsubmit.html",
    "href": "problem9_34dynamicsubmit.html",
    "title": "Problem 9.34 - Unsymmetric Bending",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"490\"\nF=reactive.Value(\"__\")\ntheta=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cantilevered beam is subjected to a load F = {F()} kN at its end, oriented Œò = {theta()}¬∞ from the vertical. If length L = {L()} m, determine the maximum bending stress in the beam. The beam has outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} mm and inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} mm.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(5, 30, 1))\n        theta.set(random.randrange(20, 30, 1))\n        L.set(random.randrange(2, 10, 1))\n        ro.set(random.randrange(40, 120, 4))\n        ri.set(ro()*0.75)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        M = F()*L()\n        My = M*math.sin(theta()*math.pi/180)\n        Mz = M*math.cos(theta()*math.pi/180)\n        I = math.pi/4*(ro()**4-ri()**4)\n        z = ro()*math.sin(theta()*math.pi/180)\n        y = ro()*math.cos(theta()*math.pi/180)\n        instr= (My*z/I+Mz*y/I)*10**6\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 9 Problems",
      "Problem 9.34 - Unsymmetric Bending"
    ]
  },
  {
    "objectID": "problem10_1dynamicsubmit.html",
    "href": "problem10_1dynamicsubmit.html",
    "title": "Problem 10.1 - 1st Moment of Area",
    "section": "",
    "text": "[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID=\"680\"\nb1=reactive.Value(\"__\")\nb2=reactive.Value(\"__\")\nh2=reactive.Value(\"__\")\nh1=reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Q at point A in units of in\\u00b3\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Q at the centroid in units of in\\u00b3\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"For the built-up T-beam shown, determine the first moment of area, Q, at point A and at the centroid of the cross-section. Assume dimensions b&lt;sub&gt;1&lt;/sub&gt; = {b1()} in., b&lt;sub&gt;2&lt;/sub&gt; = {b2()} in., h&lt;sub&gt;1&lt;/sub&gt; = {h1()} in., and h&lt;sub&gt;2&lt;/sub&gt; = {h2()} in.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b1.set(random.randrange(10, 50, 1)/10)\n        b2.set(round(b1(),1)*(round(random.randrange(40, 60, 1)/10)))\n        h2.set(b1())\n        h1.set(round(b2(),1)+round(random.randrange(20, 60, 1)/10))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        y1 = h1()+h2()/2\n        y2 = h1()/2\n        A1 = b2()*h2()\n        A2 = h1()*b1()\n        ybar = (y1*A1+y2*A2)/(A1+A2)\n        instr1 = (y1-ybar)*A1\n        instr2 = ybar/2*ybar*b1()\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.1 - 1st Moment of Area"
    ]
  },
  {
    "objectID": "problem10_4dynamicsubmit.html",
    "href": "problem10_4dynamicsubmit.html",
    "title": "Problem 10.4 - Shear Stress",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"369\"\nw=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A simply supported beam is constructed from two wooden boards as shown. The beam supports a distributed load w = {w()} kN/m. If lengths L&lt;sub&gt;1&lt;/sub&gt; = {L1()} m and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} m, what is the maximum shear stress in the glue that holds the boards together?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10, 200, 1)/10)\n        L1.set(random.randrange(10, 50, 1)/10)\n        L2.set(L1()*2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        V = (L2()*w()*(L2()/2+L1()))/(L2()+2*L1())\n        I = 37.66*10**-6\n        Q = 0.22*10**-3\n        t = 0.02\n        instr= (V*Q)/(I*t)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.4 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_5dynamicsubmit.html",
    "href": "problem10_5dynamicsubmit.html",
    "title": "Problem 10.5 - Shear Stress",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"370\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A simply supported beam is constructed from two wooden boards as shown. The beam supports a concetrated load F = {F()} kN. If length L = {L()} m  and cross-section dimensions b = {b()} mm and h = {h()} mm, determine the shear stress in the glue that holds the boards together.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(50, 300, 1)/10)\n        L.set(random.randrange(40, 100, 1)/10)\n        h.set(random.randrange(20, 50, 1))\n        b.set(h()*2)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        V = F()/2\n        y = (h()**2*(h()+h()/2)+b()*h()**2/2)/(h()**2+b()*h())\n        I = h()**4/12+h()**2*(h()+h()/2-y)**2+b()*h()**3/12+b()*h()*(h()/2-y)**2\n        Q = h()**2*(h()+h()/2-y)\n        instr= V*Q/(I*h()/1000)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.5 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_6dynamicsubmit.html",
    "href": "problem10_6dynamicsubmit.html",
    "title": "Problem 10.6 - Shear Stress",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"371\"\nb1=reactive.Value(\"__\")\nb2=reactive.Value(\"__\")\nh1=reactive.Value(\"__\")\nh2=reactive.Value(\"__\")\nV=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A T-beam has dimensions b&lt;sub&gt;1&lt;/sub&gt; = {b1()} in., b&lt;sub&gt;2&lt;/sub&gt; = {b2()} in., h&lt;sub&gt;1&lt;/sub&gt; = {h1()} in., and h&lt;sub&gt;2&lt;/sub&gt; = {h2()} in. If the shear force at this section is V = {V()} kips, determine the shear stress at section a-a.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        b1.set(random.randrange(10, 30, 1)/10)\n        b2.set(round(b1()*9,1))\n        h1.set(round(b1()*6,1))\n        h2.set(b1())\n        V.set(random.randrange(20, 100, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        y = (b2()*h2()*(h1()+h2()/2)+h1()**2*b1()/2)/(b2()*h2()+h1()*b1())\n        I = b2()*h2()**3/12+b2()*h2()*(h1()+h2()/2-y)**2+b1()*h1()**3/12+b1()*h1()*(h1()/2-y)**2\n        Q = b2()*h2()*(h1()+h2()/2-y)\n        instr= V()*Q/(I*b1())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.6 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_7dynamicsubmit.html",
    "href": "problem10_7dynamicsubmit.html",
    "title": "Problem 10.7 - Shear Stress",
    "section": "",
    "text": "Figure 1: A beam constructed of two sections glued together is subjected to a force.\n\n\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"372\"\nL=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of length L = {L()} ft is constructed by gluing together two boards and is subjected to a concentrated load F = {F()} lb. The cross-section has dimensions b = {b()} in. and h = {h()} in. Determine the shear stress at the seam between the two boards at section a-a.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50, 150, 1)/10)\n        F.set(random.randrange(200, 2000, 10))\n        h.set(random.randrange(10, 50, 1)/10)\n        b.set(round(h()*3,1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        y = (b()*h()*(h()+h()/2)+h()**3/2)/(b()*h()+h()**2)\n        I = b()*h()**3/12+b()*h()*(h()+h()/2-y)**2+h()**4/12+h()**2*(h()/2-y)**2\n        Q = h()**2*(h()/2-y)\n        instr= F()*-Q/(I*h())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.7 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_8dynamicsubmit.html",
    "href": "problem10_8dynamicsubmit.html",
    "title": "Problem 10.8 - Shear Stress",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"373\"\nw=reactive.Value(\"__\")\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cantilever beam is loaded as shown, where w = {w()} lb/in., F&lt;sub&gt;1&lt;/sub&gt; = {F1()} lb, and F&lt;sub&gt;2&lt;/sub&gt; = {F2()} lb. What is the maximum shear stress in the beam?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(1, 20, 1))\n        F1.set(random.randrange(20, 200, 1))\n        F2.set(random.randrange(20, 200, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Ay = (30*w()+F1()-F2())\n        V1 = Ay\n        V2 = V1 - 30*w()\n        V3 = V2 - F1()\n        V = max(abs(V1),abs(V2),abs(V3))\n        instr= 1.5*V/30\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.8 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_17dynamicsubmit.html",
    "href": "problem10_17dynamicsubmit.html",
    "title": "Problem 10.17 - Shear Flow",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"380\"\nL=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of length L = {L()} ft is constructed by nailing together two boards with dimensions b = {b()} in. and h = {h()} in. The beam is subjected to a concentrated load F = {F()} lb as shown. Each nail can withstand a shear load of 100 lb. What is the minimum permissable spacing between nails?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50, 200, 1)/10)\n        h.set(random.randrange(10, 40, 1)/10)\n        b.set(h()*2)\n        F.set(random.randrange(100, 900, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = b()*(2*h())**3/12\n        t = b()\n        Q = h()**2*b()/2\n        q = F()*Q/I\n        instr= 100/q\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.17 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_18dynamicsubmit.html",
    "href": "problem10_18dynamicsubmit.html",
    "title": "Problem 10.18 - Shear Flow",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"381\"\nL=reactive.Value(\"__\")\nd=reactive.Value(\"__\")\nF1=reactive.Value(\"__\")\nF2=reactive.Value(\"__\")\nF3=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is constructed by nailing together two wooden boards as shown. The nails each have a diameter d = {d()} mm and can withstand a shear stress of 100 MPa. If loads F&lt;sub&gt;1&lt;/sub&gt; = {F1()} kN, F&lt;sub&gt;2&lt;/sub&gt; = {F2()} kN, and F&lt;sub&gt;3&lt;/sub&gt; = {F3()} kN, determine the maximum permissible spacing between the nails.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(5, 15, 1))\n        F1.set(random.randrange(2, 20, 1))\n        F2.set(random.randrange(2, 20, 1))\n        F3.set(random.randrange(2, 20, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        V1 = F1()+F3()-F2()\n        V2 = V1-F1()\n        V3 = V2+F2()\n        Vmax = max(abs(V1), abs(V2), abs(V3))\n        I = 11.52*10**-6\n        Q = 1.28*10**-4\n        Taub = Vmax*Q/(I*0.08)\n        instr= (100000*(d()/1000/2)**2*math.pi)/(Taub*0.08)*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.18 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_19dynamicsubmit.html",
    "href": "problem10_19dynamicsubmit.html",
    "title": "Problem 10.19 - Shear Flow",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"382\"\nL=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nVnail=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of length L = {L()} ft is constructed by nailing together three wooden boards. The beam is subjected to a concentrated load F = {F()} lb. If each nail can resist a shear load of {Vnail()} lb, determine the minimum permissible spacing between the nails.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(20, 100, 1)/10)\n        F.set(random.randrange(300, 900, 1))\n        Vnail.set(random.randrange(100, 200, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        V = F()/2\n        I = 43.08\n        Q = 10\n        Tau = V*Q/I\n        instr= Vnail()/Tau\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.19 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_20dynamicsubmit.html",
    "href": "problem10_20dynamicsubmit.html",
    "title": "Problem 10.20 - Shear Flow",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"384\"\nVN=reactive.Value(\"__\")\nV=reactive.Value(\"__\")\nb1=reactive.Value(\"__\")\nb2=reactive.Value(\"__\")\nh1=reactive.Value(\"__\")\nh2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A T-beam is constructed from two wooden boards nailed together as shown. The nails can withstand a shear load of {VN()} kN and the beam is subjected to a maximum shear force V = {V()} kN. If dimensions b&lt;sub&gt;1&lt;/sub&gt; = {b1()} mm, b&lt;sub&gt;2&lt;/sub&gt; = {b2()} mm, h&lt;sub&gt;1&lt;/sub&gt; = {h1()} mm, and h&lt;sub&gt;2&lt;/sub&gt; = {h2()} mm, determine the minimum permissible spacing between the nails.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        VN.set(random.randrange(5, 20, 1))\n        V.set(random.randrange(30, 60, 1))\n        b1.set(random.randrange(20, 50, 1))\n        b2.set(b1()*10)\n        h1.set(b1()*8)\n        h2.set(b1())\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        h = (h1()*b1()*h1()/2+b2()*h2()*(h1()+h2()/2))/(h1()*b1()+b2()*h2())\n        I = b1()*h1()**3/12+h1()*b1()*(h-h1()/2)**2+b2()*h2()**3/12+b2()*h2()*((h1()+h2()/2)-h)**2\n        Q = h2()*b2()*((h1()+h2()/2)-h)\n        Tau = V()*Q/1000/(I/10000*b1())\n        instr= VN()/(b1()*Tau)*10\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.20 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_21dynamicsubmit.html",
    "href": "problem10_21dynamicsubmit.html",
    "title": "Problem 10.21 - Shear Flow",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"385\"\nh1=reactive.Value(\"__\")\nh2=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nVN=reactive.Value(\"__\")\nV=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is constructed from two boards nailed together as shown, with dimensions b = {b()} in., h&lt;sub&gt;1&lt;/sub&gt; = {h1()} in., and h&lt;sub&gt;2&lt;/sub&gt; = {h2()} in.  The nails can withstand a shear load of {VN()} lb and the beam is subjected to a maximum shear force V = {V()} kips. Determine the minimum permissable spacing between the nails.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        h1.set(random.randrange(10, 50, 1)/10)\n        h2.set(h1()*2)\n        b.set(h1()*3)\n        VN.set(random.randrange(500, 1000, 10))\n        V.set(random.randrange(10, 50, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        y = (h1()+h2())/2\n        Q = (y-h1()/2)*b()*h1()\n        I = b()*(h1()+h2())**3/12\n        Tau = V()*1000*Q/(I*b())\n        instr= VN()/(b()*Tau)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 10 Problems",
      "Problem 10.21 - Shear Flow"
    ]
  },
  {
    "objectID": "problem11_1dynamicsubmit.html",
    "href": "problem11_1dynamicsubmit.html",
    "title": "Problem 11.1 - By Integration of Moment Equation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"391\"\nL=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cantilever beam of length L = {L()} m is subjected to a distributed load w = {w()} kN/m and concentrated load P = {P()} kN. Determine the maximum deflection of the beam. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50, 100, 1)/10)\n        w.set(random.randrange(30, 100, 1)/10)\n        P.set(random.randrange(100, 200, 1)/10)\n        EI.set(random.randrange(20000, 30000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= abs((-3*w()*L()**4-8*P()*L()**3)/(24*EI()))*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.1 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_2dynamicsubmit.html",
    "href": "problem11_2dynamicsubmit.html",
    "title": "Problem 11.2 - By Integration of Moment Equation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"392\"\nL=reactive.Value(\"__\")\nw0=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of degrees\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cantilever beam of length L = {L()} m is subjected to a linear distributed load where w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kN/m. Determine the magnitude of the slope of the beam at the free end. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10, 100, 1)/10)\n        w0.set(random.randrange(10, 100, 1)/10)\n        EI.set(random.randrange(10000, 20000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        M = w0()*L()**2/3\n        F = L()*w0()/2\n        instr= abs((w0()*L()**3/(8*EI()))*180/math.pi)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.2 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_3dynamicsubmit.html",
    "href": "problem11_3dynamicsubmit.html",
    "title": "Problem 11.3 - By Integration of Moment Equation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"393\"\nL=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nM=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cantilever beam of length L = {L()} m is subjected to a distributed load w = {w()} kN/m and couple M = {M()} kN-m. Determine the deflection of the beam at the free end. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10, 100, 1)/10)\n        w.set(random.randrange(10, 100, 1)/10)\n        M.set(random.randrange(10, 100, 1)/10)\n        EI.set(random.randrange(20000, 30000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Mwall = w()*L()**2/2-M()\n        instr= abs((w()*L()**4-4*Mwall*L()**2)/(8*EI())*100)*10\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.3 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_4dynamicsubmit.html",
    "href": "problem11_4dynamicsubmit.html",
    "title": "Problem 11.4 - By Integration of Moment Equation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"394\"\nL=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cantilever beam of length L = {L()} m is subjected to a distributed load w = {w()} kN/m. Determine the magnitude of the deflection of the beam at point B. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10, 100, 1)/10)\n        w.set(random.randrange(10, 100, 1)/10)\n        EI.set(random.randrange(10000, 20000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= 2*w()*L()**4/(81*EI())*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.4 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_5dynamicsubmit.html",
    "href": "problem11_5dynamicsubmit.html",
    "title": "Problem 11.5 - By Integration of Moment Equation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"396\"\nw=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cantilever beam of length L = {L()} ft is subjected to a distributed load w = {w()} lb/in. and a concentrated load P = {F()} kips as shown. Determine the magnitude of the deflection of the beam at point B. Assume EI = {EI()} kip-in.&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(100, 500, 10))\n        F.set(random.randrange(10, 50, 1)/10)\n        EI.set(random.randrange(30000, 60000, 1000))\n        L.set(random.randrange(30, 100, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (F()*(L()*12)**3)/(48*EI())+(5*w()/1000*(L()*12)**4)/(384*EI())\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.5 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_17dynamicsubmit.html",
    "href": "problem11_17dynamicsubmit.html",
    "title": "Problem 11.17 - By Integration of Load Equation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"404\"\nL=reactive.Value(\"__\")\nw0=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of length L = {L()} m is subjected to a distributed load as shown where w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kN/m. Determine the magnitude of the deflection at x = {x()}L. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(5, 15, 1))\n        w0.set(random.randrange(20, 50, 1))\n        EI.set(random.randrange(10000, 20000, 1000))\n        x.set(random.randrange(1, 9, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (w0()*L()**4*math.sin(math.pi*x()))/(EI()*math.pi**4)*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.17 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_18dynamicsubmit.html",
    "href": "problem11_18dynamicsubmit.html",
    "title": "Problem 11.18 - By Integration of Load Equation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"405\"\nL=reactive.Value(\"__\")\nw0=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of length L = {L()} ft is subjected to a distributed load as shown where w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kip/ft. Determine the magnitude of the deflection at x = {x()}L. Assume EI = {EI()} kip-ft&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(5, 15, 1))\n        w0.set(random.randrange(20, 50, 1))\n        EI.set(random.randrange(30000, 60000, 1000))\n        x.set(random.randrange(1, 9, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (w0()*L()**4/math.pi**4*math.sin(math.pi*x()))/EI()*12\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.18 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_19dynamicsubmit.html",
    "href": "problem11_19dynamicsubmit.html",
    "title": "Problem 11.19 - By Integration of Load Equation",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"406\"\nL=reactive.Value(\"__\")\nw0=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of length L = {L()} ft is subjected to a distributed load as shown where w&lt;sub&gt;0&lt;/sub&gt; = {w0()} kip/ft. Determine the magnitude of the deflection at x = {x()}L. Assume EI = {EI()} kip-ft&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(6, 15, 3))\n        w0.set(L()**2/9)\n        EI.set(random.randrange(30000, 60000, 1000))\n        x.set(random.randrange(1, 9, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= abs((-w0()*(x()*L())**4/24+(x()*L())**6/3240+w0()*L()*(x()*L())**3/6-L()**3*(x()*L())**3/162-w0()*L()**2*(x()*L())**2/4+3*L()**4*(x()*L())**2/216)/EI()*12)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.19 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_22dynamicsubmit.html",
    "href": "problem11_22dynamicsubmit.html",
    "title": "Problem 11.22 - By Superposition",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"417\"\nL=reactive.Value(\"__\")\nM=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of meters\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cantilever beam is loaded as shown where L = {L()} m, M = {M()} kN-m, and P = {F()} kN. Determine the magnitude of the deflection at the free end of the beam. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(5, 15, 1))\n        M.set(random.randrange(25, 75, 1))\n        F.set(random.randrange(25, 75, 1))\n        EI.set(random.randrange(30000, 60000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= abs((9*M()*L()**2-16*F()*L()**3)/(6*EI()))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.22 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_23dynamicsubmit.html",
    "href": "problem11_23dynamicsubmit.html",
    "title": "Problem 11.23 - By Superposition",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"419\"\nL=reactive.Value(\"__\")\nM=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A simply supported beam is loaded as shown where L = {L()} m, M = {M()} kN-m, w = {w()} kN/m, and F = {F()} kN. Determine the magnitude of the deflection at the center of the beam. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(3, 8, 1))\n        M.set(random.randrange(5, 20, 1))\n        F.set(random.randrange(5, 20, 1))\n        w.set(random.randrange(10, 50, 1)/10)\n        EI.set(random.randrange(20000, 40000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (5*w()*(2*L())**4/(768*EI())+F()*(2*L())**3/(48*EI())+M()*(2*L())**2/(16*EI()))*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.23 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_24dynamicsubmit.html",
    "href": "problem11_24dynamicsubmit.html",
    "title": "Problem 11.24 - By Superposition",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"420\"\nL=reactive.Value(\"__\")\nw1=reactive.Value(\"__\")\nw2=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A simply supported beam is loaded as shown where L = {L()} m, w&lt;sub&gt;1&lt;/sub&gt; = {w1()} kN/m, and w&lt;sub&gt;2&lt;/sub&gt; = {w2()} kN/m. Determine the magnitude of the deflection at the center of the beam. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(3, 8, 1))\n        w1.set(random.randrange(10, 50, 1)/10)\n        w2.set(w1()+random.randrange(10, 30, 1)/10)\n        EI.set(random.randrange(20000, 40000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= abs((5*w1()*(2*L())**4-5*w2()*(2*L())**4)/(768*EI()))*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.24 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_25dynamicsubmit.html",
    "href": "problem11_25dynamicsubmit.html",
    "title": "Problem 11.25 - By Superposition",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"421\"\nL=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of millimeters\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"An overhanging beam is loaded as shown where L = {L()} m and w = {w()} kN/m. Determine the magnitude of the deflection at point A. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(3, 8, 1))\n        w.set(random.randrange(10, 50, 1)/10)\n        EI.set(random.randrange(20000, 40000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (w()*L()**4)/(3*EI())*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.25 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_26dynamicsubmit.html",
    "href": "problem11_26dynamicsubmit.html",
    "title": "Problem 11.26 - By Superposition",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"422\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"An overhanging beam is loaded as shown where L&lt;sub&gt;1&lt;/sub&gt; = {L1()} ft, L&lt;sub&gt;2&lt;/sub&gt; = {L2()} ft, and w = {w()} kip/ft. Determine the deflection at the point C. Assume EI = {EI()} kip-ft&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(5, 15, 1))\n        L2.set(round(L1()*5/7,1))\n        w.set(random.randrange(10, 100, 1)/10)\n        EI.set(random.randrange(20000, 40000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        M = w()*L2()**2/2\n        thetaM = M*L1()/(3*EI())\n        vw = w()*L2()**4/(8*EI())\n        instr= (thetaM*L2()+vw)*12\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.26 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_36dynamicsubmit.html",
    "href": "problem11_36dynamicsubmit.html",
    "title": "Problem 11.36 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"436\"\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nw=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kips\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam of length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} ft and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} ft is subjected to a distributed load w = {w()} kip/ft as shown. Determine the reaction force at support B. Assume EI = {EI()} kip-ft&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L1.set(random.randrange(20, 70, 1)/10)\n        L2.set(L1()*2)\n        w.set(random.randrange(10, 100, 1)/10)\n        EI.set(random.randrange(10000, 30000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        L = L1()+L2()\n        vB = (-3*w()*L2()**5+7*w()*L*L2()**4-4*w()*L**2*L2()**3)/(24*L*EI())\n        instr= (-6*L*EI()*vB)/(L2()*L1()*(L**2-L2()**2-L1()**2))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.36 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_37dynamicsubmit.html",
    "href": "problem11_37dynamicsubmit.html",
    "title": "Problem 11.37 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"437\"\nw1=reactive.Value(\"__\")\nw2=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is subjected to two distributed loads, w&lt;sub&gt;1&lt;/sub&gt; = {w1()} kN/m and w&lt;sub&gt;2&lt;/sub&gt; = {w2()} kN/m as shown. It is supported by a pin at A and rollers at B and C. If length L = {L()} m, determine the reaction force at support B. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w1.set(random.randrange(10, 50, 1)/10)\n        w2.set(w1()+random.randrange(10, 30, 1)/10)\n        L.set(random.randrange(2, 10, 1))\n        EI.set(random.randrange(20000, 40000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        v1 = 5*w1()*(2*L())**4/(768*EI())\n        v2 = -5*w2()*(2*L())**4/(768*EI())\n        instr= -((v1+v2)*48*EI())/(2*L())**3\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.37 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_38dynamicsubmit.html",
    "href": "problem11_38dynamicsubmit.html",
    "title": "Problem 11.38 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"438\"\nw=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\nL3=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip-ft\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A propped cantilever beam is subjected to a distributed load w = {w()} kip/ft as shown. If length L&lt;sub&gt;1&lt;/sub&gt; = {L1()} ft, L&lt;sub&gt;2&lt;/sub&gt; = {L2()} ft, and L&lt;sub&gt;3&lt;/sub&gt; = {L3()} ft, determine the magnitude of the moment reaction at the wall. Assume EI = {EI()} kip-ft&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(10, 50, 1)/10)\n        L1.set(random.randrange(2, 5, 1))\n        L2.set(L1()*3/2)\n        L3.set(L1()*3/2)\n        EI.set(random.randrange(10000, 30000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        R = (3*w()*L3()**3*4*L2()/(24*(L2()+L3())**3))\n        instr= -R*(L2()+L3())+L3()**2*w()/2\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.38 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_39dynamicsubmit.html",
    "href": "problem11_39dynamicsubmit.html",
    "title": "Problem 11.39 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"439\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is subjected to force F = {F()} kN as shown. If length L = {L()} m, determine the reaction force at support B. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(10, 300, 1))\n        L.set(random.randrange(2, 6, 1))\n        EI.set(random.randrange(20000, 40000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= 0.6875*F()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.39 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_40dynamicsubmit.html",
    "href": "problem11_40dynamicsubmit.html",
    "title": "Problem 11.40 - Statically Indeterminate Beam Deflection",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"440\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nEI=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A beam is subjected to force F = {F()} kN as shown. If length L = {L()} m, determine the reaction force at support B. Assume EI = {EI()} kN-m&lt;sup&gt;2&lt;/sup&gt;.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(20, 80, 1))\n        L.set(random.randrange(3, 8, 1))\n        EI.set(random.randrange(5000, 20000, 1000))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr = 5*F()/16\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.40 - Statically Indeterminate Beam Deflection"
    ]
  },
  {
    "objectID": "problem11_50dynamicsubmit.html",
    "href": "problem11_50dynamicsubmit.html",
    "title": "Problem 11.50 - Intermediate Beam Design",
    "section": "",
    "text": "[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"681\"\nsigma=reactive.Value(\"__\")\ntau=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip/ft\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A W18 x 76 shape (E = 29,000 ksi) is to be simply-supported and carry a uniform distributed load, œâ. If the beam has an allowable bending stress œÉ = {sigma()} ksi, allowable shear stress œÑ = {tau()} ksi, and allowable deflection of span/240, determine the maximum load, œâ, for a span L = {L()} ft. Ignore self-weight.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma.set(random.randrange(20, 30, 1))\n        tau.set(sigma()-random.randrange(6, 12, 1))\n        L.set(random.randrange(20, 40, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        ansM= 8*146*sigma()/(L()*12)**2*12\n        ansDef = 384*29000*1330/(240*5*(L()*12)**3)*12\n        instr = min(ansM,ansDef)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.50 - Intermediate Beam Design"
    ]
  },
  {
    "objectID": "problem11_51dynamicsubmit.html",
    "href": "problem11_51dynamicsubmit.html",
    "title": "Problem 11.51 - Intermediate Beam Design",
    "section": "",
    "text": "[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"682\"\nw=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A window manufacturer is considering maximum sizes possible for a hollow aluminum tube section (E = 67 GPa). The tube will be simply-supported with a uniform distributed load, œâ = {w()} kN/m. If the aluminum tube has an allowable bending stress œÉ = 250 MPa, allowable shear stress œÑ = 150 MPa, and deflection limit of span/480, determine the longest span allowed. Assume dimensions b = {b()} mm and h = {h()} mm.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(50, 100, 1)/10)\n        b.set(random.randrange(80, 120, 1))\n        h.set(random.randrange(150, 200, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = b()*h()**3/12-((b()-7.4)*(h()-7.4)**3/12)\n        M = w()*1000/8\n        ansM = (80.6*250/M)**0.5\n        ansDef = (384*67*I/(2400*w()/1000))**(1/3)/1000\n        instr = min(ansM,ansDef)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.51 - Intermediate Beam Design"
    ]
  },
  {
    "objectID": "problem11_53dynamicsubmit.html",
    "href": "problem11_53dynamicsubmit.html",
    "title": "Problem 11.53 - Intermediate Beam Design",
    "section": "",
    "text": "[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"684\"\nd=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A pipe with an outer diameter of {d()} mm is to be used as a cantilever beam of length L = {L()} m carrying a load P = {P()} kN at the free end. Determine the minimum required pipe wall thickness if the allowable bending stress, œÉ&lt;sub&gt;allow&lt;/sub&gt; = 400 MPa, the allowable shear stress, œÑ&lt;sub&gt;allow&lt;/sub&gt; = 240 MPa, and the allowable deflection = 50 mm. Assume E = 200 GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(75, 125, 1))\n        L.set(random.randrange(20, 30, 1)/10)\n        P.set(random.randrange(10, 100, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I1 = P()*(L()*1000)**3/(3*200*50)\n        I2 = P()*L()*1000*d()/2/0.400\n        I = max(I1,I2)\n        ri = ((math.pi*(d()/2)**4/4-I)*4/math.pi)**(1/4)\n        instr= d()/2-ri\n\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11 Problems",
      "Problem 11.53 - Intermediate Beam Design"
    ]
  },
  {
    "objectID": "problem12_1dynamicsubmit.html",
    "href": "problem12_1dynamicsubmit.html",
    "title": "Problem 12.1 - Equations",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"498\"\nsigmax=reactive.Value(\"__\")\nsigmay=reactive.Value(\"__\")\ntxy=reactive.Value(\"__\")\ntheta=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A point in a beam is subjected to the state of stress shown, where œÉ&lt;sub&gt;x&lt;/sub&gt; = {sigmax()} ksi, œÉ&lt;sub&gt;y&lt;/sub&gt; = {sigmay()} ksi, and œÑ&lt;sub&gt;xy&lt;/sub&gt; = {txy()} ksi. Determine the normal stress acting on plane a-a if angle Œò = {theta()}¬∞. Enter a negative sign if the answer is compressive.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigmax.set(random.randrange(10, 50, 1))\n        sigmay.set(random.randrange(10, 50, 1))\n        txy.set(random.randrange(10, 50, 1))\n        theta.set(random.randrange(20, 30, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (-sigmax()-sigmay())/2+(-sigmax()+sigmay())/2*math.cos(2*theta()*math.pi/180)+txy()*math.sin(2*theta()*math.pi/180)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.1 - Equations"
    ]
  },
  {
    "objectID": "problem12_2dynamicsubmit.html",
    "href": "problem12_2dynamicsubmit.html",
    "title": "Problem 12.2 - Equations",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"499\"\nsigmax=reactive.Value(\"__\")\nsigmay=reactive.Value(\"__\")\ntxy=reactive.Value(\"__\")\ntheta=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A point in a beam is subjected to the state of stress shown, where œÉ&lt;sub&gt;x&lt;/sub&gt; = {sigmax()} MPa, œÉ&lt;sub&gt;y&lt;/sub&gt; = {sigmay()} MPa, and œÑ&lt;sub&gt;xy&lt;/sub&gt; = {txy()} MPa. Determine the normal stress acting on plane a-a if angle Œò = {theta()}¬∞. Enter a negative sign if the answer is compressive.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigmax.set(random.randrange(11, 51, 1))\n        sigmay.set(random.randrange(11, 51, 1))\n        txy.set(random.randrange(11, 51, 1))\n        theta.set(random.randrange(21, 31, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        alpha = 90-10-theta()\n        instr= (sigmax()+sigmay())/2+(sigmax()-sigmay())/2*math.cos(2*alpha*math.pi/180)-txy()*math.sin(2*alpha*math.pi/180)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.2 - Equations"
    ]
  },
  {
    "objectID": "problem12_3dynamicsubmit.html",
    "href": "problem12_3dynamicsubmit.html",
    "title": "Problem 12.3 - Equations",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"500\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\ntheta = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your normal stress in units of MPa\", placeholder=\"Please enter the normal stress\"),\n    ui.input_text(\"answer2\", \"Your shear stress in units of MPa\", placeholder=\"Please enter the shear stress\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A point in a beam is subjected to the state of stress shown, where œÉ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} MPa, œÉ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} MPa, and œÑ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} MPa. Determine the magnitude of the normal stress and the magnitude of the shear stress acting on plane a-a if angle Œò = {theta()}¬∞.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(15, 60, 1))\n        sigma_y.set(random.randrange(15, 60, 1))\n        tau_xy.set(random.randrange(15, 60, 1))\n        theta.set(random.randrange(55, 75, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        thetan = 90-theta()\n        instr1 = abs((-sigma_x()-sigma_y())/2+(-sigma_x()+sigma_y())/2*math.cos(2*thetan*math.pi/180)+tau_xy()*math.sin(2*thetan*math.pi/180))\n        instr2 = abs((sigma_x()-sigma_y())/2*math.sin(2*thetan*math.pi/180)+tau_xy()*math.cos(2*thetan*math.pi/180))\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n    \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.3 - Equations"
    ]
  },
  {
    "objectID": "problem12_4dynamicsubmit.html",
    "href": "problem12_4dynamicsubmit.html",
    "title": "Problem 12.4 - Equations",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"501\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\ntheta = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your normal stress in units of ksi\", placeholder=\"Please enter your normal stress\"),\n    ui.input_text(\"answer2\", \"Your shear stress in units of ksi\", placeholder=\"Please enter your shear stress\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A material made from fibers is stressed as shown in the diagram. Stresses œÉ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} ksi, œÉ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} ksi, and œÑ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} ksi. Determine the magnitude of the normal stress acting perpendicuar to the fibers and the magnitude of the shear stress acting parallel to the fibers if angle Œò = {theta()}¬∞.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(10, 50, 1))\n        sigma_y.set(random.randrange(10, 50, 1))\n        tau_xy.set(random.randrange(10, 50, 1))\n        theta.set(random.randrange(20, 30, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        thetap = theta()+90\n        instr1 = abs((sigma_x()+sigma_y())/2+(sigma_x()-sigma_y())/2*math.cos(2*thetap*math.pi/180)+tau_xy()*math.sin(2*thetap*math.pi/180))\n        instr2 = abs((-sigma_x()+sigma_y())/2*math.sin(2*theta()*math.pi/180)+tau_xy()*math.cos(2*theta()*math.pi/180))\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n    \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.4 - Equations"
    ]
  },
  {
    "objectID": "problem12_5dynamicsubmit.html",
    "href": "problem12_5dynamicsubmit.html",
    "title": "Problem 12.5 - Equations",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"502\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\ntheta = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your normal stress in units of ksi\", placeholder=\"Please enter your normal stress\"),\n    ui.input_text(\"answer2\", \"Your shear stress in units of ksi\", placeholder=\"Please enter your shear stress\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A material made from fibers is stressed as shown in the diagram. Stresses œÉ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} ksi, œÉ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} ksi, and œÑ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} ksi. Determine the magnitude of the normal stress acting perpendicuar to the fibers and the magnitude of the shear stress acting parallel to the fibers if angle Œò = {theta()}¬∞.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(20, 75, 1))\n        sigma_y.set(random.randrange(20, 75, 1))\n        tau_xy.set(random.randrange(20, 75, 1))\n        theta.set(random.randrange(10, 25, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        thetap = 90-theta()\n        instr1 = abs((sigma_x()+sigma_y())/2+(sigma_x()-sigma_y())/2*math.cos(2*thetap*math.pi/180)+tau_xy()*math.sin(2*thetap*math.pi/180))\n        instr2 = abs((-sigma_x()+sigma_y())/2*math.sin(2*thetap*math.pi/180)+tau_xy()*math.cos(2*thetap*math.pi/180))\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n    \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.5 - Equations"
    ]
  },
  {
    "objectID": "problem12_9dynamicsubmit.html",
    "href": "problem12_9dynamicsubmit.html",
    "title": "Problem 12.9 - Principal Stresses",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"508\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your 1st principal stress in units of MPa\", placeholder=\"Please enter your œÉ1\"),\n    ui.input_text(\"answer2\", \"Your 1st pricipal direction in units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where œÉ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} MPa, œÉ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} MPa, and œÑ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} MPa. Determine the maximum principal stress œÉ&lt;sub&gt;1&lt;/sub&gt; for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(10, 50, 1))\n        sigma_y.set(sigma_x()+random.randrange(10, 30, 1))\n        tau_xy.set(random.randrange(10, 50, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = (sigma_x()+sigma_y())/2+math.sqrt(((sigma_x()-sigma_y())/2)**2+tau_xy()**2)\n        instr2 = 90+(math.atan(2*tau_xy()/(sigma_x()-sigma_y())))/2*180/math.pi\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n    \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.9 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_10dynamicsubmit.html",
    "href": "problem12_10dynamicsubmit.html",
    "title": "Problem 12.10 - Principal Stresses",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"509\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your maximum shear stress in units of ksi\", placeholder=\"Please enter your max shear stress\"),\n    ui.input_text(\"answer2\", \"Your angle in units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where œÉ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} ksi, œÉ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} ksi, and œÑ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} ksi. Determine the maximum shear stress for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(20, 70, 1))\n        sigma_y.set(sigma_x()+random.randrange(10, 30, 1))\n        tau_xy.set(random.randrange(10, 50, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = math.sqrt(((-sigma_x()-sigma_y())/2)**2+tau_xy()**2)\n        instr2 = (math.atan((sigma_x()+sigma_y())/(2*tau_xy())))/2*180/math.pi\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n    \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.10 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_11dynamicsubmit.html",
    "href": "problem12_11dynamicsubmit.html",
    "title": "Problem 12.11 - Principal Stresses",
    "section": "",
    "text": "Figure 1: A member is subjected to a state of stress.\n\n\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"510\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your maximum shear stress in units of ksi\", placeholder=\"Please enter your max shear stress\"),\n    ui.input_text(\"answer2\", \"Your angle in units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where œÉ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} ksi, œÉ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} ksi, and œÑ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} ksi. Determine the maximum shear stress for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_y.set(random.randrange(15, 60, 1))\n        sigma_x.set(sigma_y()+random.randrange(10, 30, 1))\n        tau_xy.set(random.randrange(20, 60, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = math.sqrt(((sigma_x()+sigma_y())/2)**2+tau_xy()**2)\n        instr2 = (math.atan((sigma_x()+sigma_y())/(2*tau_xy())))/2*180/math.pi\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n    \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.11 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_12dynamicsubmit.html",
    "href": "problem12_12dynamicsubmit.html",
    "title": "Problem 12.12 - Principal Stresses",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"511\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your maximum shear stress in units of MPa\", placeholder=\"Please enter your max shear stress\"),\n    ui.input_text(\"answer2\", \"Your angle in units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where œÉ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} MPa, œÉ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} MPa, and œÑ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} MPa. Determine the maximum principal stress œÉ&lt;sub&gt;1&lt;/sub&gt; for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_y.set(random.randrange(10, 80, 1))\n        sigma_x.set(sigma_y()+random.randrange(15, 40, 1))\n        tau_xy.set(random.randrange(10, 70, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = (sigma_x()+sigma_y())/2+math.sqrt(((sigma_x()-sigma_y())/2)**2+tau_xy()**2)\n        instr2 = (math.atan((-sigma_x()+sigma_y())/(2*tau_xy())))/2*180/math.pi+45\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n    \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.12 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_13dynamicsubmit.html",
    "href": "problem12_13dynamicsubmit.html",
    "title": "Problem 12.13 - Principal Stresses",
    "section": "",
    "text": "{fig-alt=A member is subjected to a state of stress caused by sigma_x, and sigma_y.‚Äù} [Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"512\"\nsigma_x=reactive.Value(\"__\")\nsigma_y=reactive.Value(\"__\")\ntau_max=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of degrees\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"The state of stress at a point in a beam is shown, where œÉ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} ksi, œÉ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} ksi, and œÑ&lt;sub&gt;xy&lt;/sub&gt; is unknown. The maximum shear stress for this state of stress is œÑ&lt;sub&gt;max&lt;/sub&gt; = {tau_max()} ksi. Determine the angle that this maximum stress occurs at.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(10, 50, 1))\n        sigma_y.set(sigma_x()+random.randrange(10, 30, 1))\n        tau_max.set(random.randrange(10, 50, 1))        \n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        tau_xy = math.sqrt(tau_max()**2-((sigma_x()-sigma_y())/2)**2)\n        instr= (math.atan((-sigma_x()+sigma_y())/(2*tau_xy)))/2*180/math.pi\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.13 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_25dynamicsubmit.html",
    "href": "problem12_25dynamicsubmit.html",
    "title": "Problem 12.25 - Mohr‚Äôs Circle",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"524\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your 1st principal stress in units of ksi\", placeholder=\"Please enter your œÉ1\"),\n    ui.input_text(\"answer2\", \"Your angle in units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where œÉ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} ksi, œÉ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} ksi, and œÑ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} ksi. Construct Mohr's Circle for the given state of stress. Then determine the maximum principal stress œÉ&lt;sub&gt;1&lt;/sub&gt; for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(20, 80, 1))\n        sigma_y.set(sigma_x()+random.randrange(5, 30, 1))\n        tau_xy.set(random.randrange(20, 60, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = (sigma_x()-sigma_y())/2+math.sqrt(((sigma_x()+sigma_y())/2)**2+tau_xy()**2)\n        instr2 = (math.atan(2*tau_xy()/(sigma_x()+sigma_y())))/2*180/math.pi\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.25 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_26dynamicsubmit.html",
    "href": "problem12_26dynamicsubmit.html",
    "title": "Problem 12.26 - Mohr‚Äôs Circle",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"525\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your 1st principal stress in units of MPa\", placeholder=\"Please enter your œÉ1\"),\n    ui.input_text(\"answer2\", \"Your angle in units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where œÉ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} MPa, œÉ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} MPa, and œÑ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} MPa. Construct Mohr's Circle for the given state of stress. Then determine the maximum principal stress œÉ&lt;sub&gt;1&lt;/sub&gt; for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(10, 40, 1))\n        sigma_y.set(sigma_x()+random.randrange(10, 20, 1))\n        tau_xy.set(random.randrange(10, 40, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = (sigma_x()+sigma_y())/2+math.sqrt(((sigma_x()-sigma_y())/2)**2+tau_xy()**2)\n        instr2 = (math.atan(2*tau_xy()/(sigma_x()-sigma_y())))/2*180/math.pi+90\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.26 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_27dynamicsubmit.html",
    "href": "problem12_27dynamicsubmit.html",
    "title": "Problem 12.27 - Mohr‚Äôs Circle",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"526\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your maximum in-plane shear stress in units of MPa\", placeholder=\"Please enter your max in-plane shear stress\"),\n    ui.input_text(\"answer2\", \"Your angle in units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where œÉ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} MPa, œÉ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} MPa, and œÑ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} MPa. Construct Mohr's Circle for the given state of stress. Then determine the maximum in-plane shear stress œÑ&lt;sub&gt;max&lt;/sub&gt; for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_y.set(random.randrange(15, 45, 1))\n        sigma_x.set(sigma_y()+random.randrange(5, 20, 1))\n        tau_xy.set(random.randrange(10, 40, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = math.sqrt(((sigma_x()-sigma_y())/2)**2+tau_xy()**2)\n        instr2 = (math.atan((sigma_x()-sigma_y())/(2*-tau_xy())))/2*-180/math.pi\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.27 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_28dynamicsubmit.html",
    "href": "problem12_28dynamicsubmit.html",
    "title": "Problem 12.28 - Mohr‚Äôs Circle",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"527\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your maximum principal stress in units of ksi\", placeholder=\"Please enter your œÉ1\"),\n    ui.input_text(\"answer2\", \"Your angle in units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where œÉ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} ksi, œÉ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} ksi, and œÑ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} ksi. Construct Mohr's Circle for the given state of stress. Then determine the maximum principal stress œÉ&lt;sub&gt;1&lt;/sub&gt; for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_y.set(random.randrange(10, 50, 1))\n        sigma_x.set(sigma_y()+random.randrange(10, 30, 1))\n        tau_xy.set(random.randrange(10, 50, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = (-sigma_x()+sigma_y())/2+math.sqrt(((-sigma_x()-sigma_y())/2)**2+tau_xy()**2)\n        instr2 = (math.atan(2*-tau_xy()/(-sigma_x()-sigma_y())))*180/math.pi/2+90\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.28 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_29dynamicsubmit.html",
    "href": "problem12_29dynamicsubmit.html",
    "title": "Problem 12.29 - Mohr‚Äôs Circle",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"529\"\nsigma_x = reactive.Value(\"__\")\nsigma_y = reactive.Value(\"__\")\ntau_xy = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your 1st principal stress in units of ksi\", placeholder=\"Please enter your œÉ1\"),\n    ui.input_text(\"answer2\", \"Your angle units of degrees\", placeholder=\"Please enter your angle\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"The state of stress at a point in a beam is shown, where œÉ&lt;sub&gt;x&lt;/sub&gt; = {sigma_x()} ksi, œÉ&lt;sub&gt;y&lt;/sub&gt; = {sigma_y()} ksi, and œÑ&lt;sub&gt;xy&lt;/sub&gt; = {tau_xy()} ksi. Construct Mohr's Circle for the given state of stress. Then determine the maximum principal stress œÉ&lt;sub&gt;1&lt;/sub&gt; for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_x.set(random.randrange(12, 57, 1))\n        sigma_y.set(sigma_x()+random.randrange(11, 29, 1))\n        tau_xy.set(random.randrange(12, 57, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = (sigma_x()-sigma_y())/2+math.sqrt(((sigma_x()+sigma_y())/2)**2+tau_xy()**2)\n        instr2 = (math.atan(2*tau_xy()/(sigma_x()+sigma_y())))*180/math.pi/2\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.29 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_39dynamicsubmit.html",
    "href": "problem12_39dynamicsubmit.html",
    "title": "Problem 12.39 - 3D Mohr‚Äôs Circle",
    "section": "",
    "text": "[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"686\"\nsigma1 = reactive.Value(\"__\")\nsigma2 = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your max in-plane stress in units of MPa\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your max absolute stress in units of MPa\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A plane stress state results in principal stress œÉ&lt;sub&gt;1&lt;/sub&gt; = {sigma1()} MPa and œÉ&lt;sub&gt;2&lt;/sub&gt; = -{sigma2()} MPa. Use Mohr's Circle to determine the maximum in-plane and maximum absolute shear stresses.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma1.set(random.randrange(200, 500, 5))\n        sigma2.set(random.randrange(100, 400, 5))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = (sigma1()+sigma2())/2\n        instr2 = (sigma1()+sigma2())/2\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.39 - 3D Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_40dynamicsubmit.html",
    "href": "problem12_40dynamicsubmit.html",
    "title": "Problem 12.40 - 3D Mohr‚Äôs Circle",
    "section": "",
    "text": "[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"687\"\nsigma1 = reactive.Value(\"__\")\ntau_max = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your œÉ2 in units of ksi\", placeholder=\"Please enter your œÉ2\"),\n    ui.input_text(\"answer2\", \"Your max absolute shear stress in units of ksi\", placeholder=\"Please enter your shear stress\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [ui.markdown(f\"A plane stress state results in principal stress œÉ&lt;sub&gt;1&lt;/sub&gt; = {sigma1()} ksi and œÑ&lt;sub&gt;max-in-plane&lt;/sub&gt; = {tau_max()} ksi. Use Mohr's Circle to determine œÉ&lt;sub&gt;2&lt;/sub&gt; and the maximum absolute shear stresses.\")]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma1.set(random.randrange(10, 50, 1))\n        tau_max.set(sigma1()*random.randrange(20, 40, 1)/100)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)\n        instr1 = sigma1()-2*tau_max()\n        instr2 = sigma1()/2\n        correct1 = math.isclose(float(input.answer1()), instr1, rel_tol=0.01)\n        correct2 = math.isclose(float(input.answer2()), instr2, rel_tol=0.01)\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct respectively' if correct2 else 'incorrect respectively'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 12 Problems",
      "Problem 12.40 - 3D Mohr's Circle"
    ]
  },
  {
    "objectID": "problem13_1dynamicsubmit.html",
    "href": "problem13_1dynamicsubmit.html",
    "title": "Problem 13.1 - Cylindrical",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"556\"\nd=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\nT=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A thin-walled cylindrical pressure vessel with an outside diameter d = {d()} in. is subjected to an internal pressure P = {P()} psi and an external torque T = {T()} kip-in. at its top. The base is fixed to the ground. If the vessel wall thickness is t = {t()} in., determine the absolute largest principal stress in the vessel wall.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(10, 30, 1))\n        P.set(random.randrange(100, 500, 10))\n        T.set(random.randrange(200, 800, 10))\n        t.set(random.randrange(2, 8, 1)/10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        J =  math.pi*((d()/2)**4-(d()/2-t())**4)/2\n        tau_ha = T()*d()/2/J\n        sigma_a = P()*(d()/2-t())/(2*t())/1000\n        sigma_h = P()*(d()/2-t())/t()/1000\n        instr= ((sigma_a+sigma_h)/2+math.sqrt(((sigma_h-sigma_a)/2)**2+tau_ha**2))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 13 Problems",
      "Problem 13.1 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_2dynamicsubmit.html",
    "href": "problem13_2dynamicsubmit.html",
    "title": "Problem 13.2 - Cylindrical",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"558\"\nd=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cylindrical pressure vessel of outer diameter d = {d()} mm experiences an internal pressure P = {P()} kPa. Determine the maximum in-plane shear stress in the vessel wall if the wall thickness is t = {t()} mm.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        d.set(random.randrange(500, 1000, 10))\n        P.set(random.randrange(100, 1000, 1)/10)\n        t.set(random.randrange(10, 50, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigma_a = P()*(d()/2-t())/(2*t())\n        sigma_h = P()*(d()/2-t())/t()\n        instr= (math.sqrt(((-sigma_h+sigma_a)/2)**2))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 13 Problems",
      "Problem 13.2 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_3dynamicsubmit.html",
    "href": "problem13_3dynamicsubmit.html",
    "title": "Problem 13.3 - Cylindrical",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"559\"\nri=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\nP=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of in\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A gas storage tank with an internal radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} in. and wall thickness t = {t()} in. is filled to an internal pressure P = {P()} psi. If the original length L = {L()} ft., determine the total axial deflection (change in length) of the tank after filling. Assume E = 29,000 ksi and ŒΩ = 0.3.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        ri.set(random.randrange(10, 25, 1))\n        t.set(random.randrange(2, 8, 1)/10)\n        P.set(random.randrange(1000, 5000, 100))\n        L.set(random.randrange(10, 25, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigma_a = P()*ri()/(2*t())/1000\n        sigma_h = P()*ri()/t()/1000\n        v = 0.3\n        E = 29000\n        e = (sigma_a-v*sigma_h)/E\n        instr= L()*12*e\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 13 Problems",
      "Problem 13.3 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_4dynamicsubmit.html",
    "href": "problem13_4dynamicsubmit.html",
    "title": "Problem 13.4 - Cylindrical",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random str ling ofetters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"563\"\ndi=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A cylindrical thin-walled pressure vessel with an inner diameter d&lt;sub&gt;i&lt;/sub&gt; = {di()} mm is subjected to an unknown internal pressure, P. A vertical load F = {F()} kN is also applied to the vessel as shown. If length L = {L()} m and the wall thickness t = {t()} mm, what pressure will cause the axial and hoop stresses to be equal?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        di.set(random.randrange(200, 500, 10))\n        F.set(random.randrange(5, 25, 1)/10)\n        L.set(random.randrange(10, 50, 1)/10)\n        t.set(random.randrange(1, 10, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        sigma_f = F()*1000/(math.pi*((di()/2000+t()/1000)**2-(di()/2000)**2))/1000\n        instr= (2*t()/1000*sigma_f/(di()/2000))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 13 Problems",
      "Problem 13.4 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_15dynamicsubmit.html",
    "href": "problem13_15dynamicsubmit.html",
    "title": "Problem 13.15 - Spherical",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"554\"\nP=reactive.Value(\"__\")\nsigma_fail=reactive.Value(\"__\")\nFS=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A balloon with a wall thickness of 0.02 in. is inflated to a pressure of {P()} psi. If the balloon material fails in tension at {sigma_fail()} psi, what is the maximum radius of the balloon using a factor of safety of {FS()}?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        P.set(random.randrange(20, 60, 1))\n        sigma_fail.set(random.randrange(5000, 10000, 100))\n        FS.set(random.randrange(15, 30, 1)/10)        \n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= sigma_fail()/FS()*2*0.02/P()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 13 Problems",
      "Problem 13.15 - Spherical"
    ]
  },
  {
    "objectID": "problem13_16dynamicsubmit.html",
    "href": "problem13_16dynamicsubmit.html",
    "title": "Problem 13.16 - Spherical",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random str ling ofetters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"563\"\nsigma_yield=reactive.Value(\"__\")\nt=reactive.Value(\"__\")\ndi=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A spherical thin-walled pressure vessel is to be constructed of steel with a yield stress of {sigma_yield()} ksi and a wall thickness t = {t()} in. If the internal diameter of the tank is d&lt;sub&gt;i&lt;/sub&gt; = {di()} ft, determine the maximum allowable pressure before yielding.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma_yield.set(random.randrange(40, 65, 1))\n        t.set(random.randrange(2, 8, 1)/10)\n        di.set(random.randrange(10, 30, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= 2*sigma_yield()*t()/(di()*6)*1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 13 Problems",
      "Problem 13.16 - Spherical"
    ]
  },
  {
    "objectID": "problem14_1dynamicsubmit.html",
    "href": "problem14_1dynamicsubmit.html",
    "title": "Problem 14.1 - Eccentric Axial Loads",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"481\"\nw=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\nL1=reactive.Value(\"__\")\nL2=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of psi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A large column supports a cantilevered load W = {w()} kips as shown. Dimensions b = {b()} ft, h = {h()} ft, L&lt;sub&gt;1&lt;/sub&gt; = {L1()} ft, and L&lt;sub&gt;2&lt;/sub&gt; = {L2()} ft. What is the magnitude of the compressive stress at point A? Assume the cantilevered beam does not fail or bend. Enter a negative sign if the stress is compressive\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(5, 50, 1))\n        b.set(random.randrange(1, 5, 1))\n        h.set(b()*2)\n        L1.set(b()*5)\n        L2.set(random.randrange(5, 15, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (-w()/(b()*h())-(6*w()*L2()*math.cos(60*math.pi/180))/(b()**2*h())-(6*w()*L2()*math.sin(60*math.pi/180)/(h()**2*b())))*6.944444\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 14 Problems",
      "Problem 14.1 - Eccentric Axial Loads"
    ]
  },
  {
    "objectID": "problem14_2dynamicsubmit.html",
    "href": "problem14_2dynamicsubmit.html",
    "title": "Problem 14.2 - Eccentric Axial Loads",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"482\"\nF=reactive.Value(\"__\")\ny=reactive.Value(\"__\")\nx=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A metal electric pole supporting a load F = {F()} kN was knocked at an angle during a recent storm. If dimensions x = {x()} mm, y = {y()} mm, and L = {L()} m, determine the magnitude of the maximum normal stress at the base.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(10, 90, 1))\n        y.set(random.randrange(500, 1000, 10))\n        x.set(y()*2)\n        L.set(random.randrange(5, 12, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        M = math.sqrt((x()/1000)**2+(y()/1000)**2)*F()*1000\n        sigmaB = M*0.1/(4637*10**-8)\n        sigmaA = F()*1000/(math.pi*(0.1**2-0.08**2))\n        instr= abs((sigmaA+sigmaB)/10**6)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 14 Problems",
      "Problem 14.2 - Eccentric Axial Loads"
    ]
  },
  {
    "objectID": "problem14_9dynamicsubmit.html",
    "href": "problem14_9dynamicsubmit.html",
    "title": "Problem 14.9 - General Combined Loads",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\n\nproblem_ID = \"519\"\nL = reactive.Value(\"__\")\nr = reactive.Value(\"__\")\nF = reactive.Value(\"__\")\nT = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\n        \"**Please enter your ID number from your instructor and click to generate your problem**\"\n    ),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\n        \"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"\n    ),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\n        \"answer\", \"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"\n    ),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A solid circular rod of length L = {L()} m and radius r = {r()} mm is subjected to axial load F = {F()} kN and torsional moment T = {T()} kN-m. Determine the absolute maximum shear stress (for any coordinate direction) at any location in the bar.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(2, 10, 1))\n        r.set(random.randrange(20, 50, 1))\n        F.set(random.randrange(50, 150, 1))\n        T.set(random.randrange(10, 30, 1) / 10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        tau_xy = 2 * T() * 1000 / (math.pi * (r() / 1000) ** 3) / 10**6\n        sigma_y = F() * 1000 / (math.pi * (r() / 1000) ** 2) / 10**6\n        instr = math.sqrt((-sigma_y / 2) ** 2 + tau_xy**2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(\n            f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\"\n        )\n\n        # Show feedback to the user.\n        feedback = ui.markdown(\n            f\"Your answer of {input.answer()} is {check}.\"\n        )\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = (\n            session.encoded_attempt()\n            if session.encoded_attempt is not None\n            else \"No attempts\"\n        )\n        yield f\"{final_encoded}\\n\\n\"\n\n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n\n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(\n                0.25\n            )  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 14 Problems",
      "Problem 14.9 - General Combined Loads"
    ]
  },
  {
    "objectID": "problem14_10dynamicsubmit.html",
    "href": "problem14_10dynamicsubmit.html",
    "title": "Problem 14.10 - General Combined Loads",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"521\"\nL=reactive.Value(\"__\")\nr=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nT=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A solid circular rod of length L = {L()} ft and radius r = {r()} in. is subjected to load F = {F()} kips and torsional moment T = {T()} kip-in. Determine the maximum principal stress at point A.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10, 50, 1)/10)\n        r.set(random.randrange(10, 30, 1)/10)\n        F.set(random.randrange(10, 100, 1)/10)\n        T.set(random.randrange(100, 300, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        tau_xy = 2*T()/(math.pi*r()**3)\n        sigma_x = F()*L()*48/(math.pi*r()**3)\n        instr= sigma_x/2+math.sqrt((sigma_x/2)**2+tau_xy**2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 14 Problems",
      "Problem 14.10 - General Combined Loads"
    ]
  },
  {
    "objectID": "problem14_11dynamicsubmit.html",
    "href": "problem14_11dynamicsubmit.html",
    "title": "Problem 14.11 - General Combined Loads",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"522\"\nL=reactive.Value(\"__\")\nr=reactive.Value(\"__\")\nF=reactive.Value(\"__\")\nT=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of MPa\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A solid circular rod of length L = {L()} m and radius r = {r()} mm is subjected to load F = {F()} kN and torsional moment T = {T()} kN-m. Determine the absolute maximum normal stress at point A.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(10, 50, 1)/10)\n        r.set(random.randrange(20, 50, 1))\n        F.set(random.randrange(15, 50, 1)/10)\n        T.set(random.randrange(5, 30, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        tau_xy = 2*T()*1000/(math.pi*(r()/1000)**3)/10**6\n        sigma_x = 4000*F()*L()/(math.pi*(r()/1000)**3)/10**6\n        instr= -sigma_x/2+math.sqrt((sigma_x/2)**2+tau_xy**2)\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 14 Problems",
      "Problem 14.11 - General Combined Loads"
    ]
  },
  {
    "objectID": "problem15_1dynamicsubmit.html",
    "href": "problem15_1dynamicsubmit.html",
    "title": "Problem 15.1 - Buckling & Yield - Euler‚Äôs Formula",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random str ling ofetters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"607\"\nL=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\nri=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kN\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A steel (E = 200 GPa) tube column with a yield strength of 250 MPa is pinned at both ends. If length L = {L()} m, outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} mm and inner radius r&lt;sub&gt;i&lt;/sub&gt; = {ri()} mm, determine the maximum allowable load the column can support.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(50, 100, 1)/10)\n        ro.set(random.randrange(50, 150, 1))\n        ri.set(ro()-random.randrange(5, 10, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = math.pi/4*(ro()**4-ri()**4)\n        E = 200*10**9\n        instr= (math.pi**2*E*I/10**12/L()**2)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.1 - Buckling & Yield - Euler's Formula"
    ]
  },
  {
    "objectID": "problem15_2dynamicsubmit.html",
    "href": "problem15_2dynamicsubmit.html",
    "title": "Problem 15.2 - Buckling & Yield - Euler‚Äôs Formula",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"610\"\nL=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of ksi\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A W14 x 34 beam is used as a column that is pinned at both ends. If length L = {L()} ft and the elastic modulus E = {E()} x 10&lt;sup&gt;6&lt;/sup&gt; psi, determine the critical stress for the column.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(15, 40, 1))\n        E.set(random.randrange(250, 350, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        A = 10\n        I = 6.91\n        instr= math.pi**2*E()*10**6*I/(A*144*L()**2)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.2 - Buckling & Yield - Euler's Formula"
    ]
  },
  {
    "objectID": "problem15_3dynamicsubmit.html",
    "href": "problem15_3dynamicsubmit.html",
    "title": "Problem 15.3 - Buckling & Yield - Euler‚Äôs Formula",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"611\"\nF=reactive.Value(\"__\")\nFS=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A column is pinned at both ends and supports a load F = {F()} kN. Determine the maximum allowable column length, L. Use a factor of safety of {FS()} and assume the elastic modulus E = {E()} GPa.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(200, 800, 10))\n        FS.set(random.randrange(15, 30, 1)/10)\n        E.set(random.randrange(170, 250, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = 3.32875*10**-5\n        instr= math.sqrt(math.pi**2*E()*10**9*I/(F()*10**3*FS()))\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.3 - Buckling & Yield - Euler's Formula"
    ]
  },
  {
    "objectID": "problem15_11dynamicsubmit.html",
    "href": "problem15_11dynamicsubmit.html",
    "title": "Problem 15.11 - Effect of Supports",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"612\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of inches\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A column with a square cross-section is used to support a force F = {F()} kips. The column is fixed at its base and free at the other end. If length L = {L()} ft and elastic modulus E = 29,000 ksi, determine the minimum dimension, h, so that the column will not buckle.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(50, 150, 1)/10)\n        L.set(random.randrange(100, 200, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= (48*F()*1000*L()**2*144/(math.pi**2*29*10**6))**0.25\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.11 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem15_12dynamicsubmit.html",
    "href": "problem15_12dynamicsubmit.html",
    "title": "Problem 15.12 - Effect of Supports",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"621\"\nF=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A W16 x 40 beam is used as a column with a length L = {L()} ft. It is fixed at both ends and subjected to load F = {F()} kips. If the elastic modulus E = 29,000 ksi, determine the factor of safety with respect to buckling.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(200, 500, 10))\n        L.set(random.randrange(100, 200, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Pcr = math.pi**2*29*10**3*28.9/(0.5*L()*12)**2\n        instr= Pcr/F()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.12 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem15_13dynamicsubmit.html",
    "href": "problem15_13dynamicsubmit.html",
    "title": "Problem 15.13 - Effect of Supports",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"623\"\nL=reactive.Value(\"__\")\nFS=reactive.Value(\"__\")\nE=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kips\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A W8 x 15 beam (I&lt;sub&gt;x&lt;/sub&gt; = 48.0 in.&lt;sup&gt;4&lt;/sup&gt;, I&lt;sub&gt;y&lt;/sub&gt; = 3.41 in.&lt;sup&gt;4&lt;/sup&gt;) is used as a column with one end fixed and the other end pinned. If the length of the column L = {L()} ft, determine the largest load it can carry with a factor of safety of {FS()}. The elastic modulus E = {E()} ksi.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(150, 300, 1)/10)\n        FS.set(random.randrange(15, 50, 1)/10)\n        E.set(random.randrange(15000, 30000, 100))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Pcr = math.pi**2*E()*57.7/(0.7*L()*12)**2\n        instr= Pcr/FS()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.13 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem15_14dynamicsubmit.html",
    "href": "problem15_14dynamicsubmit.html",
    "title": "Problem 15.14 - Effect of Supports",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return \"\".join(random.choice(string.ascii_lowercase) for _ in range(length))\n\nproblem_ID = \"624\"\nF = reactive.Value(\"__\")\nL = reactive.Value(\"__\")\nFS = reactive.Value(\"__\")\n\nattempts = [\"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\", \"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer1\", \"Your Answer for the first beam number\", placeholder=\"Please enter your answer 1\"),\n    ui.input_text(\"answer2\", \"Your Answer for the second beam number\", placeholder=\"Please enter your answer 2\"),\n    ui.input_action_button(\"submit\", \"Submit Answers\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return [\n            ui.markdown(\n                f\"A wide-flange column that is fixed at both ends is required to carry a load F = {F()} kips. If length L = {L()} ft and the elastic modulus E = 29,000 ksi, identify the lightest structural member in Appendix A, that is the beam number, that can be used. Use a factor of safety of {FS()} against buckling.\"\n            )\n        ]\n\n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        F.set(random.randrange(300, 800, 10))\n        L.set(random.randrange(150, 300, 1) / 10)\n        FS.set(random.randrange(15, 40, 1) / 10)\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(\n            attempt_counter() + 1\n        )  # Increment the attempt counter on each submission.\n        I = F()*L()**2*144*FS()/(4*math.pi**2*29000)\n\n        # Create a dataframe\n        df = pd.DataFrame()\n\n        # Define Beam Name Columns\n        df[\"I-Beam First Num\"] = [40,40,40,36,36,36,30,30,30,24,24,24,21,21,21,18,18,18,16,16,16,14,14,14,12,12,12]\n\n        #Define Weight Column\n        df[\"Weight\"] = [431,297,264,487,247,210,326,173,99,279,131,84,201,122,68,130,76,40,67,40,31,90,53,34,106,53,26]\n        \n        # Define Iy Column\n        df[\"Iy (in\\u2074)\"] = [1690,1090,493,2250,1010,411,1240,598,128,823,340,94.4,542,305,64.7,278,152,19.1,119,28.9,12.4,362,57.7,23.3,301,95.8,17.3]\n\n        # Create Solution Dataframe\n        instr=pd.DataFrame()\n        instr[\"First Num\"] =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        instr[\"Second Num\"] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        \n        # Search for Possible Solutions\n        i = 0\n        while i &lt; 27:\n            if df.iloc[i, 2] &gt;= I:\n                instr.iloc[i, 0] = df.iloc[i, 0]\n                instr.iloc[i, 1] = df.iloc[i, 1]\n            i += 1\n        instr = instr.loc[(instr != 0).any(axis=1)]\n\n        #Find Minimum Weight\n        wmin = min(instr.iloc[:,1])\n        mask = instr['Second Num'] == wmin\n        instr = pd.DataFrame(instr[mask])\n\n        correct1 = float(input.answer1()) == instr.iloc[0,0]\n        correct2 = float(input.answer2()) == instr.iloc[0,1]\n        \n        if correct1 and correct2:\n            check = \"both correct.\"\n        else:\n            check = f\" {'correct' if correct1 else 'incorrect'} and {'correct' if correct2 else 'incorrect'}.\"\n        \n        correct_indicator = \"JL\" if correct1 and correct2 else \"JG\"\n\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer1()}, {input.answer2()}, {check}\\n\")\n\n        feedback = ui.markdown(f\"Your answers of {input.answer1()} and {input.answer2()} are {check}.\")\n        m = ui.modal(feedback, title=\"Feedback\", easy_close=True)\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        yield \"Timestamp,Attempt,Answer1,Answer2,Feedback\\n\"\n        for attempt in attempts[1:]:\n            await asyncio.sleep(0.25)\n            yield attempt\n\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.14 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem15_15dynamicsubmit.html",
    "href": "problem15_15dynamicsubmit.html",
    "title": "Problem 15.15 - Effect of Supports",
    "section": "",
    "text": "[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]\n#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"625\"\nL=reactive.Value(\"__\")\nFS=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of lb\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"To draw attention, a junkyard owner mounts a car on top of a column of length L = {L()} ft made from a W8 x 15 beam (I&lt;sub&gt;x&lt;/sub&gt; = 48.0 in.&lt;sup&gt;4&lt;/sup&gt;, I&lt;sub&gt;y&lt;/sub&gt; = 3.41 in.&lt;sup&gt;4&lt;/sup&gt;). If the elastic modulus E = 29,000 ksi, what is the heaviest car body that can be used to avoid buckling? Use a factor of safety of {FS()}.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(150, 250, 1)/10)\n        FS.set(random.randrange(15, 30, 1)/10)\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        Pcr = math.pi**2*29*10**6*3.41/(4*L()**2*144)\n        instr= Pcr/FS()\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 15 Problems",
      "Problem 15.15 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem2_1staticsubmit.html",
    "href": "problem2_1staticsubmit.html",
    "title": "Problem 2.1 - Average Normal Stress",
    "section": "",
    "text": "Problem Statement\nA series of solid circular bars are loaded with three loads as shown, F1 = 60 N, F2 = 20 N, and F3 = 40 N. What is the largest absolute normal stress in any bar?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.1 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_2staticsubmit.html",
    "href": "problem2_2staticsubmit.html",
    "title": "Problem 2.2 - Average Normal Stress",
    "section": "",
    "text": "Problem Statement\nTwo cylinders are stacked on top of one another and two forces are applied at the top surface and at the joint between the cylinders as shown. If L1 = 3 in., L2 = 4 in., FA = 500 lb, and FB = 200 lb, find the average normal stress in cylinder B.\n [Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.2 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_3staticsubmit.html",
    "href": "problem2_3staticsubmit.html",
    "title": "Problem 2.3 - Average Normal Stress",
    "section": "",
    "text": "Problem Statement\nA plastic cylindrical peg is constrained by a metal cap as shown. An axial load of F = 40 lb is applied to the peg. If d1 = 0.5 in and d2 = 0.9 in, determine the normal stress in the peg. Assume the axial load is evenly distributed across the peg and that the metal cap is fixed and does not move.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.3 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_3staticsubmit.html#problem-statement",
    "href": "problem2_3staticsubmit.html#problem-statement",
    "title": "Problem 2.3 - Average Normal Stress",
    "section": "",
    "text": "Figure 1: A plastic cylindrical peg is constrained by a metal cap",
    "crumbs": [
      "Chapter 2",
      "Problem 2.3 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_4staticsubmit.html",
    "href": "problem2_4staticsubmit.html",
    "title": "Problem 2.4 - Average Normal Stress",
    "section": "",
    "text": "Problem Statement\nA crate weighing 45 kN is suspended by a set of cables. The diameter of each cable is 30 mm. What is the maximum stress in any cable, excluding the cable attached to the crate.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.4 - Average Normal Stress"
    ]
  },
  {
    "objectID": "problem2_21staticsubmit.html",
    "href": "problem2_21staticsubmit.html",
    "title": "Problem 2.21 - Average Shear Stress",
    "section": "",
    "text": "Problem Statement\nA double lap joint is glued together using glue with a shear stress failure strength of 8000 psi. If dimensions L = 6 in. and t = 8 in., what is the maximum load P that the joint can withstand? Assume the load is evenly distributed across the joint on both sides.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.21 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_22staticsubmit.html",
    "href": "problem2_22staticsubmit.html",
    "title": "Problem 2.22 - Average Shear Stress",
    "section": "",
    "text": "Problem Statement\nA bracket is attached to a wall with two circular rivets of diameter d = 20 mm. A load F = 50 kN is applied in the center of the bracket. Assuming the load is split evenly between the two rivits, determine the shear stress in each rivet.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.22 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_23staticsubmit.html",
    "href": "problem2_23staticsubmit.html",
    "title": "Problem 2.23 - Average Shear Stress",
    "section": "",
    "text": "Problem Statement\nA square bar of length L1 = 10 in. and L2 = 14 in. is pinned at one end and rests on a circular rod of diameter d = 5/8 in. A force F = 60 lb is applied at the free end. What is the average shear stress in the circular rod?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.23 - Average Shear Stress"
    ]
  },
  {
    "objectID": "problem2_38staticsubmit.html",
    "href": "problem2_38staticsubmit.html",
    "title": "Problem 2.38 - Bearing Stress",
    "section": "",
    "text": "Problem Statement\nA crate of weight W = 8000 lb hangs from a solid circular metal rod of diameter d1 = 1 in.. The cable is wrapped around a support collar of diameter d2 = 3 in. and thickness t = 2 in. to evenly distribute the cable load. What is the bearing stress on the support collar due to the rod?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.38 - Bearing Stress"
    ]
  },
  {
    "objectID": "problem2_39staticsubmit.html",
    "href": "problem2_39staticsubmit.html",
    "title": "Problem 2.39 - Bearing Stress",
    "section": "",
    "text": "Problem Statement\nA link mechanism is connected with pins of diameter d = 1/2 in. A force F = 500 lb is applied to the mechanism as shown. The mechanism has width w = 1 in. and thickness t = 1/4 in. What is the bearing stress in member BC at joint B due to the pin at B?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.39 - Bearing Stress"
    ]
  },
  {
    "objectID": "problem2_39staticsubmit.html#problem-statement",
    "href": "problem2_39staticsubmit.html#problem-statement",
    "title": "Problem 2.39 - Bearing Stress",
    "section": "",
    "text": "Figure 1: A link mechanism is connected with pins.",
    "crumbs": [
      "Chapter 2",
      "Problem 2.39 - Bearing Stress"
    ]
  },
  {
    "objectID": "problem2_41staticsubmit.html",
    "href": "problem2_41staticsubmit.html",
    "title": "Problem 2.41 - Bearing Stress",
    "section": "",
    "text": "Problem Statement\nA steel connector plate is hung from a brass rod of diameter d = 1 in. The plate has dimensions t = 0.5 in. and w = 2 in. Considering only bearing stress, find the minimum load that will cause the connector or rod to fail. Assume the failure bearing stress for brass is 70 ksi and for steel is 75 ksi.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.41 - Bearing Stress"
    ]
  },
  {
    "objectID": "problem2_47staticsubmit.html",
    "href": "problem2_47staticsubmit.html",
    "title": "Problem 2.47 - Stress on an Inclined Plane",
    "section": "",
    "text": "Problem Statement\nTwo slanted brackets are glued together as shown. If F = 500 lb, L = 4 in., and Œò = 20 ¬∞, determine the shear stress parallel to the inclined plane. Assume loads are inline and there is no rotation.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.47 - Stress on an Inclined Plane"
    ]
  },
  {
    "objectID": "problem2_48staticsubmit.html",
    "href": "problem2_48staticsubmit.html",
    "title": "Problem 2.48 - Stress on an Inclined Plane",
    "section": "",
    "text": "Problem Statement\nA 2 inch thick board is cut and then glued back together along a line that is Œò = 15¬∞ off the vertical as shown. If height h = 10 in. and F = 3500 lb, determine the normal stress along the cut line.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 2",
      "Problem 2.48 - Stress on an Inclined Plane"
    ]
  },
  {
    "objectID": "problem3_2staticsubmit.html",
    "href": "problem3_2staticsubmit.html",
    "title": "Problem 3.2 - Normal Strain",
    "section": "",
    "text": "Problem Statement\nDuring a tension test of a rectangular prism, the original gage length L = 200 mm is increased to L‚Äô = 201.43 mm. determine the normal strain, Œµ, in the prism.\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 3",
      "Problem 3.2 - Normal Strain"
    ]
  },
  {
    "objectID": "problem3_7staticsubmit.html",
    "href": "problem3_7staticsubmit.html",
    "title": "Problem 3.7 - Shear Strain",
    "section": "",
    "text": "Problem Statement\nA square plate is deformed due to shear with the new shape shown. If length L = 300 mm and x = 42 mm, determine the shear strain at corner A\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 3",
      "Problem 3.7 - Shear Strain"
    ]
  },
  {
    "objectID": "problem4_5staticsubmit.html",
    "href": "problem4_5staticsubmit.html",
    "title": "Problem 4.5 - Hooke‚Äôs Law",
    "section": "",
    "text": "Problem Statement\nA single force F = 3 kips pulls on three cylindrical rods, each of length L = 6 in., Diameter d1 = 2 in., and d2 = 1 in. What is the strain in the steel cylinder? Assume Esteel = 29,000 ksi and Ealuminum = 10,000 ksi.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.5 - Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_5staticsubmit.html#problem-statement",
    "href": "problem4_5staticsubmit.html#problem-statement",
    "title": "Problem 4.5 - Hooke‚Äôs Law",
    "section": "",
    "text": "Figure 1: A single force pulls on three cylindrical rods that are fixed to a wall.",
    "crumbs": [
      "Chapter 4",
      "Problem 4.5 - Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_6staticsubmit.html",
    "href": "problem4_6staticsubmit.html",
    "title": "Problem 4.6 - Hooke‚Äôs Law",
    "section": "",
    "text": "Problem Statement\nA polymer test specimen is subjected to an axial load of F = 18 kips. The central portion of the specimen has an initial length L = 8 in., w = 3 in., and t = 1/4 in. If the length increases by dL = 0.052 in., determine the elastic modulus of the material.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.6 - Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_6staticsubmit.html#problem-statement",
    "href": "problem4_6staticsubmit.html#problem-statement",
    "title": "Problem 4.6 - Hooke‚Äôs Law",
    "section": "",
    "text": "Figure 1: A polymer test specimen is pulled from the top and bottom.",
    "crumbs": [
      "Chapter 4",
      "Problem 4.6 - Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_10staticsubmit.html",
    "href": "problem4_10staticsubmit.html",
    "title": "Problem 4.10 - Poisson‚Äôs Ratio",
    "section": "",
    "text": "Problem Statement\nA circular rod of an unknown metallic alloy is placed in tension with a P = 5 kip axial load. The length of the rod is L = 10 in. and the diameter is d = 1 in. After applying the load, the rod length increases by 0.0035 in and the diameter decreases by 0.00014 in. What is the Poisson‚Äôs ratio of the alloy?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.10 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_10staticsubmit.html#problem-statement",
    "href": "problem4_10staticsubmit.html#problem-statement",
    "title": "Problem 4.10 - Poisson‚Äôs Ratio",
    "section": "",
    "text": "Figure 1: A circular road is placed in tension with an axial load.",
    "crumbs": [
      "Chapter 4",
      "Problem 4.10 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_11staticsubmit.html",
    "href": "problem4_11staticsubmit.html",
    "title": "Problem 4.11 - Poisson‚Äôs Ratio",
    "section": "",
    "text": "Problem Statement\nAn aluminum circular rod of radius r1 = 2 in is inserted into space that is slightly wider than the rod, where r2 = 2.003 in. What load P is needed so that the rod expands and fills the space in the radial direction? Assume E = 15,000 ksi and v = 0.33.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.11 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_11staticsubmit.html#problem-statement",
    "href": "problem4_11staticsubmit.html#problem-statement",
    "title": "Problem 4.11 - Poisson‚Äôs Ratio",
    "section": "",
    "text": "Figure 1: A circular rod is inserted into a space slightly wider than the rod.",
    "crumbs": [
      "Chapter 4",
      "Problem 4.11 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_12staticsubmit.html",
    "href": "problem4_12staticsubmit.html",
    "title": "Problem 4.12 - Poisson‚Äôs Ratio",
    "section": "",
    "text": "Problem Statement\nA rectangular bar is pulled in tension by a load P in the x-direction. The bar deflects by d1 = 0.0350 in and d2 = 0.0012 in, in the x- and y-direction, respectively. The length in the x-direction is 5 in, and the length in the y direction is 1 in. What is the Poisson‚Äôs ratio of the material? The z-direction deflection is not known.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.12 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_12staticsubmit.html#problem-statement",
    "href": "problem4_12staticsubmit.html#problem-statement",
    "title": "Problem 4.12 - Poisson‚Äôs Ratio",
    "section": "",
    "text": "Figure 1: A rectangular rod is pulled in tension in the x-direction.",
    "crumbs": [
      "Chapter 4",
      "Problem 4.12 - Poisson's Ratio"
    ]
  },
  {
    "objectID": "problem4_18staticsubmit.html",
    "href": "problem4_18staticsubmit.html",
    "title": "Problem 4.18 - Thermal Strain",
    "section": "",
    "text": "Problem Statement\nA copper pipe (Œ± = 17x10-6 /¬∞C) of length L = 6.2 m is cooled from 31¬∞C to to 4¬∞C. Determine the longitudinal strain in the cooled pipe.\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.18 - Thermal Strain"
    ]
  },
  {
    "objectID": "problem4_19staticsubmit.html",
    "href": "problem4_19staticsubmit.html",
    "title": "Problem 4.19 - Thermal Strain",
    "section": "",
    "text": "Problem Statement\nUpon plant startup, a steel steam pipe (Œ± = 6.5 x 10-6 /¬∞F) of length L = 120 ft is raised in temperature from an ambient temperature of 65¬∞F to 413¬∞F. Determine the change in length of the pipe.\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.19 - Thermal Strain"
    ]
  },
  {
    "objectID": "problem4_23staticsubmit.html",
    "href": "problem4_23staticsubmit.html",
    "title": "Problem 4.23 - Multiaxial Hooke‚Äôs Law",
    "section": "",
    "text": "Problem Statement\nA square steel plate of side length L = 6 in. and thickness t = 1/2 in. is uniformly pulled by two forces Fx = 15 kips and Fy = 25 kips as shown. If E = 29,000 ksi and Poisson‚Äôs ratio v = 0.29, determine the change in thickness of the plate.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.23 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_23staticsubmit.html#problem-statement",
    "href": "problem4_23staticsubmit.html#problem-statement",
    "title": "Problem 4.23 - Multiaxial Hooke‚Äôs Law",
    "section": "",
    "text": "Figure 1: A block is pulled in by two forces.",
    "crumbs": [
      "Chapter 4",
      "Problem 4.23 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_24staticsubmit.html",
    "href": "problem4_24staticsubmit.html",
    "title": "Problem 4.24 - Multiaxial Hooke‚Äôs Law",
    "section": "",
    "text": "Problem Statement\nA strain gauge is placed on a polymer test sample with an elastic modulus E = 1 x 107 psi and a Poisson‚Äôs ratio of v = 0.3. When a P1 = 5 kip vertical load is applied to the test sample, the strain gauge reads a strain of SG = 11 x 10-6 in the x-direction. What is the relative error of the strain gauge compared to the theoretical strain of the test sample? Note: relative error is defined to be the difference between the measured value and the theoretical value divided by the theoretical value.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.24 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_24staticsubmit.html#problem-statement",
    "href": "problem4_24staticsubmit.html#problem-statement",
    "title": "Problem 4.24 - Multiaxial Hooke‚Äôs Law",
    "section": "",
    "text": "Figure 1: A strain gauge is placed on a test sample and a vertical load is applied to the test sample.",
    "crumbs": [
      "Chapter 4",
      "Problem 4.24 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_25staticsubmit.html",
    "href": "problem4_25staticsubmit.html",
    "title": "Problem 4.25 - Multiaxial Hooke‚Äôs Law",
    "section": "",
    "text": "Problem Statement\nA block is pulled in all three directions (Px = 3 kN, Py = 3 kN, Pz = 6 kN). What is the percent change in volume after all three loads are applied? Assume E = 1,500 MPa and v = 0.35.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.25 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_25staticsubmit.html#problem-statement",
    "href": "problem4_25staticsubmit.html#problem-statement",
    "title": "Problem 4.25 - Multiaxial Hooke‚Äôs Law",
    "section": "",
    "text": "Figure 1: A block is pulled in all three directions.",
    "crumbs": [
      "Chapter 4",
      "Problem 4.25 - Multiaxial Hooke's Law"
    ]
  },
  {
    "objectID": "problem4_35staticsubmit.html",
    "href": "problem4_35staticsubmit.html",
    "title": "Problem 4.35 - Allowable Stress/Safety Factor",
    "section": "",
    "text": "Problem Statement\nA small truss is constructed with solid square wood members and subjected to a load of F = 30 kN. Determine the minimum dimension, a, of the member so that the truss will have a factor of safety of 2. All members have the same cross-section. The wood has a failure stress of œÉfail = 50 MPa.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 4",
      "Problem 4.35 - Allowable Stress/Safety Factor"
    ]
  },
  {
    "objectID": "problem5_6staticsubmit.html",
    "href": "problem5_6staticsubmit.html",
    "title": "Problem 5.6 - Stress Concentrations",
    "section": "",
    "text": "Problem Statement\nA flat bar of thickness t = 9 mm contains a hole as shown. The bar is subjected to a tensile load P = 4.7 kN. Determine the maximum tensile stress in the bar.\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.6 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_8staticsubmit.html",
    "href": "problem5_8staticsubmit.html",
    "title": "Problem 5.8 - Stress Concentrations",
    "section": "",
    "text": "Problem Statement\nA flat bar of thickness t = 0.25 in. narrows with fillets as shown. If a load P = 3200 lb is applied, determine the maximum stress in the bar.\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.8 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_8staticsubmit.html#problem-statement",
    "href": "problem5_8staticsubmit.html#problem-statement",
    "title": "Problem 5.8 - Stress Concentrations",
    "section": "",
    "text": "Figure 1: A bar narrows in width.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.8 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_10staticsubmit.html",
    "href": "problem5_10staticsubmit.html",
    "title": "Problem 5.10 - Stress Concentrations",
    "section": "",
    "text": "Problem Statement\nThe linkage of thickness t = 0.5 in. shown is subjected to load P = 25 kips. Determine the maximum stress in the linkage.\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.10 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_10staticsubmit.html#problem-statement",
    "href": "problem5_10staticsubmit.html#problem-statement",
    "title": "Problem 5.10 - Stress Concentrations",
    "section": "",
    "text": "Figure 1: A linkage is subjected to a loading as shown.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.10 - Stress Concentrations"
    ]
  },
  {
    "objectID": "problem5_11staticsubmit.html",
    "href": "problem5_11staticsubmit.html",
    "title": "Problem 5.11 - Axial Deformation",
    "section": "",
    "text": "Problem Statement\nA series of solid, steel, circular bars are loaded with forces as shown, where F1 = 3 kN, F2 = 2 kN, F3 = 3 kN, and F4 = 4 kN. What is the total change in length of the system? Assume E = 210 GPa for steel.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.11 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_11staticsubmit.html#problem-statement",
    "href": "problem5_11staticsubmit.html#problem-statement",
    "title": "Problem 5.11 - Axial Deformation",
    "section": "",
    "text": "Figure 1: A series of solid, steel, circular bars are loaded with forces.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.11 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_12staticsubmit.html",
    "href": "problem5_12staticsubmit.html",
    "title": "Problem 5.12 - Axial Deformation",
    "section": "",
    "text": "Problem Statement\nTwo forces, F1 = 15 kN and F2 = 10 kN, are applied to the system of cylinders as shown. If L1 = 5 m, L2 = 3 m, and L3 = 4 m, what is the total change in length of the system? Assume Esteel = 210 GPa and Ealuminum = 70 GPa.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.12 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_12staticsubmit.html#problem-statement",
    "href": "problem5_12staticsubmit.html#problem-statement",
    "title": "Problem 5.12 - Axial Deformation",
    "section": "",
    "text": "Figure 1: Two forces are applied to the system of cylinders.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.12 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_13staticsubmit.html",
    "href": "problem5_13staticsubmit.html",
    "title": "Problem 5.13 - Axial Deformation",
    "section": "",
    "text": "Problem Statement\nTwo forces, F1 = 1 kN and F2 = 2 kN, are applied to the system of cylinders as shown. If L1 = 10 mm and L2 = 14 mm, what is the total change in length of the system. Assume Ebrass = 100 GPa and Ealuminum = 70 GPa.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.13 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_13staticsubmit.html#problem-statement",
    "href": "problem5_13staticsubmit.html#problem-statement",
    "title": "Problem 5.13 - Axial Deformation",
    "section": "",
    "text": "Figure 1: Two forces are applied to the system of cylinders.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.13 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_14staticsubmit.html",
    "href": "problem5_14staticsubmit.html",
    "title": "Problem 5.14 - Axial Deformation",
    "section": "",
    "text": "Problem Statement\nA series of solid circular steel bars are loaded as shown, where F1 = 60 N, F2 = 20 N, and F3 = 40 N. If lengths L1 = L2 = 30 cm and L3 = 40 cm, determine the total change in length of the system. Assume Esteel = 210 GPa.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.14 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_14staticsubmit.html#problem-statement",
    "href": "problem5_14staticsubmit.html#problem-statement",
    "title": "Problem 5.14 - Axial Deformation",
    "section": "",
    "text": "Figure 1: A series of solid circular steel bars are loaded with three loads.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.14 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_15staticsubmit.html",
    "href": "problem5_15staticsubmit.html",
    "title": "Problem 5.15 - Axial Deformation",
    "section": "",
    "text": "Problem Statement\nA crate weight W = 120 lb is attached to a cable constructed from steel of length L1 = 12 in. and Area A1 = 0.02 in.2 and aluminum of length L2 = 24 in. and area A2 = 0.03 in.2. What is the total deflection of the crate after it is attached to the wire? Assume Esteel = 29,000 ksi and Ealuminum = 10,000 ksi. Neglect the weight of the wires.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.15 - Axial Deformation"
    ]
  },
  {
    "objectID": "problem5_27staticsubmit.html",
    "href": "problem5_27staticsubmit.html",
    "title": "Problem 5.27 - Deformation in Systems of Bars",
    "section": "",
    "text": "Problem Statement\nA bar is attached to two wires, one steel and one aluminum. If the lengths of the wires L1 = 8 in. and L2 = 10 in., find the distance x that load F = 5 kips must be placed at so that the bar remains horizontal after the load is applied. Both wires have the same cross-section area A = 0.02 in.2. Assume Esteel = 29,000 ksi, Ealuminum = 10,000 ksi and that the bar is of length L = 12 in.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.27 - Deformation in Systems of Bars"
    ]
  },
  {
    "objectID": "problem5_27staticsubmit.html#problem-statement",
    "href": "problem5_27staticsubmit.html#problem-statement",
    "title": "Problem 5.27 - Deformation in Systems of Bars",
    "section": "",
    "text": "Figure 1: A bar is attached to two wires, one steel and one aluminum.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.27 - Deformation in Systems of Bars"
    ]
  },
  {
    "objectID": "problem5_34staticsubmit.html",
    "href": "problem5_34staticsubmit.html",
    "title": "Problem 5.34 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA copper circular rod of radius r = 4 cm is inserted into an aluminum tube with inner radius ri = 5 cm and outer radius ro = 6 cm as shown. Load P is applied to the rigid top plate. If length L = 15 cm, what load P will cause the plate to deflect dL = 0.23 mm downward? Assume Ecopper = 110 GPa and Ealuminum = 70 GPa.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.34 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_34staticsubmit.html#problem-statement",
    "href": "problem5_34staticsubmit.html#problem-statement",
    "title": "Problem 5.34 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: A copper circular rod is inserted into an aluminum tube as shown.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.34 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_35staticsubmit.html",
    "href": "problem5_35staticsubmit.html",
    "title": "Problem 5.35 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nTwo blocks with square cross-sections are stacked as shown, with the top block inserted into the bottom block and subjected to load F = 3.4 kips. The top block is aluminum (E = 10,000 ksi) with side length w1 = 2 in. and the bottom block is steel (E = 29,000 ksi) with side length w2 = 3 in. If length L = 5 in., what is the total deflection of the top surface? Ignore the weight of the blocks.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.35 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_35staticsubmit.html#problem-statement",
    "href": "problem5_35staticsubmit.html#problem-statement",
    "title": "Problem 5.35 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: Two blocks with square cross sections are stacked and loaded at the top.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.35 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_36staticsubmit.html",
    "href": "problem5_36staticsubmit.html",
    "title": "Problem 5.36 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nTwo square members are attached to two fixed walls as shown. Force F is applied at point B and point B is displaced d = 0.002 in. to the right. If L = 5 in., Ewood = 1,750 ksi, and Eplastic = 400 ksi, determine the applied force F.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.36 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_36staticsubmit.html#problem-statement",
    "href": "problem5_36staticsubmit.html#problem-statement",
    "title": "Problem 5.36 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: Two square members are placed between two fixed walls.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.36 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_37staticsubmit.html",
    "href": "problem5_37staticsubmit.html",
    "title": "Problem 5.37 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nTwo aluminum circular rods are attached to two fixed walls as shown. Assume E = 70 MPa for both cylinders, F = 30 kN, d1 = 20 mm, d2 = 30 mm, L1 = 300 mm, and L2 = 200 mm. Determine the normal stress in member 1.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.37 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_37staticsubmit.html#problem-statement",
    "href": "problem5_37staticsubmit.html#problem-statement",
    "title": "Problem 5.37 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: Two aluminum circular rods are placed between two fixed walls.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.37 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_38staticsubmit.html",
    "href": "problem5_38staticsubmit.html",
    "title": "Problem 5.38 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA distributed load w = 100 N/cm2 is applied to a short column made from wood and concrete. Assume Econcrete = 25 GPa, Ewood = 12 GPa, b = 3 cm, h1 = 3 cm, and h2 = 6 cm. What load is carried by the concrete center?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.38 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_38staticsubmit.html#problem-statement",
    "href": "problem5_38staticsubmit.html#problem-statement",
    "title": "Problem 5.38 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: A pressure load is applied to a short column made of wood and concrete.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.38 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_39staticsubmit.html",
    "href": "problem5_39staticsubmit.html",
    "title": "Problem 5.39 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA concrete post of length L = 0.3 m and diameter dc = 120 mm supports a load F = 150 kN. The concrete is reinforced with 6 steel rods of diameter ds = 10 mm. Assume Econcrete = 25 GPa and Esteel = 200 GPa. Determine the stress in the concrete.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.39 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_39staticsubmit.html#problem-statement",
    "href": "problem5_39staticsubmit.html#problem-statement",
    "title": "Problem 5.39 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: A concrete post with 6 steel rebar rods embedded in the concrete supports a load.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.39 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem5_50staticsubmit.html",
    "href": "problem5_50staticsubmit.html",
    "title": "Problem 5.50 - Thermal Deformation",
    "section": "",
    "text": "Problem Statement\nThe axial stress in a solid circular bar between two fixed walls is 30 ksi. Find the temperature change necessary to relieve the stress. Assume L = 30 in., E = 29,000 ksi, and Œ± = 6.5 x 10-6 / ¬∞F.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.50 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_50staticsubmit.html#problem-statement",
    "href": "problem5_50staticsubmit.html#problem-statement",
    "title": "Problem 5.50 - Thermal Deformation",
    "section": "",
    "text": "Figure 1: A solid circular bar is between two fixed walls.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.50 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_51staticsubmit.html",
    "href": "problem5_51staticsubmit.html",
    "title": "Problem 5.51 - Thermal Deformation",
    "section": "",
    "text": "Problem Statement\nThe W = 1,000 kg weight is placed on a L = 1 m tall brass bar with a cross section of d = 2.5 cm. If the bar undergoes a temperature change of 50¬∞C, what is the total deformation of the bar? Assume the Young‚Äôs Modulus and thermal coefficient of expansion is 100 GPa and 10 x 10-6 /¬∞C, respectively. Also, assume no buckling.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.51 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_51staticsubmit.html#problem-statement",
    "href": "problem5_51staticsubmit.html#problem-statement",
    "title": "Problem 5.51 - Thermal Deformation",
    "section": "",
    "text": "Figure 1: A weight is placed on a tall brass bar.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.51 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_52staticsubmit.html",
    "href": "problem5_52staticsubmit.html",
    "title": "Problem 5.52 - Thermal Deformation",
    "section": "",
    "text": "Problem Statement\nTwo cylindrical rods are heated until they expand, just closing the gap of d = 0.01 in. The coefficient of thermal expansion, Œ±, for material A and B is 6 x 10-6/¬∞F and 10 x 10-6/¬∞F, respectively. The radius of A rA = 0.5 in and the length is L1 = 10 in. The radius of B is rB = 0.8 in and the length is L2 = 6 in. What is the change in temperature?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.52 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_52staticsubmit.html#problem-statement",
    "href": "problem5_52staticsubmit.html#problem-statement",
    "title": "Problem 5.52 - Thermal Deformation",
    "section": "",
    "text": "Figure 1: Two cylindrical rods are connected and heated until they expand to close a gap.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.52 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_53staticsubmit.html",
    "href": "problem5_53staticsubmit.html",
    "title": "Problem 5.53 - Thermal Deformation",
    "section": "",
    "text": "Problem Statement\nThree cylindrical rods of lengths L1 = 0.12 m, L2 = 0.1 m, and L3 = 0.08 m are connected together. A force F = 15 kN is applied to the free end and all three rods are heated by 120 ¬∞C. The coefficient of thermal expansion, Œ±, and elastic modulus, E, for each material are Œ±A = 10 x 10-6 /¬∞C, Œ±B = 5 x 10-6 /¬∞C, Œ±C = 7 x 10-6 /¬∞C, EA = 40 GPa, EB = 120 GPa, and EC = 80 GPa. What is the total deflection of the right rod tip?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.53 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_53staticsubmit.html#problem-statement",
    "href": "problem5_53staticsubmit.html#problem-statement",
    "title": "Problem 5.53 - Thermal Deformation",
    "section": "",
    "text": "Figure 1: Three cylindrical rods are rigidly connected togehter with a load applied to the free end.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.53 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_54staticsubmit.html",
    "href": "problem5_54staticsubmit.html",
    "title": "Problem 5.54 - Thermal Deformation",
    "section": "",
    "text": "Problem Statement\nA square brass bar is placed between two fixed walls and heated from 5 ¬∞C to 35 ¬∞C. If L = 450 mm, h = 15 mm, E = 100 GPa, and Œ± = 20 x 10-6 /¬∞C, determine the stress in the bar.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.54 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_54staticsubmit.html#problem-statement",
    "href": "problem5_54staticsubmit.html#problem-statement",
    "title": "Problem 5.54 - Thermal Deformation",
    "section": "",
    "text": "Figure 1: A long square brass bar is placed between two fixed walls.",
    "crumbs": [
      "Chapter 5",
      "Problem 5.54 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem5_55staticsubmit.html",
    "href": "problem5_55staticsubmit.html",
    "title": "Problem 5.55 - Thermal Deformation",
    "section": "",
    "text": "Problem Statement\nBars AB and BC are pinned at joint B. Both bars are made from the same material with E = 200 GPa, v = 0.32, and a = 11.7 x 10-6 /¬∞C. Dimensions L = 400 mm, t = 33 mm, h = 15 mm, and d = 10 mm. If both bars are heated by 20 ¬∞C, determine the shear stress generated in the pin at B.\n{fig-alt=‚Äù Two bars are pinned at joint B between two walls. Joint AB is on the left hand side and joint BC is on the right hand side. Both bars are length L and thickness t and height h. The diameter of the bolt holding them together is d.¬†‚Äú}\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 5",
      "Problem 5.55 - Thermal Deformation"
    ]
  },
  {
    "objectID": "problem6_1staticsubmit.html",
    "href": "problem6_1staticsubmit.html",
    "title": "Problem 6.1 - Torsional Stress",
    "section": "",
    "text": "Problem Statement\nWhat torque is required to create a maximum shear stress of œÑ = 50 MPa in a solid circular bar of diameter d = 60 mm?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.1 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_1staticsubmit.html#problem-statement",
    "href": "problem6_1staticsubmit.html#problem-statement",
    "title": "Problem 6.1 - Torsional Stress",
    "section": "",
    "text": "Figure 1: A bar is fixed to a wall at one end.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.1 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_2staticsubmit.html",
    "href": "problem6_2staticsubmit.html",
    "title": "Problem 6.2 - Torsional Stress",
    "section": "",
    "text": "Problem Statement\nA force F = 150 lb is applied to a hand crank that is stuck and will not turn. If L = 10 in. and y = 5 in., determine the maximum shear stress due to torsion in the crank rod between A and B. Assume the crank has diameter d = 0.5 in.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.2 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_2staticsubmit.html#problem-statement",
    "href": "problem6_2staticsubmit.html#problem-statement",
    "title": "Problem 6.2 - Torsional Stress",
    "section": "",
    "text": "Figure 1: A hand crank is attached to a wall.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.2 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_3staticsubmit.html",
    "href": "problem6_3staticsubmit.html",
    "title": "Problem 6.3 - Torsional Stress",
    "section": "",
    "text": "Problem Statement\nTwo torques are applied to a two part circular rod as shown. If T1 = 6 kip-in., T2 = 2 kip-in., d1 = 5 in., and d2 = 4 in., what is the magnitude of the maximum shear stress?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.3 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_4staticsubmit.html",
    "href": "problem6_4staticsubmit.html",
    "title": "Problem 6.4 - Torsional Stress",
    "section": "",
    "text": "Problem Statement\nThree belt pulleys are connected to a solid circular shaft of diameter d = 3 in. that rotates freely at joints A and E. The pulleys are subjected to forces F1 = 1 kips, F2 = 1 kips, and F3 = 1.5 kips. What is the maximum shear stress in the shaft between pulleys B and C?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.4 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_5staticsubmit.html",
    "href": "problem6_5staticsubmit.html",
    "title": "Problem 6.5 - Torsional Stress",
    "section": "",
    "text": "Problem Statement\nTwo torques ,TB = 0.6 kip-ft and TC = 0.3 kip-ft, are applied to the hollow pipe as shown. If L = 1 ft., ro = 2.5 in., and ri = 2 in., determine the maximum shear stress in the pipe.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.5 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_5staticsubmit.html#problem-statement",
    "href": "problem6_5staticsubmit.html#problem-statement",
    "title": "Problem 6.5 - Torsional Stress",
    "section": "",
    "text": "Figure 1: Two torques are applied to a hollow pipe attached to the wall.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.5 - Torsional Stress"
    ]
  },
  {
    "objectID": "problem6_11staticsubmit.html",
    "href": "problem6_11staticsubmit.html",
    "title": "Problem 6.11 - Torsional Deformation",
    "section": "",
    "text": "Problem Statment\nA hollow copper rod (E = 110 GPa, v = 0.33) is subjected to torque T as shown. If length L = 0.8 m, outer diameter do = 80 mm, and inner diameter di = 40 mm, determine torque T if the rod twists 2¬∞.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.11 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_11staticsubmit.html#problem-statment",
    "href": "problem6_11staticsubmit.html#problem-statment",
    "title": "Problem 6.11 - Torsional Deformation",
    "section": "",
    "text": "Figure 1: A hollow copper rod is fixed to a wall at one end and a torque is applied",
    "crumbs": [
      "Chapter 6",
      "Problem 6.11 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_12staticsubmit.html",
    "href": "problem6_12staticsubmit.html",
    "title": "Problem 6.12 - Torsional Deformation",
    "section": "",
    "text": "Problem Statement\nA bar with a shear modulus G = 11 x 106 psi is subjected to torques T1 = 1,500 lb-ft at its center and T2 at its free end. The inner diameter is 1 in and the outer diameter is 2 in and the total length of the bar is 10 in. If the rotation of the rod at its free end is Œ¶ = 2¬∞ clockwise, what is the magnitude of torque T2?\n{fig-alt=‚Äù A bar is attached to a wall. The bar has an inner diameter of 1 in and outer diameter of 2 in. Torque, T[1] is applied halfway down the bar. The bar length is 10 in total.‚Äù}\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.12 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_13staticsubmit.html",
    "href": "problem6_13staticsubmit.html",
    "title": "Problem 6.13 - Torsional Deformation",
    "section": "",
    "text": "Problem Statement\nThree moments are applied to the system of cylinders as shown. Assume T1 = 3 kN-m, T2 = 6 kN-m, and T3 = -4 kN-m. If Gsteel = 77 GPa and Galuminum = 27 GPa, determine the total angle of twist at the free end.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.13 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_13staticsubmit.html#problem-statement",
    "href": "problem6_13staticsubmit.html#problem-statement",
    "title": "Problem 6.13 - Torsional Deformation",
    "section": "",
    "text": "Figure 1: A system of cylinders are attached to the wall at one end.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.13 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_14staticsubmit.html",
    "href": "problem6_14staticsubmit.html",
    "title": "Problem 6.14 - Torsional Deformation",
    "section": "",
    "text": "Problem Statement\nA circular rod of length L = 350 mm, outer radius ro = 30 mm, and unknown inner radius ri has a shear modulus G = 80 GPa. The rod is subjected to torque T = 1.25 kN-m at the free end. If the angle of twist must not exceed 2¬∞ and the shear stress must not exceed 100 MPa, what is the minimum required inner radius?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.14 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_14staticsubmit.html#problem-statement",
    "href": "problem6_14staticsubmit.html#problem-statement",
    "title": "Problem 6.14 - Torsional Deformation",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length)) \n\nproblem_ID=\"270\"\nL=reactive.Value(\"__\")\nro=reactive.Value(\"__\")\nT=reactive.Value(\"__\")\nG=reactive.Value(\"__\")\nstress=reactive.Value(\"__\")\n\nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of mm\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A circular rod of length L = {L()} mm, outer radius r&lt;sub&gt;o&lt;/sub&gt; = {ro()} mm, and unknown inner radius r&lt;sub&gt;i&lt;/sub&gt; has a shear modulus G = {G()} GPa. The rod is subjected to torque T = {T()} kN-m at the free end. If the angle of twist must not exceed 2¬∞ and the shear stress must not exceed {stress()} MPa, what is the minimum required inner radius?\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        L.set(random.randrange(250, 500, 10))\n        ro.set(random.randrange(30, 75, 1))\n        G.set(random.randrange(60, 100, 1))\n        T.set(random.randrange(10, 100, 1)/10)\n        stress.set(random.randrange(75, 150, 1))\n        \n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        r1= ((ro()/1000)**4-(2*T()*1000*ro()/1000/(math.pi*stress()*10**6)))**0.25*1000\n        r2 = ((ro()/1000)**4-(2*T()*1000*L()/1000/(math.pi*G()*10**9*2*math.pi/180)))**0.25*1000\n        if r1&gt;r2:\n            instr = r2\n        else:\n            instr = r1\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 6",
      "Problem 6.14 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_15staticsubmit.html",
    "href": "problem6_15staticsubmit.html",
    "title": "Problem 6.15 - Torsional Deformation",
    "section": "",
    "text": "Problem Statement\nA hollow circular rod is attached to a wall and subjected to a torque T = 3 kN-m at the free end.The rod has inner diameter 8 cm and outer diameter 10 cm. Determine the angle of twist at x = 300 mm. Assume G = 100 GPa and L = 500 mm.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.15 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_15staticsubmit.html#problem-statement",
    "href": "problem6_15staticsubmit.html#problem-statement",
    "title": "Problem 6.15 - Torsional Deformation",
    "section": "",
    "text": "Figure 1: A hollow circualr rod is attached to a wall and subjected to a torque at the free end.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.15 - Torsional Deformation"
    ]
  },
  {
    "objectID": "problem6_22staticsubmit.html",
    "href": "problem6_22staticsubmit.html",
    "title": "Problem 6.22 - Power Transmission & Gear Assemblies",
    "section": "",
    "text": "Problem Statement\nThe steel shaft is being turned by an electric motor providing 20 kW of power at 180 rpm. Power is extracted at B with a torque of 600 N‚∏±m. Determine the remaining torque available for the gear at C.\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.22 - Power Transmission & Gear Assemblies"
    ]
  },
  {
    "objectID": "problem6_23staticsubmit.html",
    "href": "problem6_23staticsubmit.html",
    "title": "Problem 6.23 - Power Transmission & Gear Assemblies",
    "section": "",
    "text": "Problem Statement\nA lawnmower engine supplying 2 hp running at 3200 rpm is being used to power a homemade winch. Given the gearing shown, determine the heaviest load that can be lifted.\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.23 - Power Transmission & Gear Assemblies"
    ]
  },
  {
    "objectID": "problem6_27staticsubmit.html",
    "href": "problem6_27staticsubmit.html",
    "title": "Problem 6.27 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA steel rod of diameter d = 40 mm is attached to walls A and C as shown. Two forces F = 2 kN are applied at distance L = 100 mm. If the shear modulus of the rod G = 75 GPa, determine the maximum shear stress in the rod.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.27 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem6_28staticsubmit.html",
    "href": "problem6_28staticsubmit.html",
    "title": "Problem 6.28 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA composite circular rod is made from two different plastics. A torque of T = 4 kN-m is applied at the midpoint. The right end is free. What is the maximum stress in either material? Assume length L = 10 cm and the shear modulus of the two materials are G1 = 2 GPa and G2 = 1 GPa.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.28 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem6_28staticsubmit.html#problem-statement",
    "href": "problem6_28staticsubmit.html#problem-statement",
    "title": "Problem 6.28 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: A composite circular rod is made from two different plastics. A torque is applied at the midpoint.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.28 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem6_29staticsubmit.html",
    "href": "problem6_29staticsubmit.html",
    "title": "Problem 6.29 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA composite circular rod is made from aluminum (G = 3,800 ksi) and steel (G = 11,000 ksi) as shown. A torque T = 800 lb-ft is applied to the free end. What is the maximum stress in either material? Assume length L = 12 in., outer radius ro = 1.5 in., and inner radius ri = 1 in.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.29 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem6_29staticsubmit.html#problem-statement",
    "href": "problem6_29staticsubmit.html#problem-statement",
    "title": "Problem 6.29 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: A composite circular rod is made from aluminum and steel.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.29 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem6_30staticsubmit.html",
    "href": "problem6_30staticsubmit.html",
    "title": "Problem 6.30 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA shaft is fixed between two walls. One portion is made from nickel (Gnickel = 11.4 x 106 psi) with a diameter of d1 = 2 in. The other portion is aluminum (Galuminum = 4 x 106 psi) with a diameter of d2 = 4 in. A torque T = 1,000 lb-ft is applied at the point where the two materials meet. If lengths L1 = 8 ft and L2 = 4 ft, what is the maximum shear stress in the shaft?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.30 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem6_30staticsubmit.html#problem-statement",
    "href": "problem6_30staticsubmit.html#problem-statement",
    "title": "Problem 6.30 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: A shaft made of two different materials is fixed between two walls.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.30 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem6_31staticsubmit.html",
    "href": "problem6_31staticsubmit.html",
    "title": "Problem 6.31 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nTwo steel (G = 80 GPa) circular rods are firmly welded together and attached between two walls. Assume d1 = 5 mm, d2 = 4 mm, and L = 25 mm. A torque T = 10 N-m is applied at the welded joint as shown. What is the highest stress in either rod?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 6",
      "Problem 6.31 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem6_31staticsubmit.html#problem-statement",
    "href": "problem6_31staticsubmit.html#problem-statement",
    "title": "Problem 6.31 - Statically Indeterminate Problems",
    "section": "",
    "text": "Figure 1: Two steel circular rods are firmly welded together and attached between two walls.",
    "crumbs": [
      "Chapter 6",
      "Problem 6.31 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem7_1staticsubmit.html",
    "href": "problem7_1staticsubmit.html",
    "title": "Problem 7.1 - Internal Shear Force & Bending Moment by Equilibrium",
    "section": "",
    "text": "Problem Statement\nA beam is subjected to the loading shown, where w = 60 lb/ft and F = 400 lb. Determine the internal shear force and bending moment at section a-a.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.1 - Internal Shear Force & Bending Moment by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_1staticsubmit.html#problem-statement",
    "href": "problem7_1staticsubmit.html#problem-statement",
    "title": "Problem 7.1 - Internal Shear Force & Bending Moment by Equilibrium",
    "section": "",
    "text": "Figure 1: A beam is subjected to a distributed load and force applied.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.1 - Internal Shear Force & Bending Moment by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_2staticsubmit.html",
    "href": "problem7_2staticsubmit.html",
    "title": "Problem 7.2 - Internal Shear Force & Bending Moment by Equilibrium",
    "section": "",
    "text": "Problem Statement\nA beam is subjected to the loading shown, where w = 4 kN/m and L = 2 m. What is the internal bending moment at section a-a at x = 1 m?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.2 - Internal Shear Force & Bending Moment by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_2staticsubmit.html#problem-statement",
    "href": "problem7_2staticsubmit.html#problem-statement",
    "title": "Problem 7.2 - Internal Shear Force & Bending Moment by Equilibrium",
    "section": "",
    "text": "Figure 1: A beam is subjected to a triangular load as shown.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.2 - Internal Shear Force & Bending Moment by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_3staticsubmit.html",
    "href": "problem7_3staticsubmit.html",
    "title": "Problem 7.3 - Internal Shear Force & Bending Moment by Equilibrium",
    "section": "",
    "text": "Problem Statement\nThree loads are applied to the structure as shown, where F1 = 10 lb., F2 = 13 lb., and F3 = 10 lb applied at an angle Œò = 50¬∞. Determine the internal shear force and bending moment at section aa.\n{fig-alt=‚Äù unsure how to describe.‚Äù}\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.3 - Internal Shear Force & Bending Moment by Equilibrium"
    ]
  },
  {
    "objectID": "problem7_14staticsubmit.html",
    "href": "problem7_14staticsubmit.html",
    "title": "Problem 7.14 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "Problem Statement\nPlot the shear force and bending moment diagrams for the loading shown. Assume w = 5 kip/ft and L = 6 ft. What is the maximum absolute shear force and maximum absolute bending moment?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.14 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_14staticsubmit.html#problem-statement",
    "href": "problem7_14staticsubmit.html#problem-statement",
    "title": "Problem 7.14 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "Figure 1: A distributed load is applied to a beam.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.14 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_15staticsubmit.html",
    "href": "problem7_15staticsubmit.html",
    "title": "Problem 7.15 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "Problem Statement\nPlot the shear force and bending moment diagrams for the loading shown. Assume M = 10 kip-ft, L1 = 3 ft, and L2 = 4 ft. What is the maximum absolute shear force and maximum absolute bending moment?\n{fig-alt=‚Äù A beam is subjected to a clockwise moment at the left end A with supports at B and C. The distance between A and B is L1 and the distance between B and C is L2.‚Äù}\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.15 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_16staticsubmit.html",
    "href": "problem7_16staticsubmit.html",
    "title": "Problem 7.16 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "Problem Statement\nPlot the shear force and bending moment diagrams for the loading shown. Assume w = 10 lb/ft, M = 200 lb-ft, and L = 10 ft. What is the maximum absolute shear force and maximum absolute bending moment?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.16 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_16staticsubmit.html#problem-statement",
    "href": "problem7_16staticsubmit.html#problem-statement",
    "title": "Problem 7.16 - Shear Force & Bending Moment Equations",
    "section": "",
    "text": "Figure 1: A beam is subjected to a distributed load and a moment with supports at A and B.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.16 - Shear Force & Bending Moment Equations"
    ]
  },
  {
    "objectID": "problem7_25staticsubmit.html",
    "href": "problem7_25staticsubmit.html",
    "title": "Problem 7.25 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Problem Statement\nA shelf is loaded with four boxes as shown. Assume W1 = 5 lb, W2 = 10 lb, and L = 1 ft. Determine the maximum internal shear force.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.25 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_25staticsubmit.html#problem-statement",
    "href": "problem7_25staticsubmit.html#problem-statement",
    "title": "Problem 7.25 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Figure 1: A shelf is loaded with four boxes.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.25 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_26staticsubmit.html",
    "href": "problem7_26staticsubmit.html",
    "title": "Problem 7.26 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Problem Statement\nPlot the shear force and bending moment diagrams for the loading shown. Assume w = 30 kN/m, L1 = 3.6 m, and L2 = 1.2 m. What is the maximum absolute shear force and maximum absolute bending moment?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.26 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_26staticsubmit.html#problem-statement",
    "href": "problem7_26staticsubmit.html#problem-statement",
    "title": "Problem 7.26 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Figure 1: A beam is subjected to a distributed load with supports at A and B.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.26 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_27staticsubmit.html",
    "href": "problem7_27staticsubmit.html",
    "title": "Problem 7.27 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Problem Statement\nA beam is loaded as shown. Determine the distance from point A to where the internal shear force is zero. Assume w = 3 kN/m, F1 = 8 kN, and F2 = 5 kN.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.27 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_27staticsubmit.html#problem-statement",
    "href": "problem7_27staticsubmit.html#problem-statement",
    "title": "Problem 7.27 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Figure 1: A beam is loaded as shown.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.27 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_28staticsubmit.html",
    "href": "problem7_28staticsubmit.html",
    "title": "Problem 7.28 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Problem Statement\nPlot the shear force and bending moment diagrams for the loading shown. Assume w1 = 50 kN/m, and w2 = 10 kN/m. What is the maximum absolute shear force and maximum absolute bending moment?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.28 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_28staticsubmit.html#problem-statement",
    "href": "problem7_28staticsubmit.html#problem-statement",
    "title": "Problem 7.28 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Figure 1: A beam is subjected to two distributed loads.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.28 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_29staticsubmit.html",
    "href": "problem7_29staticsubmit.html",
    "title": "Problem 7.29 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Problem Statement\nPlot the shear force and bending moment diagrams for the loading shown. Assume w1 = 2 kip/ft and w2 = 4 kip/ft. What is the maximum absolute shear force and maximum absolute bending moment?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 7",
      "Problem 7.29 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem7_29staticsubmit.html#problem-statement",
    "href": "problem7_29staticsubmit.html#problem-statement",
    "title": "Problem 7.29 - Graphical Methods for Shear Force & Bending Moment Diagrams",
    "section": "",
    "text": "Figure 1: A beam is subjected to a non-uniform distributed load.",
    "crumbs": [
      "Chapter 7",
      "Problem 7.29 - Graphical Methods for Shear Force & Bending Moment Diagrams"
    ]
  },
  {
    "objectID": "problem8_1staticsubmit.html",
    "href": "problem8_1staticsubmit.html",
    "title": "Problem 8.1 - Centroid",
    "section": "",
    "text": "Problem Statement\nFor the composite cross-section shown, determine the centroid location, measured from the base. Assume dimensions b1 = 20 mm, b2 = 130 mm, h1 = 6 mm, h2 = 130 mm, and t = 4 mm.\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 8",
      "Problem 8.1 - Centroid"
    ]
  },
  {
    "objectID": "problem8_2staticsubmit.html",
    "href": "problem8_2staticsubmit.html",
    "title": "Problem 8.2 - Centroid",
    "section": "",
    "text": "Problem Statement\nFor the beam cross-section shown, determine the centroid location, measured from the top surface. Assume dimensions a = 3 in. and b = 3 in.\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 8",
      "Problem 8.2 - Centroid"
    ]
  },
  {
    "objectID": "problem8_7staticsubmit.html",
    "href": "problem8_7staticsubmit.html",
    "title": "Problem 8.7 - Area Moment of Inertia",
    "section": "",
    "text": "Problem Statement\nThe cross-section shows a concrete beam with two hollow round holes. Determine the area moment of inertia about the beam‚Äôs centroid. Assume lengths a = 5 in., b = 2 in., c = 6 in., d = 4 in., d1 = 3 in., and d2 = 6 in.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 8",
      "Problem 8.7 - Area Moment of Inertia"
    ]
  },
  {
    "objectID": "problem8_7staticsubmit.html#problem-statement",
    "href": "problem8_7staticsubmit.html#problem-statement",
    "title": "Problem 8.7 - Area Moment of Inertia",
    "section": "",
    "text": "Figure 1: A cross section has two round holes.",
    "crumbs": [
      "Chapter 8",
      "Problem 8.7 - Area Moment of Inertia"
    ]
  },
  {
    "objectID": "problem9_1staticsubmit.html",
    "href": "problem9_1staticsubmit.html",
    "title": "Problem 9.1 - Bending Stress",
    "section": "",
    "text": "Problem Statement\nA beam with a rectangular cross-section of base b = 80 mm and h = 200 mm is subjected to the leading shown. If w = 2 kN/m and L = 2 m, determine the magnitude of the largest bending stress in the beam.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.1 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_1staticsubmit.html#problem-statement",
    "href": "problem9_1staticsubmit.html#problem-statement",
    "title": "Problem 9.1 - Bending Stress",
    "section": "",
    "text": "Figure 1: Beam undergoing a distributed load.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.1 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_2staticsubmit.html",
    "href": "problem9_2staticsubmit.html",
    "title": "Problem 9.2 - Bending Stress",
    "section": "",
    "text": "Problem Statement\nA beam has the cross-section shown, where b1 = 10 mm, b2 = 30 mm, h1 = 20 mm, and h2 = 10 mm. The beam is subjected to a concentrated load F = 2 kN at its midpoint. If length L = 2 m, determine the magnitude of the maximum bending stress in the beam.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.2 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_2staticsubmit.html#problem-statement",
    "href": "problem9_2staticsubmit.html#problem-statement",
    "title": "Problem 9.2 - Bending Stress",
    "section": "",
    "text": "Figure 1: A beam has a force applied to it.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.2 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_3staticsubmit.html",
    "href": "problem9_3staticsubmit.html",
    "title": "Problem 9.3 - Bending Stress",
    "section": "",
    "text": "Problem Statement\nA person of mass m = 80 kg stands on the end of a diving board with cross-section b = 300 mm and h = 50 mm. If lengths L1 = 1 m and L2 = 2 m, determine the maximum bending stress in the board. Assume g = 9.81 m/s2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.3 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_3staticsubmit.html#problem-statement",
    "href": "problem9_3staticsubmit.html#problem-statement",
    "title": "Problem 9.3 - Bending Stress",
    "section": "",
    "text": "Figure 1: A diving board with a person standing on it.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.3 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_4staticsubmit.html",
    "href": "problem9_4staticsubmit.html",
    "title": "Problem 9.4 - Bending Stress",
    "section": "",
    "text": "Problem Statement\nA beam with a hollow circular cross-section of outer radius ro = 5.5 in. and inner radius ri = 5 in. is subjected to a distributed load as shown. If w = 100 lb/ft, L1 = 5 ft, and L2 = 10 ft, determine the magnitude of the maximum bending stress in the beam.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.4 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_4staticsubmit.html#problem-statement",
    "href": "problem9_4staticsubmit.html#problem-statement",
    "title": "Problem 9.4 - Bending Stress",
    "section": "",
    "text": "Figure 1: A beam with a circular cross section is subjected to a distributed load.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.4 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_5staticsubmit.html",
    "href": "problem9_5staticsubmit.html",
    "title": "Problem 9.5 - Bending Stress",
    "section": "",
    "text": "Problem Statement\nA beam has the cross-section shown where b = 2 in. and h = 2 in. If the cross-section is subjected to an internal bending moment of 10 kip-in, determine the magnitude of the bending stress at the bottom of the cross-section.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.5 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_5staticsubmit.html#problem-statement",
    "href": "problem9_5staticsubmit.html#problem-statement",
    "title": "Problem 9.5 - Bending Stress",
    "section": "",
    "text": "Figure 1: The cross section of a beam.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.5 - Bending Stress"
    ]
  },
  {
    "objectID": "problem9_21staticsubmit.html",
    "href": "problem9_21staticsubmit.html",
    "title": "Problem 9.21 - Beam Design",
    "section": "",
    "text": "Problem Statement\nA beam with a rectangular cross-section is subjected to a distributed load w = 3 kN/m as shown. The maximum allowable bending stress in the beam is 7 MPa. If length L = 5 m and the cross-sectional area of the beam is A = 0.025 m2, determine the required width (b) of the cross-section.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.21 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_21staticsubmit.html#problem-statement",
    "href": "problem9_21staticsubmit.html#problem-statement",
    "title": "Problem 9.21 - Beam Design",
    "section": "",
    "text": "Figure 1: A beam is subjected to a distributed load.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.21 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_22staticsubmit.html",
    "href": "problem9_22staticsubmit.html",
    "title": "Problem 9.22 - Beam Design",
    "section": "",
    "text": "Problem Statement\nA wide-flange beam supports two loads F = 12 kN as shown. If L = 2 m and the allowable stress is œÉ = 250 MPa, what is the lightest W-beam in Appendix A that could be used for the beam?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.22 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_22staticsubmit.html#problem-statement",
    "href": "problem9_22staticsubmit.html#problem-statement",
    "title": "Problem 9.22 - Beam Design",
    "section": "",
    "text": "Figure 1: A wide flange beam is subjected to two loads.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.22 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_23staticsubmit.html",
    "href": "problem9_23staticsubmit.html",
    "title": "Problem 9.23 - Beam Design",
    "section": "",
    "text": "Problem Statement\nA wide flange beam supports the distributed load shown, where w0 = 5 kN/m. If length L = 3 m and the allowable stress is œÉ = 150 MPa, what is the lightest W-beam in Appendix A that could be used for the beam?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.23 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_23staticsubmit.html#problem-statement",
    "href": "problem9_23staticsubmit.html#problem-statement",
    "title": "Problem 9.23 - Beam Design",
    "section": "",
    "text": "Figure 1: An I beam is subjected to a triangular load.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.23 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_24staticsubmit.html",
    "href": "problem9_24staticsubmit.html",
    "title": "Problem 9.24 - Beam Design",
    "section": "",
    "text": "Problem Statement\nA wide flange I-beam is fixed at one end into a wall, and loaded with both a distributed load w = 0.5 kN/m and a point load F = 1 kN. If length L = 12 m and the failure stress is 250 MPa, what is the lightest W-beam from Appendix A that could be used for the beam? Use a factor of safety of 2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.24 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_24staticsubmit.html#problem-statement",
    "href": "problem9_24staticsubmit.html#problem-statement",
    "title": "Problem 9.24 - Beam Design",
    "section": "",
    "text": "Figure 1: An I beam is subjected to a distribued load and a tip force.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.24 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_25staticsubmit.html",
    "href": "problem9_25staticsubmit.html",
    "title": "Problem 9.25 - Beam Design",
    "section": "",
    "text": "Problem Statement\nA wide flange I-beam is subjected to both a distributed load w = 4 kN/m and a point load F = 25 kN. If length L1 = 10 m, L2 = 5 m, and the failure stress is 375 MPa, what is the lightest W-beam from Appendix A that could be used for the beam?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.25 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_25staticsubmit.html#problem-statement",
    "href": "problem9_25staticsubmit.html#problem-statement",
    "title": "Problem 9.25 - Beam Design",
    "section": "",
    "text": "Figure 1: A I beam is subjected to a distributed load and a tip load.",
    "crumbs": [
      "Chapter 9",
      "Problem 9.25 - Beam Design"
    ]
  },
  {
    "objectID": "problem9_31staticsubmit.html",
    "href": "problem9_31staticsubmit.html",
    "title": "Problem 9.31 - Unsymmetric Bending",
    "section": "",
    "text": "Problem Statement\nTwo loads, F1 = 8 kips and F2 = 12 kips, are applied at the end of a cantilever beam as shown. Both loads act through the center of the rectangular cross-section of base b = 6 in. and height h = 12 in. If length L = 5 ft, determine the stress at point P in the beam at the wall.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.31 - Unsymmetric Bending"
    ]
  },
  {
    "objectID": "problem9_32staticsubmit.html",
    "href": "problem9_32staticsubmit.html",
    "title": "Problem 9.32 - Unsymmetric Bending",
    "section": "",
    "text": "Problem Statement\nTwo moments, Mz = 1.5 kN-m and My = 1.0 kN-m, act on a beam with the rectangular cross-section shown. If base b = 80 mm and height h = 60 mm, determine the bending stress at point A. Recall the convention that tensile stresses are positive and compressive stresses are negative.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.32 - Unsymmetric Bending"
    ]
  },
  {
    "objectID": "problem9_33staticsubmit.html",
    "href": "problem9_33staticsubmit.html",
    "title": "Problem 9.33 - Unsymmetric Bending",
    "section": "",
    "text": "Problem Statement\nA W14 x 34 steel beam supports a load F = 5 kips at its center. The beam is on a sloped roof so the load acts at an angle Œò = 22¬∞ as shown. If length L = 4 ft, determine the stress at point A. Recall the convention that tensile stresses are positive and compressive stresses are negative.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.33 - Unsymmetric Bending"
    ]
  },
  {
    "objectID": "problem9_34staticsubmit.html",
    "href": "problem9_34staticsubmit.html",
    "title": "Problem 9.34 - Unsymmetric Bending",
    "section": "",
    "text": "Problem Statement\nA cantilevered beam is subjected to a load F = 10 kN at its end, oriented Œò = 25¬∞ from the vertical. If length L = 0.35 m, determine the maximum bending stress in the beam. The beam has outer radius ro = 40 mm and inner radius ri = 30 mm.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 9",
      "Problem 9.34 - Unsymmetric Bending"
    ]
  },
  {
    "objectID": "problem10_1staticsubmit.html",
    "href": "problem10_1staticsubmit.html",
    "title": "Problem 10.1 - 1st Moment of Area",
    "section": "",
    "text": "Problem Statement\nFor the built-up T-beam shown, determine the first moment of area, Q, at point A and at the centroid of the cross-section. Assume dimensions b1 = 1.5 in., b2 = 5.5 in., h1 = 7.5 in., and h2 = 1.5 in.\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.1 - 1st Moment of Area"
    ]
  },
  {
    "objectID": "problem10_4staticsubmit.html",
    "href": "problem10_4staticsubmit.html",
    "title": "Problem 10.4 - Shear Stress",
    "section": "",
    "text": "Problem Statement\nA simply supported beam is constructed from two wooden boards as shown. The beam supports a distributed load w = 3.5 kN/m. If lengths L1 = 1.5 m and L2 = 3 m, what is the maximum shear stress in the glue that holds the boards together?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.4 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_4staticsubmit.html#problem-statement",
    "href": "problem10_4staticsubmit.html#problem-statement",
    "title": "Problem 10.4 - Shear Stress",
    "section": "",
    "text": "Figure 1: A simply supported beam constructed of two wood boards is subjected to a force as shown.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.4 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_5staticsubmit.html",
    "href": "problem10_5staticsubmit.html",
    "title": "Problem 10.5 - Shear Stress",
    "section": "",
    "text": "Problem Statement\nA simply supported beam is constructed from two wooden boards as shown. The beam supports a concentrated load F = 10 kN. If length L = 5 m and cross-section dimensions b = 40 mm and h = 20 mm, determine the shear stress in the glue that holds the boards together.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.5 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_5staticsubmit.html#problem-statement",
    "href": "problem10_5staticsubmit.html#problem-statement",
    "title": "Problem 10.5 - Shear Stress",
    "section": "",
    "text": "Figure 1: A simply supported beam constructed of two wood boards is subjected to a force as shown.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.5 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_6staticsubmit.html",
    "href": "problem10_6staticsubmit.html",
    "title": "Problem 10.6 - Shear Stress",
    "section": "",
    "text": "Problem Statement\nA T-beam has dimensions b1 = 1 in., b2 = 9 in., h1 = 6 in., and h2 = 1 in. If the shear force at this section is V = 5 kips, determine the shear stress at section a-a.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.6 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_6staticsubmit.html#problem-statement",
    "href": "problem10_6staticsubmit.html#problem-statement",
    "title": "Problem 10.6 - Shear Stress",
    "section": "",
    "text": "Figure 1: A T-beam is subjected to a shear load.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.6 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_7staticsubmit.html",
    "href": "problem10_7staticsubmit.html",
    "title": "Problem 10.7 - Shear Stress",
    "section": "",
    "text": "Problem Statement\nA beam of length L = 10 ft is constructed by gluing together two boards and is subjected to a concentrated load F = 500 lb. The cross-section has dimensions b = 3 in. and h = 1 in. Determine the shear stress at the seam between the two boards at section a-a.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.7 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_7staticsubmit.html#problem-statement",
    "href": "problem10_7staticsubmit.html#problem-statement",
    "title": "Problem 10.7 - Shear Stress",
    "section": "",
    "text": "Figure 1: A beam constructed of two sections glued together is subjected to a force.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.7 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_8staticsubmit.html",
    "href": "problem10_8staticsubmit.html",
    "title": "Problem 10.8 - Shear Stress",
    "section": "",
    "text": "Problem Statement\nA cantilever beam is loaded as shown, where w = 1 lb/in., F1 = 5 lb, and F2 = 10 lb. What is the maximum shear stress in the beam?",
    "crumbs": [
      "Chapter 10",
      "Problem 10.8 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_8staticsubmit.html#problem-image",
    "href": "problem10_8staticsubmit.html#problem-image",
    "title": "Problem 10.8 - Shear Stress",
    "section": "Problem Image",
    "text": "Problem Image\n\n\n\nFigure 1: A cantilever beam is subjected to the loading as shown.\n\n\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.8 - Shear Stress"
    ]
  },
  {
    "objectID": "problem10_17staticsubmit.html",
    "href": "problem10_17staticsubmit.html",
    "title": "Problem 10.17 - Shear Flow",
    "section": "",
    "text": "Problem Statement\nA beam of length L = 10 ft is constructed by nailing together two boards with dimensions b = 3.5 in. and h = 1.5 in. The beam is subjected to a concentrated load F = 100 lb as shown. Each nail can withstand a shear load of 100 lb. What is the minimum permissible spacing between nails?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.17 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_17staticsubmit.html#problem-statement",
    "href": "problem10_17staticsubmit.html#problem-statement",
    "title": "Problem 10.17 - Shear Flow",
    "section": "",
    "text": "Figure 1: A cantilever beam constructed of two boards nailed together is subjected to a point load.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.17 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_18staticsubmit.html",
    "href": "problem10_18staticsubmit.html",
    "title": "Problem 10.18 - Shear Flow",
    "section": "",
    "text": "Problem Statement\nA 4-m-long beam is constructed by nailing together two wooden boards as shown. The nails each have a diameter d = 5 mm and can withstand a shear stress of 100 MPa. If loads F1 = 3 kN, F2 = 4 kN, and F3 = 2 kN, determine the maximum permissible spacing between the nails.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.18 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_18staticsubmit.html#problem-statement",
    "href": "problem10_18staticsubmit.html#problem-statement",
    "title": "Problem 10.18 - Shear Flow",
    "section": "",
    "text": "Figure 1: A cantilever beam constructed of two boards nailed together is subjected to the loading as shown.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.18 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_19staticsubmit.html",
    "href": "problem10_19staticsubmit.html",
    "title": "Problem 10.19 - Shear Flow",
    "section": "",
    "text": "Problem Statement\nA beam of length L = 8 ft is constructed by nailing together three wooden boards. The beam is subjected to a concentrated load F = 300 lb. If each nail can resist a shear load of 100 lb, determine the minimum permissible spacing between the nails.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.19 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_19staticsubmit.html#problem-statement",
    "href": "problem10_19staticsubmit.html#problem-statement",
    "title": "Problem 10.19 - Shear Flow",
    "section": "",
    "text": "Figure 1: A simply supported beam consisting of three pieces nailed together is subjected to a point load.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.19 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_20staticsubmit.html",
    "href": "problem10_20staticsubmit.html",
    "title": "Problem 10.20 - Shear Flow",
    "section": "",
    "text": "Problem Statement\nA T-beam is constructed from two wooden boards nailed together as shown. The nails can withstand a shear load of 10 kN and the beam is subjected to a maximum shear force V = 30 kN. If dimensions b1 =20 mm, b2 = 200 mm, h1 = 160 mm, and h2 = 20 mm, determine the minimum permissible spacing between the nails.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.20 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_20staticsubmit.html#problem-statement",
    "href": "problem10_20staticsubmit.html#problem-statement",
    "title": "Problem 10.20 - Shear Flow",
    "section": "",
    "text": "Figure 1: A T-beam is constructed of two plywood sheets nailed together.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.20 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_21staticsubmit.html",
    "href": "problem10_21staticsubmit.html",
    "title": "Problem 10.21 - Shear Flow",
    "section": "",
    "text": "Problem Statement\nA beam is constructed from two boards nailed together as shown, with dimensions b = 3 in., h1 = 1 in., and h2 = 2 in. The nails can withstand a shear load of 850 lb and the beam is subjected to a maximum shear force V = 2 kips. Determine the minimum permissible spacing between the nails.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 10",
      "Problem 10.21 - Shear Flow"
    ]
  },
  {
    "objectID": "problem10_21staticsubmit.html#problem-statement",
    "href": "problem10_21staticsubmit.html#problem-statement",
    "title": "Problem 10.21 - Shear Flow",
    "section": "",
    "text": "Figure 1: A beam is constructed from two pieces nailed together.",
    "crumbs": [
      "Chapter 10",
      "Problem 10.21 - Shear Flow"
    ]
  },
  {
    "objectID": "problem11_1staticsubmit.html",
    "href": "problem11_1staticsubmit.html",
    "title": "Problem 11.1 - By Integration of Moment Equation",
    "section": "",
    "text": "Problem Statement\nA cantilever beam of length L = 7.5 m is subjected to a distributed load w = 6.5 kN/m and concentrated load P = 15 kN. Determine the maximum deflection of the beam. Assume EI = 25,000 kN-m2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.1 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_1staticsubmit.html#problem-statement",
    "href": "problem11_1staticsubmit.html#problem-statement",
    "title": "Problem 11.1 - By Integration of Moment Equation",
    "section": "",
    "text": "Figure 1: A cantilever beam is subjected to the loading shown.",
    "crumbs": [
      "Chapter 11",
      "Problem 11.1 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_2staticsubmit.html",
    "href": "problem11_2staticsubmit.html",
    "title": "Problem 11.2 - By Integration of Moment Equation",
    "section": "",
    "text": "Problem Statement\nA cantilever beam of length L = 1.5 m is subjected to a linear distributed load where w0 = 1 kN/m. Determine the magnitude of the slope of the beam at the free end. Assume EI = 10 kN-m2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.2 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_2staticsubmit.html#problem-statement",
    "href": "problem11_2staticsubmit.html#problem-statement",
    "title": "Problem 11.2 - By Integration of Moment Equation",
    "section": "",
    "text": "Figure 1: A cantilever beam is subjected to the loading shown.",
    "crumbs": [
      "Chapter 11",
      "Problem 11.2 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_3staticsubmit.html",
    "href": "problem11_3staticsubmit.html",
    "title": "Problem 11.3 - By Integration of Moment Equation",
    "section": "",
    "text": "Problem Statement\nA cantilever beam of length L = 4 m is subjected to a distributed load w = 2 kN/m and couple M = 5 kN-m. Determine the deflection of the beam at the free end. Assume EI = 25,000 kN-m2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.3 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_3staticsubmit.html#problem-statement",
    "href": "problem11_3staticsubmit.html#problem-statement",
    "title": "Problem 11.3 - By Integration of Moment Equation",
    "section": "",
    "text": "Figure 1: A cantilever beam is subjected to the loading shown.",
    "crumbs": [
      "Chapter 11",
      "Problem 11.3 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_4staticsubmit.html",
    "href": "problem11_4staticsubmit.html",
    "title": "Problem 11.4 - By Integration of Moment Equation",
    "section": "",
    "text": "Problem Statement\nA cantilever beam of length L = 5.5 m is subjected to a distributed load w = 5.5 kN/m. Determine the magnitude of the deflection of the beam at point B. Assume EI = 25,000 kN-m2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.4 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_4staticsubmit.html#problem-statement",
    "href": "problem11_4staticsubmit.html#problem-statement",
    "title": "Problem 11.4 - By Integration of Moment Equation",
    "section": "",
    "text": "Figure 1: A cantilever beam is subjected to the loading shown.",
    "crumbs": [
      "Chapter 11",
      "Problem 11.4 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_5staticsubmit.html",
    "href": "problem11_5staticsubmit.html",
    "title": "Problem 11.5 - By Integration of Moment Equation",
    "section": "",
    "text": "Problem Statement\nA cantilever beam of length L = 6.5 ft is subjected to a distributed load w = 300 lb/in. and a concentrated load F = 2.5 kips as shown. Determine the magnitude of the deflection of the beam at point B. Assume EI = 45,000 kip-in.2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.5 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_5staticsubmit.html#problem-statement",
    "href": "problem11_5staticsubmit.html#problem-statement",
    "title": "Problem 11.5 - By Integration of Moment Equation",
    "section": "",
    "text": "Figure 1: A simply supported beam is subjected to the loading shown.",
    "crumbs": [
      "Chapter 11",
      "Problem 11.5 - By Integration of Moment Equation"
    ]
  },
  {
    "objectID": "problem11_17staticsubmit.html",
    "href": "problem11_17staticsubmit.html",
    "title": "Problem 11.17 - By Integration of Load Equation",
    "section": "",
    "text": "Problem Statement\nA beam of length L = 10 m is subjected to a distributed load as shown where w0 = 35 kN/m. Determine the magnitude of the deflection at x = 0.55L. Assume EI = 15,000 kN-m2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.17 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_17staticsubmit.html#problem-statement",
    "href": "problem11_17staticsubmit.html#problem-statement",
    "title": "Problem 11.17 - By Integration of Load Equation",
    "section": "",
    "text": "Figure 1: A simply supported beam is subjected to the loading shown.",
    "crumbs": [
      "Chapter 11",
      "Problem 11.17 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_18staticsubmit.html",
    "href": "problem11_18staticsubmit.html",
    "title": "Problem 11.18 - By Integration of Load Equation",
    "section": "",
    "text": "Problem Statement\nA beam of length L = 10 ft is subjected to a distributed load as shown where w0 = 50 kip/ft. Determine the magnitude of the deflection at x = 0.5L. Assume EI = 45,000 kip-ft2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.18 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_18staticsubmit.html#problem-statement",
    "href": "problem11_18staticsubmit.html#problem-statement",
    "title": "Problem 11.18 - By Integration of Load Equation",
    "section": "",
    "text": "Figure 1: A simply supported beam is subjected to the loading shown.",
    "crumbs": [
      "Chapter 11",
      "Problem 11.18 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_19staticsubmit.html",
    "href": "problem11_19staticsubmit.html",
    "title": "Problem 11.19 - By Integration of Load Equation",
    "section": "",
    "text": "Problem Statement\nA beam of length L = 15 ft is subjected to a distributed load as shown where w0 = 25 kip/ft. Determine the magnitude of the deflection at x = 0.5L. Assume EI = 45,000 kip-ft2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.19 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_19staticsubmit.html#problem-statement",
    "href": "problem11_19staticsubmit.html#problem-statement",
    "title": "Problem 11.19 - By Integration of Load Equation",
    "section": "",
    "text": "Figure 1: A cantilever beam is subjected to the loading shown.",
    "crumbs": [
      "Chapter 11",
      "Problem 11.19 - By Integration of Load Equation"
    ]
  },
  {
    "objectID": "problem11_22staticsubmit.html",
    "href": "problem11_22staticsubmit.html",
    "title": "Problem 11.22 - By Superposition",
    "section": "",
    "text": "Problem Statement\nA cantilever beam is loaded as shown where L = 10 m, M = 50 kN-m, and F = 50 kN. Determine the magnitude of the deflection at the free end of the beam. Assume EI = 45000 kN-m2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.22 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_23staticsubmit.html",
    "href": "problem11_23staticsubmit.html",
    "title": "Problem 11.23 - By Superposition",
    "section": "",
    "text": "Problem Statement\nA simply supported beam is loaded as shown where L = 5 m, M = 2 kN-m, w = 1.5 kN/m, and F = 1 kN. Determine the magnitude of the deflection at the center of the beam. Assume EI = 30000 kN-m2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.23 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_24staticsubmit.html",
    "href": "problem11_24staticsubmit.html",
    "title": "Problem 11.24 - By Superposition",
    "section": "",
    "text": "Problem Statement\nA simply supported beam is loaded as shown where L = 2 m, w1 = 2 kN/m, and w2 = 3 kN/m. Determine the magnitude of the deflection at the center of the beam. Assume EI = 30,000 kN-m2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.24 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_25staticsubmit.html",
    "href": "problem11_25staticsubmit.html",
    "title": "Problem 11.25 - By Superposition",
    "section": "",
    "text": "Problem Statement\nAn overhanging beam is loaded as shown where L = 7.5 m and w = 7.5 kN/m. Determine the magnitude of the deflection at point A. Assume EI = 30,000 kN-m2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.25 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_26staticsubmit.html",
    "href": "problem11_26staticsubmit.html",
    "title": "Problem 11.26 - By Superposition",
    "section": "",
    "text": "Problem Statement\nAn overhanging beam is loaded as shown where L1 = 7 ft, L2 = 5 ft, and w = 200 kip/ft. Determine the deflection at the point C. Assume EI = 29,000 kip-ft2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.26 - By Superposition"
    ]
  },
  {
    "objectID": "problem11_36staticsubmit.html",
    "href": "problem11_36staticsubmit.html",
    "title": "Problem 11.36 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA beam of length L1 = 3 ft and L2 = 6 ft is subjected to a distributed load w = 250 kip/ft as shown. Determine the reaction force at support B. Assume EI = 20,000 kip-ft2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.36 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem11_37staticsubmit.html",
    "href": "problem11_37staticsubmit.html",
    "title": "Problem 11.37 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA beam is subjected to two distributed loads, w1 = 2 kN/m and w2 = 3 kN/m as shown. It is supported by a pin at A and rollers at B and C. If length L = 2 m, determine the reaction force at support B. Assume EI = 30,000 kN-m2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.37 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem11_38staticsubmit.html",
    "href": "problem11_38staticsubmit.html",
    "title": "Problem 11.38 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA propped cantilever beam is subjected to a distributed load w = 2 kip/ft as shown. If length L1 = 2 ft, L2 = 3 ft, and L3 = 3 ft, determine the magnitude of the moment reaction at the wall. Assume EI = 20,000 kip-ft2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.38 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem11_39staticsubmit.html",
    "href": "problem11_39staticsubmit.html",
    "title": "Problem 11.39 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA beam is subjected to force F = 155 kN as shown. If length L = 4 m, determine the reaction force at support B. Assume EI = 30,000 kN-m2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.39 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem11_40staticsubmit.html",
    "href": "problem11_40staticsubmit.html",
    "title": "Problem 11.40 - Statically Indeterminate Problems",
    "section": "",
    "text": "Problem Statement\nA beam is subjected to force F = 10 kN as shown. If length L = 2 m, determine the reaction force at support B. Assume EI = 12,500 kN-m2.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.40 - Statically Indeterminate Problems"
    ]
  },
  {
    "objectID": "problem11_50staticsubmit.html",
    "href": "problem11_50staticsubmit.html",
    "title": "Problem 11.50 - Intermediate Beam Design",
    "section": "",
    "text": "Problem Statement\nA W18 x 76 shape (E = 29,000 ksi) is to be simply-supported and carry a uniform distributed load, œâ. If the beam has an allowable bending stress œÉ = 34 ksi, allowable shear stress œÑ = 14 ksi, and allowable deflection of span/240, determine the maximum load, œâ, for a span L = 30 ft. Ignore self-weight.\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.50 - Intermediate Beam Design"
    ]
  },
  {
    "objectID": "problem11_50staticsubmit.html#problem-statement",
    "href": "problem11_50staticsubmit.html#problem-statement",
    "title": "Problem 11.50 - Intermediate Beam Design",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"681\"\nsigma=reactive.Value(\"__\")\ntau=reactive.Value(\"__\")\nL=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of kip/ft\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A W18 x 76 shape (E = 29,000 ksi) is to be simply-supported and carry a uniform distributed load, œâ. If the beam has an allowable bending stress œÉ = {sigma()} ksi, allowable shear stress œÑ = {tau()} ksi, and allowable deflection of span/240, determine the maximum load, œâ, for a span L = {L()} ft. Ignore self-weight.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        sigma.set(random.randrange(20, 30, 1))\n        tau.set(sigma()-random.randrange(6, 12, 1))\n        L.set(random.randrange(20, 40, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        instr= 8*146*sigma()/(L()*12)**2*12\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11",
      "Problem 11.50 - Intermediate Beam Design"
    ]
  },
  {
    "objectID": "problem11_51staticsubmit.html",
    "href": "problem11_51staticsubmit.html",
    "title": "Problem 11.51 - Intermediate Beam Design",
    "section": "",
    "text": "Problem Statement\nA window manufacturer is considering maximum sizes possible for a hollow aluminum tube section (E = 67 GPa). The tube will be simply-supported with a uniform distributed load, œâ = 6.2 kN/m. If the aluminum tube has an allowable bending stress œÉ = 250 MPa, allowable shear stress œÑ = 150 MPa, and deflection limit of span/480, determine the longest span allowed. Assume dimensions b = 102 mm and h = 154 mm.\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.51 - Intermediate Beam Design"
    ]
  },
  {
    "objectID": "problem11_51staticsubmit.html#problem-statement",
    "href": "problem11_51staticsubmit.html#problem-statement",
    "title": "Problem 11.51 - Intermediate Beam Design",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#| components: [viewer]\n\nfrom shiny import App, render, ui, reactive\nimport random\nimport asyncio\nimport io\nimport math\nimport string\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef generate_random_letters(length):\n    # Generate a random string of letters of specified length\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))  \n\nproblem_ID=\"682\"\nw=reactive.Value(\"__\")\nb=reactive.Value(\"__\")\nh=reactive.Value(\"__\")\n  \nattempts=[\"Timestamp,Attempt,Answer,Feedback\\n\"]\n\napp_ui = ui.page_fluid(\n    ui.markdown(\"**Please enter your ID number from your instructor and click to generate your problem**\"),\n    ui.input_text(\"ID\",\"\", placeholder=\"Enter ID Number Here\"),\n    ui.input_action_button(\"generate_problem\", \"Generate Problem\", class_=\"btn-primary\"),\n    ui.markdown(\"**Problem Statement**\"),\n    ui.output_ui(\"ui_problem_statement\"),\n    ui.input_text(\"answer\",\"Your Answer in units of m\", placeholder=\"Please enter your answer\"),\n    ui.input_action_button(\"submit\", \"Submit Answer\", class_=\"btn-primary\"),\n    ui.download_button(\"download\", \"Download File to Submit\", class_=\"btn-success\"),\n)\n\ndef server(input, output, session):\n    # Initialize a counter for attempts\n    attempt_counter = reactive.Value(0)\n\n    @output\n    @render.ui\n    def ui_problem_statement():\n        return[ui.markdown(f\"A window manufacturer is considering maximum sizes possible for a hollow aluminum tube section (E = 67 GPa). The tube will be simply-supported with a uniform distributed load, œâ = {w()} kN/m. If the aluminum tube has an allowable bending stress œÉ = 250 MPa, allowable shear stress œÑ = 150 MPa, and deflection limit of span/480, determine the longest span allowed. Assume dimensions b = {b()} mm and h = {h()} mm.\")]\n    \n    @reactive.Effect\n    @reactive.event(input.generate_problem)\n    def randomize_vars():\n        random.seed(input.ID())\n        w.set(random.randrange(50, 100, 1)/10)\n        b.set(random.randrange(80, 120, 1))\n        h.set(random.randrange(150, 200, 1))\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        attempt_counter.set(attempt_counter() + 1)  # Increment the attempt counter on each submission.\n        I = b()*h()**3/12-((b()-7.4)*(h()-7.4)**3/12)\n        instr= (384*67*I/(2400*w()/1000))**(1/3)/1000\n        if math.isclose(float(input.answer()), instr, rel_tol=0.01):\n            check = \"*Correct*\"\n            correct_indicator = \"JL\"\n        else:\n            check = \"*Not Correct.*\"\n            correct_indicator = \"JG\"\n\n        # Generate random parts for the encoded attempt.\n        random_start = generate_random_letters(4)\n        random_middle = generate_random_letters(4)\n        random_end = generate_random_letters(4)\n        encoded_attempt = f\"{random_start}{problem_ID}-{random_middle}{attempt_counter()}{correct_indicator}-{random_end}{input.ID()}\"\n\n        # Store the most recent encoded attempt in a reactive value so it persists across submissions\n        session.encoded_attempt = reactive.Value(encoded_attempt)\n\n        # Append the attempt data to the attempts list without the encoded attempt\n        attempts.append(f\"{datetime.now()}, {attempt_counter()}, {input.answer()}, {check}\\n\")\n\n        # Show feedback to the user.\n        feedback = ui.markdown(f\"Your answer of {input.answer()} is {check}.\")\n        m = ui.modal(\n            feedback,\n            title=\"Feedback\",\n            easy_close=True\n        )\n        ui.modal_show(m)\n\n    @session.download(filename=lambda: f\"Problem_Log-{problem_ID}-{input.ID()}.csv\")\n    async def download():\n        # Start the CSV with the encoded attempt (without label)\n        final_encoded = session.encoded_attempt() if session.encoded_attempt is not None else \"No attempts\"\n        yield f\"{final_encoded}\\n\\n\"\n        \n        # Write the header for the remaining CSV data once\n        yield \"Timestamp,Attempt,Answer,Feedback\\n\"\n        \n        # Write the attempts data, ensure that the header from the attempts list is not written again\n        for attempt in attempts[1:]:  # Skip the first element which is the header\n            await asyncio.sleep(0.25)  # This delay may not be necessary; adjust as needed\n            yield attempt\n\n# App installation\napp = App(app_ui, server)",
    "crumbs": [
      "Chapter 11",
      "Problem 11.51 - Intermediate Beam Design"
    ]
  },
  {
    "objectID": "problem11_53staticsubmit.html",
    "href": "problem11_53staticsubmit.html",
    "title": "Problem 11.53 - Intermediate Beam Design",
    "section": "",
    "text": "Problem Statement\nA pipe with an outer diameter of 100 mm is to be used as a cantilever beam of length L = 2.5 m carrying a load P = 6.8 kN at the free end. Determine the minimum required pipe wall thickness if the allowable bending stress, œÉallow = 400 MPa, the allowable shear stress, œÑallow = 240 MPa, and the allowable deflection = 50 mm. Assume E = 200 GPa.\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 11",
      "Problem 11.53 - Intermediate Beam Design"
    ]
  },
  {
    "objectID": "problem12_1staticsubmit.html",
    "href": "problem12_1staticsubmit.html",
    "title": "Problem 12.1 - Equations",
    "section": "",
    "text": "Problem Statement\nA point in a beam is subjected to the state of stress shown, where œÉx = 20 ksi, œÉy = 35 ksi, and œÑxy = 15 ksi. Determine the normal stress acting on plane a-a if angle Œò = 25¬∞.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.1 - Equations"
    ]
  },
  {
    "objectID": "problem12_2staticsubmit.html",
    "href": "problem12_2staticsubmit.html",
    "title": "Problem 12.2 - Equations",
    "section": "",
    "text": "Problem Statement\nA point in a beam is subjected to the state of stress shown, where œÉx = 12 MPa, œÉy = 24 MPa, and œÑxy = 6 MPa. Determine the normal stress acting on plane a-a if angle Œò = 25¬∞.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.2 - Equations"
    ]
  },
  {
    "objectID": "problem12_3staticsubmit.html",
    "href": "problem12_3staticsubmit.html",
    "title": "Problem 12.3 - Equations",
    "section": "",
    "text": "Problem Statement\nA point in a beam is subjected to the state of stress shown, where œÉx = 5.0 MPa, œÉy = 12.5 MPa, and œÑxy = 3.5 MPa. Determine the magnitude of the normal stress and the magnitude of the shear stress acting on plane a-a if angle Œò = 67¬∞.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.3 - Equations"
    ]
  },
  {
    "objectID": "problem12_4staticsubmit.html",
    "href": "problem12_4staticsubmit.html",
    "title": "Problem 12.4 - Equations",
    "section": "",
    "text": "Problem Statement\nA material made from fibers is stressed as shown in the diagram. Stresses œÉx = 20 ksi, œÉy = 10 ksi, and œÑxy = 10 ksi. Determine the magnitude of the normal stress acting perpendicular to the fibers and the magnitude of the shear stress acting parallel to the fibers if angle Œò = 20¬∞.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.4 - Equations"
    ]
  },
  {
    "objectID": "problem12_5staticsubmit.html",
    "href": "problem12_5staticsubmit.html",
    "title": "Problem 12.5 - Equations",
    "section": "",
    "text": "Problem Statement\nA material made from fibers is stressed as shown in the diagram. Stresses œÉx = 45 ksi, œÉy = 5 ksi, and œÑxy = 10 ksi. Determine the magnitude of the normal stress acting perpendicular to the fibers and the magnitude of the shear stress acting parallel to the fibers if angle Œò = 18¬∞.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.5 - Equations"
    ]
  },
  {
    "objectID": "problem12_9staticsubmit.html",
    "href": "problem12_9staticsubmit.html",
    "title": "Problem 12.9 - Principal Stresses",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where œÉx = 30 MPa, œÉy = 20 MPa, and œÑxy = 15 MPa. Determine the maximum principal stress œÉ1 for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.9 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_10staticsubmit.html",
    "href": "problem12_10staticsubmit.html",
    "title": "Problem 12.10 - Principal Stresses",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where œÉx = 30 ksi, œÉy = 10 ksi, and œÑxy = 15 ksi. Determine the maximum shear stress for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.10 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_11staticsubmit.html",
    "href": "problem12_11staticsubmit.html",
    "title": "Problem 12.11 - Principal Stresses",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where œÉx = 35.8 ksi, œÉy = 11.5 ksi, and œÑxy = 56.3 ksi. Determine the maximum shear stress for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.11 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_11staticsubmit.html#problem-statement",
    "href": "problem12_11staticsubmit.html#problem-statement",
    "title": "Problem 12.11 - Principal Stresses",
    "section": "",
    "text": "Figure 1: A member is subjected to a state of stress.",
    "crumbs": [
      "Chapter 12",
      "Problem 12.11 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_12staticsubmit.html",
    "href": "problem12_12staticsubmit.html",
    "title": "Problem 12.12 - Principal Stresses",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where œÉx = 3 MPa, œÉy = 5 MPa, and œÑxy = 3 MPa. Determine the maximum principal stress œÉ1 for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.12 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_13staticsubmit.html",
    "href": "problem12_13staticsubmit.html",
    "title": "Problem 12.13 - Principal Stresses",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where œÉx = 25 ksi, œÉy = 15 ksi, and œÑxy is unknown. The maximum shear stress for this state of stress is œÑmax = 30 ksi. Determine the angle that this maximum stress occurs at.\n{fig-alt=A member is subjected to a state of stress caused by sigma_x, and sigma_y.‚Äù} [Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.13 - Principal Stresses"
    ]
  },
  {
    "objectID": "problem12_25staticsubmit.html",
    "href": "problem12_25staticsubmit.html",
    "title": "Problem 12.25 - Mohr‚Äôs Circle",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where œÉx = 30 ksi, œÉy = 20 ksi, and œÑxy = 10 ksi. Construct Mohr‚Äôs Circle for the given state of stress. Then determine the maximum principal stress œÉ1 for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.25 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_26staticsubmit.html",
    "href": "problem12_26staticsubmit.html",
    "title": "Problem 12.26 - Mohr‚Äôs Circle",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where œÉx = 20 MPa, œÉy = 10 MPa, and œÑxy = 10 MPa. Construct Mohr‚Äôs Circle for the given state of stress. Then determine the maximum principal stress œÉ1 for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.26 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_27staticsubmit.html",
    "href": "problem12_27staticsubmit.html",
    "title": "Problem 12.27 - Mohr‚Äôs Circle",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where œÉx = 10 MPa, œÉy = 10 MPa, and œÑxy = 5 MPa. Construct Mohr‚Äôs Circle for the given state of stress. Then determine the maximum in-plane shear stress œÑmax for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.27 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_28staticsubmit.html",
    "href": "problem12_28staticsubmit.html",
    "title": "Problem 12.28 - Mohr‚Äôs Circle",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where œÉx = 35 ksi, œÉy = 15 ksi, and œÑxy = 25 ksi. Construct Mohr‚Äôs Circle for the given state of stress. Then determine the maximum principal stress œÉ1 for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.28 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_29staticsubmit.html",
    "href": "problem12_29staticsubmit.html",
    "title": "Problem 12.29 - Mohr‚Äôs Circle",
    "section": "",
    "text": "Problem Statement\nThe state of stress at a point in a beam is shown, where œÉx = 13.2 ksi, œÉy = 7.5 ksi, and œÑxy = 1.8 ksi. Construct Mohr‚Äôs Circle for the given state of stress. Then determine the maximum principal stress œÉ1 for this state of stress, and the angle at which this stress occurs, measured counterclockwise from the x-axis.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.29 - Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_39staticsubmit.html",
    "href": "problem12_39staticsubmit.html",
    "title": "Problem 12.39 - 3D Mohr‚Äôs Circle",
    "section": "",
    "text": "Problem Statement\nA plane stress state results in principal stress œÉ1 = 435 MPa and œÉ2 = -124 MPa. Use Mohr‚Äôs Circle to determine the maximum in-plane and maximum absolute shear stresses.\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.39 - 3D Mohr's Circle"
    ]
  },
  {
    "objectID": "problem12_40staticsubmit.html",
    "href": "problem12_40staticsubmit.html",
    "title": "Problem 12.40 - 3D Mohr‚Äôs Circle",
    "section": "",
    "text": "Problem Statement\nA plane stress state results in principal stress œÉ1 = 3.2 ksi and œÑmax-in-plane = 1.04 ksi. Use Mohr‚Äôs Circle to determine œÉ2 and the maximum absolute shear stresses.\n[Problem adapted from ¬© Chris Galitz CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 12",
      "Problem 12.40 - 3D Mohr's Circle"
    ]
  },
  {
    "objectID": "problem13_1staticsubmit.html",
    "href": "problem13_1staticsubmit.html",
    "title": "Problem 13.1 - Cylindrical",
    "section": "",
    "text": "Problem Statement\nA thin-walled cylindrical pressure vessel with an outside diameter d = 18 in. is subjected to an internal pressure P = 100 psi and an external torque T = 180 kip-in. at its top. The base is fixed to the ground. If the vessel wall thickness is t = 0.25 in., determine the absolute largest principal stress in the vessel wall.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 13",
      "Problem 13.1 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_2staticsubmit.html",
    "href": "problem13_2staticsubmit.html",
    "title": "Problem 13.2 - Cylindrical",
    "section": "",
    "text": "Problem Statement\nA cylindrical pressure vessel of outer diameter d = 750 mm experiences an internal pressure P = 20 kPa. Determine the maximum in-plane shear stress in the vessel wall if the wall thickness is t = 10 mm.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 13",
      "Problem 13.2 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_3staticsubmit.html",
    "href": "problem13_3staticsubmit.html",
    "title": "Problem 13.3 - Cylindrical",
    "section": "",
    "text": "Problem Statement\nA gas storage tank with an internal radius ri = 18 in. and wall thickness t = 3/8 in. is filled to an internal pressure P = 2,000 psi. If the original length L = 18 ft., determine the total axial deflection (change in length) of the tank after filling. Assume E = 29,000 ksi and ŒΩ = 0.3.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 13",
      "Problem 13.3 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_4staticsubmit.html",
    "href": "problem13_4staticsubmit.html",
    "title": "Problem 13.4 - Cylindrical",
    "section": "",
    "text": "Problem Statement\nA cylindrical thin-walled pressure vessel with an inner diameter di = 240 mm is subjected to an unknown internal pressure, P. A vertical load F = 1 kN is also applied to the vessel as shown. If length L = 3.2 m and the wall thickness t = 1 mm, what pressure will cause the axial and hoop stresses to be equal?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 13",
      "Problem 13.4 - Cylindrical"
    ]
  },
  {
    "objectID": "problem13_15staticsubmit.html",
    "href": "problem13_15staticsubmit.html",
    "title": "Problem 13.15 - Spherical",
    "section": "",
    "text": "Problem Statement\nA balloon with a wall thickness of 0.02 in. is inflated to a pressure of 30 psi. If the balloon material fails in tension at 8,000 psi, what is the maximum radius of the balloon using a factor of safety of 2?\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 13",
      "Problem 13.15 - Spherical"
    ]
  },
  {
    "objectID": "problem13_16staticsubmit.html",
    "href": "problem13_16staticsubmit.html",
    "title": "Problem 13.16 - Spherical",
    "section": "",
    "text": "Problem Statement\nA spherical thin-walled pressure vessel is to be constructed of steel with a yield stress of 50 ksi and a wall thickness t = 1/4 in. If the internal diameter of the tank is di = 20 ft, determine the maximum allowable pressure before yielding.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 13",
      "Problem 13.16 - Spherical"
    ]
  },
  {
    "objectID": "problem14_1staticsubmit.html",
    "href": "problem14_1staticsubmit.html",
    "title": "Problem 14.1 - Eccentric Axial Loads",
    "section": "",
    "text": "Problem Statement\nA large column supports a cantilevered load W = 8 kips as shown. Dimensions b = 2 ft, h = 4 ft, L1 = 10 ft, and L2 = 10 ft. What is the magnitude of the compressive stress at point A? Assume the cantilevered beam does not fail or bend.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 14",
      "Problem 14.1 - Eccentric Axial Loads"
    ]
  },
  {
    "objectID": "problem14_2staticsubmit.html",
    "href": "problem14_2staticsubmit.html",
    "title": "Problem 14.2 - Eccentric Axial Loads",
    "section": "",
    "text": "Problem Statement\nA metal electric pole supporting a load F = 50 kN was knocked at an angle during a recent storm. If dimensions x = 2000 mm, y = 1000 mm, and L = 8 m, determine the magnitude of the maximum normal stress at the base.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 14",
      "Problem 14.2 - Eccentric Axial Loads"
    ]
  },
  {
    "objectID": "problem14_9staticsubmit.html",
    "href": "problem14_9staticsubmit.html",
    "title": "Problem 14.9 - General Combined Loads",
    "section": "",
    "text": "Problem Statement\nA solid circular rod of length L = 6 m and radius r = 35 mm is subjected to axial load F = 17.5 kN and torsional moment T = 17.5 kN-m. Determine the absolute maximum shear stress (for any coordinate direction) at any location in the bar.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 14",
      "Problem 14.9 - General Combined Loads"
    ]
  },
  {
    "objectID": "problem14_10staticsubmit.html",
    "href": "problem14_10staticsubmit.html",
    "title": "Problem 14.10 - General Combined Loads",
    "section": "",
    "text": "Problem Statement\nA solid circular rod of length L = 2 ft and radius r = 2 in. is subjected to load F = 0.5 kips and torsional moment T = 12 kip-in. Determine the maximum principal stress at point A.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 14",
      "Problem 14.10 - General Combined Loads"
    ]
  },
  {
    "objectID": "problem14_11staticsubmit.html",
    "href": "problem14_11staticsubmit.html",
    "title": "Problem 14.11 - General Combined Loads",
    "section": "",
    "text": "Problem Statement\nA solid circular rod of length L = 1.2 m and radius r = 50 mm is subjected to load F = 1 kN and torsional moment T = 0.5 kN-m. Determine the absolute maximum normal stress at point A.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 14",
      "Problem 14.11 - General Combined Loads"
    ]
  },
  {
    "objectID": "problem15_1staticsubmit.html",
    "href": "problem15_1staticsubmit.html",
    "title": "Problem 15.1 - Buckling & Yield - Euler‚Äôs Formula",
    "section": "",
    "text": "Problem Statement\nA steel (E = 200 GPa) tube column with a yield strength of 250 MPa is pinned at both ends. If length L = 6 m, outer radius ro = 75 mm and inner radius ri = 70 mm, determine the maximum allowable load the column can support.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 15",
      "Problem 15.1 - Buckling & Yield - Euler's Formula"
    ]
  },
  {
    "objectID": "problem15_2staticsubmit.html",
    "href": "problem15_2staticsubmit.html",
    "title": "Problem 15.2 - Buckling & Yield - Euler‚Äôs Formula",
    "section": "",
    "text": "Problem Statement\nA W14 x 34 beam is used as a column that is pinned at both ends. If length L = 30 ft and the elastic modulus E = 280 x 106 psi, determine the critical stress for the column.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 15",
      "Problem 15.2 - Buckling & Yield - Euler's Formula"
    ]
  },
  {
    "objectID": "problem15_3staticsubmit.html",
    "href": "problem15_3staticsubmit.html",
    "title": "Problem 15.3 - Buckling & Yield - Euler‚Äôs Formula",
    "section": "",
    "text": "Problem Statement\nA column is pinned at both ends and supports a load F = 500 kN. Determine the maximum allowable column length, L. Use a factor of safety of 2 and assume the elastic modulus E = 200 GPa.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 15",
      "Problem 15.3 - Buckling & Yield - Euler's Formula"
    ]
  },
  {
    "objectID": "problem15_11staticsubmit.html",
    "href": "problem15_11staticsubmit.html",
    "title": "Problem 15.11 - Effect of Supports",
    "section": "",
    "text": "Problem Statement\nA column with a square cross-section is used to support a force F = 5 kips. The column is fixed at its base and free at the other end. If length L = 18 ft and elastic modulus E = 29,000 ksi, determine the minimum dimension, h, so that the column will not buckle.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 15",
      "Problem 15.11 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem15_12staticsubmit.html",
    "href": "problem15_12staticsubmit.html",
    "title": "Problem 15.12 - Effect of Supports",
    "section": "",
    "text": "Problem Statement\nA W16 x 40 beam is used as a column with a length L = 20 ft. It is fixed at both ends and subjected to load F = 300 kips. If the elastic modulus E = 29,000 ksi, determine the factor of safety with respect to buckling.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 15",
      "Problem 15.12 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem15_13staticsubmit.html",
    "href": "problem15_13staticsubmit.html",
    "title": "Problem 15.13 - Effect of Supports",
    "section": "",
    "text": "Problem Statement\nA W8 x 15 beam (Ix = 48.0 in.4, Iy = 3.41 in.4) is used as a column with one end fixed and the other end pinned. If the length of the column L = 25 ft, determine the largest load it can carry with a factor of safety of 2. The elastic modulus E = 10,000 ksi.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 15",
      "Problem 15.13 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem15_14staticsubmit.html",
    "href": "problem15_14staticsubmit.html",
    "title": "Problem 15.14 - Effect of Supports",
    "section": "",
    "text": "Problem Statement\nA wide-flange column that is fixed at both ends is required to carry a load F = 500 kips. If length L = 30 ft and the elastic modulus E = 29,000 ksi, determine the lightest structural member in Appendix A that can be used. Use a factor of safety of 2 against buckling.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 15",
      "Problem 15.14 - Effect of Supports"
    ]
  },
  {
    "objectID": "problem15_15staticsubmit.html",
    "href": "problem15_15staticsubmit.html",
    "title": "Problem 15.15 - Effect of Supports",
    "section": "",
    "text": "Problem Statement\nTo draw attention, a junkyard owner mounts a car on top of a column of length L = 30 ft made from a W8 x 15 beam (Ix = 48.0 in.4, Iy = 3.41 in.4). If the elastic modulus E = 29,000 ksi, what is the heaviest car body that can be used to avoid buckling? Use a factor of safety of 2.25.\n[Problem adapted from ¬© Kurt Gramoll CC BY NC-SA 4.0]",
    "crumbs": [
      "Chapter 15",
      "Problem 15.15 - Effect of Supports"
    ]
  }
]