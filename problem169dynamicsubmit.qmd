# Dynamic Problem Statement {.unnumbered}

This is a dynamic rendering of the problem with dynamic variables based on the username entered. 


## Problem Image

![Figure 1: A steel connector plate is hung from a brass rod.](images/169.png){fig-alt="Picture with a steel connector plate hung from a brass rod. The brass rod is fixed at both ends. The connector plate has a diameter d and thickness t."}

```{shinylive-python}
#| standalone: true
#| viewerHeight: 600
#| components: [viewer]

from shiny import App, render, ui, reactive
import random
import asyncio
import io
import math
from datetime import datetime
from pathlib import Path

problem_ID="169"
d=reactive.Value("__")
t=reactive.Value("__")
W=reactive.Value("__")
Fbrass = 70
Fsteel = 75


attempts=["Timestamp,Attempt,Answer,Feedback\n"]

app_ui = ui.page_fluid(
    ui.markdown("**Please enter your ID number from your instructor and click to generate your problem**"),
    ui.input_text("ID","", placeholder="Enter ID Number Here"),
    ui.input_action_button("generate_problem", "Generate Problem", class_="btn-primary"),
    ui.markdown("**Problem Statement**"),
    ui.output_ui("ui_problem_statement"),
    ui.input_text("answer","Your Answer in units of inches", placeholder="Please enter your answer"),
    ui.input_action_button("submit", "Submit Answer", class_="btn-primary"),
    ui.download_button("download", "Download File to Submit", class_="btn-success"),
)


def server(input, output, session):
    @output
    @render.ui
    def ui_problem_statement():
        return[ui.markdown(f"A steel connector plate is hung from a brass rod of diameter {d()} = in. The plate has dimensions {t()} = in. and {w()} = in. Find the minimum load that will cause the connector or rod to fail. Assume the tensile and compressive failure stress for brass is 70 ksi and for steel is 75 ksi. Assume the shear failure stress for each material is one half of the tensile-compressive failure stress. ")]
    
    @reactive.Effect
    @reactive.event(input.generate_problem)
    def randomize_vars():
        random.seed(input.ID())
        d.set(random.randrange(0.8, 2, 0.1))
        t.set(random.randrange(0.3, 0.7, 0.1))
        w.set(d*2)
        

    @reactive.Effect
    @reactive.event(input.submit)
    def _():
        
        instr= (Fsteel()/2)*(2*.866*d()/2)
        #check=math.isclose(float(input.answer()),instr,rel_tol=0.001)
        if math.isclose(float(input.answer()),instr,rel_tol=0.001):
           check="*Correct*"
        else:
           check="*Not Correct.*"
        
        correct_indicator = "JL" if check == "*Correct*" else "JG"
        
        feedback=ui.markdown(f"Your answer of {input.answer()} is {check}.  For reference in debugging this, the calculated instructor answer is {instr}")
        attempts.append(f"{datetime.now()}, {input.submit()},{input.answer()},{check}\n")
        m=ui.modal(
          feedback,
          title="Feedback",
          easy_close=True
        )
        ui.modal_show(m)
    import random
    import string

def generate_random_letters(length):
    # Generate a random string of letters of specified length
    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))   

random_start = generate_random_letters(4)  
random_end = generate_random_letters(4)    

encoded_attempt = f"{random_start}{problem_ID}apoj{len(attempts)+1}{correct_indicator}{random_end}{input.ID()}"


attempts.append(f"{datetime.now()}, {encoded_attempt}\n")

    @session.download(
        filename=lambda: f"Problem_Log-{problem_ID}-{input.ID()}.csv"
    )
    async def download():
        # This version uses a function to generate the filename. It also yields data
        # multiple times.
        yield "Timestamp,Encoded Attempt\n"
   
        for attempt in attempts:
          await asyncio.sleep(0.25) 
          yield attempt

app = App(app_ui, server)

```
